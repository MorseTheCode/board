<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Evidence Board</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            body {
                font-family: 'Inter', sans-serif;
                user-select: none;
            }

            textarea, [contenteditable="true"] {
                user-select: text;
            }

            #board {
                background-color: transparent;
                position: relative;
                overflow: hidden;
            }

            #canvas-container {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                transform-origin: 0 0;
                will-change: transform;
            }

            #svg-layer-connections, #svg-layer-drawings {
                position: absolute;
                top: -10000px;
                left: -10000px;
                overflow: visible;
            }

            #svg-layer-connections {
                z-index: 6;
            }

            #svg-layer-drawings {
                z-index: 5;
            }

            #selection-box {
                position: absolute;
                border: 1px dashed #38bdf8;
                background: rgba(56, 189, 248, 0.1);
                z-index: 1000;
                display: none;
                pointer-events: none;
            }

            #users-modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                backdrop-filter: blur(5px);
                z-index: 10000;
                display: none;
                align-items: center;
                justify-content: center;
            }
            #users-modal {
                width: 400px;
                max-width: 90%;
                padding: 20px;
                z-index: 10001;
            }
            #users-list li {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 8px;
                border-bottom: 1px solid #334155;
            }
            #users-list li:last-child {
                border-bottom: none;
            }
            .role-badge {
                font-size: 0.75rem;
                padding: 2px 6px;
                border-radius: 12px;
                font-weight: 600;
            }
            .role-owner { background-color: #f43f5e; color: white; }
            .role-editor { background-color: #3b82f6; color: white; }
            .role-viewer { background-color: #475569; color: #e2e8f0; }

            .permission-btn {
                font-size: 0.8rem;
                padding: 3px 8px;
                border-radius: 6px;
                margin-left: 5px;
                background-color: #334155;
                color: #e2e8f0;
                cursor: pointer;
            }
            .permission-btn:hover {
                background-color: #475569;
            }
            .permission-btn.promote { background-color: #2563eb; color: white; }
            .permission-btn.demote { background-color: #94a3b8; color: #1e293b; }
            .permission-btn.kick { background-color: #b91c1c; color: white; }

            #sidebar-menu {
                background: rgb(30 41 59 / 0.8);
                backdrop-filter: blur(12px);
                border-left: 1px solid #334155;
                box-shadow: -10px 0 30px rgba(0,0,0,0.5);
                display: flex; 
                transform: translateX(100%);
                z-index: 9000; 
                top: 4rem;
                height: calc(100vh - 4rem);
                cursor: default;
            }

            #sidebar-menu.sidebar-open {
                transform: translateX(0%);
            }

            .sidebar-item {
                display: flex;
                align-items: center;
                gap: 12px;
                padding: 8px;
                border-radius: 8px;
                cursor: pointer;
                transition: background-color 0.2s;
                border: 1px solid #334155;
                background-color: #1e293b;
            }

            .sidebar-item:hover {
                background-color: #334155;
            }

            .sidebar-item .preview {
                width: 48px;
                height: 48px;
                flex-shrink: 0;
                border-radius: 6px;
                background-color: #334155;
                overflow: hidden;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .sidebar-item .preview-img {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }
            
            .sidebar-item .preview-icon {
                width: 24px;
                height: 24px;
                color: #94a3b8;
            }
            .sidebar-item .text-preview {
                font-size: 0.9rem;
                color: #e2e8f0;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                font-family: 'Inter', sans-serif;
            }

            .sidebar-button-shifted {
                transform: translateX(-20rem);
            }

            @keyframes fadeInScale {
                from { opacity: 0; transform: scale(0.95); }
                to { opacity: 1; transform: scale(1); }
            }

            .freehand-drawing {
                fill: none;
                stroke-linecap: round;
                stroke-linejoin: round;
                pointer-events: auto;
            }

            .temp-drawing-path {
                fill: none;
                stroke-linecap: round;
                stroke-linejoin: round;
                pointer-events: none;
            }

            .item {
                position: absolute;
                min-width: 150px;
                min-height: 50px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.3);
                cursor: default;
                display: flex;
                flex-direction: column;
                border-radius: 16px;
                border: 1px solid rgba(255,255,255,0.1);
                transition: transform 0.2s ease, box-shadow 0.2s ease;
                user-select: none;
            }

            .item-transition {
                transition: left 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), 
                            top 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            }

            .item:hover {
                transform: scale(1.02);
                box-shadow: 0 10px 30px rgba(0,0,0,0.35);
                z-index: 1001 !important;
            }

            .item.item-node {
                background-color: #65a30d;
                border: 2px solid #a3e635;
                border-radius: 50%;
                min-width: 0;
                min-height: 0;
                box-shadow: 0 4px 12px rgba(0,0,0,0.4);
                padding: 0;
                transition: box-shadow 0.2s ease;
            }

            .item.item-node:hover {
                box-shadow: 0 6px 16px rgba(0,0,0,0.5);
            }

            .item.item-node .delete-btn {
                top: -6px;
                right: -6px;
            }

            .connector-line {
                fill: none;
                cursor: pointer;
                transition: stroke-width 0.1s;
                vector-effect: non-scaling-stroke;
                stroke-linecap: round;
                stroke-linejoin: round;
            }

            .connector-line:hover {
                filter: drop-shadow(0 0 2px rgba(56, 189, 248, 0.7));
            }
            .connector-line.selected-line {
                filter: drop-shadow(0 0 3px #38bdf8) drop-shadow(0 0 3px #38bdf8);
            }

            .item.item-note {
                background-color: rgb(254 249 195);
            }

            .move-handle-note {
                width: 100%;
                height: 24px;
                background: rgba(0,0,0,0.15);
                cursor: grab;
                border-radius: 16px 16px 0 0;
            }
            .move-handle-note:active {
                cursor: grabbing;
                background-color: rgba(0,0,0,0.2);
            }

            .item.item-image {
                border: none;
                background: #ffffff;
                padding-bottom: 0px;
                border-radius: 8px;
            }

            .item.item-image .image-wrapper {
                padding: 2px 2px 2px 2px;
                background-color: #ffffff;
                position: relative;
                border-radius: 8px 8px 0 0;
                overflow: hidden;
                transition: border-radius 0.2s ease;
            }

            .item.item-image .image-wrapper.no-caption {
                border-radius: 8px;
            }

            .item.item-image .image-wrapper img {
                border: 1px solid #f0f0f0;
                border-radius: 8px;
            }

            .item.item-image .caption {
                background-color: #ffffff;
                padding: 8px 8px;
                font-size: 14px;
                text-align: center;
                color: #333;
                min-height: 30px;
                cursor: text;
                border-radius: 8px 8px 8px 8px;
                overflow: hidden;
                font-family: 'Brush Script MT', cursive;
                white-space: pre-wrap;
                word-break: break-word;
            }

            .resize-handle {
                display: none !important;
            }

            .item.item-timeline {
                background-color: rgb(30 41 59 / 0.8);
                backdrop-filter: blur(12px);
                border: 1px solid #334155;
                padding: 0;
                min-width: 200px;
                min-height: 100px;
            }

            .item-timeline svg {
                width: 100%;
                height: 100%;
                display: block;
            }

            .timeline-main-line {
                stroke-linecap: round;
            }

            .timeline-ball {
                fill: #3b82f6;
            }

            .timeline-arrow {
                fill: #3b82f6;
            }

            .timeline-event-line {
                stroke-linecap: round;
            }

            .timeline-event-text {
                font-family: 'Inter', sans-serif;
                font-size: 12px;
                fill: white;
            }

            .timeline-event-move-handle,
            .timeline-event-resize-handle {
                cursor: pointer;
                fill: #f0f0f0;
                stroke: #3b82f6;
                stroke-width: 2px;
                transition: all 0.2s ease;
            }

            .timeline-event-move-handle:hover,
            .timeline-event-resize-handle:hover {
                fill: #3b82f6;
                stroke: #f0f0f0;
            }

            .timeline-event-move-handle {
                cursor: ew-resize;
            }
            .timeline-vertical .timeline-event-move-handle {
                cursor: ns-resize;
            }

            .timeline-event-resize-handle {
                cursor: ns-resize;
            }
            .timeline-vertical .timeline-event-resize-handle {
                cursor: ew-resize;
            }

            .resize-handle-image, .resize-handle-note {
                position: absolute;
                width: 20px;
                height: 20px;
                bottom: -8px;
                right: -8px;
                background: #4f46e5;
                border: 1px solid white;
                border-radius: 50%;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
                cursor: se-resize;
                z-index: 10;
            }

            .delete-btn {
                position: absolute;
                width: 24px;
                height: 24px;
                top: -10px;
                right: -10px;
                background: #ef4444;
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                z-index: 10;
                border: 1px solid white;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            }
            .delete-btn:hover {
                background: #dc2626;
            }

            .edit-btn {
                position: absolute;
                width: 24px;
                height: 24px;
                top: -10px;
                right: 22px;
                background: #3b82f6;
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 14px;
                cursor: pointer;
                z-index: 10;
                border: 1px solid white;
                box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            }
            .edit-btn:hover {
                background: #2563eb;
            }

            #add-image-input {
                display: none;
            }

            .item.selected {
                box-shadow: 0 0 0 3px #4f46e5;
                z-index: 1000 !important;
            }

            .item textarea {
                border: none;
                outline: none;
                resize: none;
                width: 100%;
                padding: 12px;
                padding-top: 8px;
                background: transparent;
                font-family: 'Brush Script MT', cursive;
                flex-grow: 1;
                border-radius: 0 0 16px 16px;
            }

            .item.item-note textarea[readonly] {
                cursor: default;
            }
            .item.item-note:active textarea[readonly] {
                cursor: default;
            }
            .item.item-note textarea:not([readonly]) {
                box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
                cursor: text;
                background: rgba(0,0,0,0.03);
            }

            .glass-panel {
                background: rgb(30 41 59 / 0.8);
                backdrop-filter: blur(12px);
                border: 1px solid #334155;
                border-radius: 16px;
                box-shadow: 0 12px 30px rgba(0,0,0,0.5);
            }

            #line-control-panel {
                position: absolute;
                z-index: 2000;
                display: none;
                flex-direction: column;
                gap: 10px;
                width: 220px;
                padding: 16px;
            }

            #line-control-panel label {
                font-size: 0.85rem;
                color: #94a3b8;
                display: block;
                margin-bottom: 4px;
            }

            #line-control-panel select,
            #line-control-panel input[type="range"],
            #line-control-panel input[type="color"] {
                width: 100%;
                padding: 4px;
                border-radius: 6px;
                border: 1px solid #475569;
                background: #1e293b;
                color: white;
                font-size: 0.9rem;
            }

            #line-control-panel input[type="color"] {
                height: 30px;
                padding: 2px;
            }

            #line-control-panel button {
                background: #4f46e5;
                color: white;
                padding: 6px 10px;
                border-radius: 8px;
                cursor: pointer;
                text-align: center;
                margin-top: 5px;
                transition: background-color 0.2s;
            }
            #line-control-panel button:hover {
                background: #6366f1;
            }
            #line-control-panel #delete-line-btn {
                background: #ef4444;
            }
            #line-control-panel #delete-line-btn:hover {
                background: #f87171;
            }

            .context-menu {
                position: absolute;
                display: none;
                flex-direction: column;
                z-index: 1500;
                width: 190px;
                padding: 8px;
                animation: fadeInScale 0.12s ease-out;
            }
            .context-menu button {
                background: none;
                border: none;
                color: #e2e8f0;
                padding: 10px 14px;
                text-align: left;
                cursor: pointer;
                font-size: 0.9rem;
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin: 0;
                border-radius: 8px;
                width: 100%;
            }
            .context-menu button:hover {
                background: #334155;
                color: white;
            }

            .context-menu label.context-menu-label-btn {
                background: none;
                border: none;
                color: #e2e8f0;
                padding: 10px 14px;
                text-align: left;
                cursor: pointer;
                font-size: 0.9rem;
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin: 0;
                border-radius: 8px;
                width: 100%;
            }
            .context-menu label.context-menu-label-btn:hover {
                background: #334155;
                color: white;
            }

            #connection-submenu, #font-submenu {
                background: #1e293b;
                display: none;
                border-radius: 8px;
                margin-top: 4px;
                padding-top: 4px;
                padding-bottom: 4px;
                display: none;
                flex-direction: column;
                width: 100%;
                animation: fadeInScale 0.12s ease-out;
                transform-origin: left center;
            }

            #connection-submenu button, #font-submenu button {
                background: none;
                border: none;
                color: #e2e8f0;
                padding: 10px 14px;
                text-align: left;
                cursor: pointer;
                font-size: 0.9rem;
                display: flex;
                justify-content: center;
                align-items: center;
                margin: 0;
                border-radius: 8px;
                width: 100%;
            }
            #connection-submenu button:hover, #font-submenu button:hover {
                background: #334155;
                color: white;
            }

            .cursor-mode-btn {
                background-color: #334155;
                color: #e2e8f0;
                padding: 6px 10px;
                border-radius: 8px;
                border: 2px solid #334155;
                transition: all 0.2s ease;
            }
            .cursor-mode-btn:hover {
                background-color: #475569;
                border-color: #475569;
            }
            .cursor-mode-btn.active {
                background-color: #4f46e5;
                border-color: #818cf8;
                color: white;
                box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
            }

            .header-btn {
                background-color: #334155;
                color: #e2e8f0;
                padding: 6px 12px;
                border-radius: 8px;
                font-size: 0.875rem;
                font-weight: 500;
                transition: background-color 0.2s;
            }
            .header-btn:hover {
                background-color: #475569;
            }
            .header-btn.danger {
                background-color: #7f1d1d;
                color: #fca5a5;
            }
            .header-btn.danger:hover {
                background-color: #b91c1c;
                color: white;
            }

            #toggle-api-box-btn {
                transition: transform 0.2s ease;
            }
            #toggle-api-box-btn.collapsed {
                transform: rotate(-90deg);
            }

            #cursor-mode-container {
                position: relative;
                display: flex;
                gap: 8px;
            }

            #toggle-draw-controls {
                background-color: #334155;
                color: white;
                padding: 6px;
                border-radius: 8px;
                border: 2px solid #334155;
                margin-left: -6px;
                z-index: 1;
            }
            #toggle-draw-controls.active {
                background-color: #4f46e5;
                border-color: #818cf8;
            }
            #toggle-draw-controls svg {
                transition: transform 0.2s ease;
            }
            #toggle-draw-controls.active svg {
                transform: rotate(180deg);
            }

            #draw-controls {
                position: absolute;
                top: 110%;
                left: 0;
                z-index: 21;
                display: none;
                flex-direction: column;
                gap: 10px;
                width: 200px;
                padding: 12px;
            }
            #draw-controls-tools {
                display: flex;
                gap: 8px;
            }
            .draw-tool-btn {
                background-color: #475569;
                color: white;
                padding: 6px;
                border-radius: 6px;
                border: 2px solid #475569;
                flex-grow: 1;
            }
            .draw-tool-btn.active {
                background-color: #4f46e5;
                border-color: #818cf8;
            }

            #draw-controls label {
                font-size: 0.8rem;
                color: #cbd5e1;
            }
            #draw-controls input[type="color"] {
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                width: 30px;
                height: 30px;
                border-radius: 50%;
                border: 2px solid white;
                padding: 0;
                cursor: pointer;
                background: transparent;
            }
            #draw-controls input[type="color"]::-webkit-color-swatch {
                border-radius: 50%;
                border: none;
            }
            #draw-controls input[type="color"]::-moz-color-swatch {
                border-radius: 50%;
                border: none;
            }
            #draw-controls input[type="range"] {
                width: 100%;
            }

            #eraser-cursor {
                display: none;
                position: fixed;
                width: 20px;
                height: 20px;
                border: 1px solid rgba(255, 255, 255, 0.7);
                border-radius: 50%;
                pointer-events: none;
                transform: translate(-50%, -50%) translateZ(1px);
                z-index: 9999;
            }

            #board.eraser-active {
                cursor: none;
            }

            #pencil-cursor {
                display: none;
                position: fixed;
                width: 5px;
                height: 5px;
                border: 1px solid rgba(255, 255, 255, 0.7);
                background-color: #FFFFFF;
                border-radius: 50%;
                pointer-events: none;
                transform: translate(-50%, -50%) translateZ(1px);
                z-index: 9999;
            }

            #board.pencil-active {
                cursor: none;
            }

            body.read-only #cursor-mode-container,
            body.read-only #toggle-snap-grid,
            body.read-only #clear-notes-btn,
            body.read-only #clear-images-btn,
            body.read-only #clear-lines-btn,
            body.read-only #clear-drawings-btn,
            body.read-only #clear-all-btn,
            body.read-only #manage-backups-btn,
            body.read-only .edit-btn,
            body.read-only .delete-btn,
            body.read-only .resize-handle-image,
            body.read-only .resize-handle-note,
            body.read-only .move-handle-note,
            body.read-only #item-menu-font,
            body.read-only #item-menu-connect,
            body.read-only #item-menu-delete-node,
            body.read-only #board-menu-add-note,
            body.read-only #board-menu-add-image-label,
            body.read-only #board-menu-add-node,
            body.read-only #board-menu-add-timeline,
            body.read-only #board-menu-add-paste {
                display: none !important;
            }

            /* Bloco removido */

            body.read-only #item-menu-bring-front,
            body.read-only #item-menu-send-back {
                 display: none !important;
            }

            body:not(.is-owner) #delete-room-btn,
            body:not(.is-owner) #board-settings-btn {
                display: none !important;
            }

            #lobby-room-list li {
                @apply p-0 m-0 mb-2;
            }
            #lobby-room-list li .lobby-room-item {
                @apply appearance-none
                       flex justify-between items-center p-4 rounded-lg w-full text-left
                       text-white border border-indigo-500 bg-indigo-600
                       transition-all duration-200 cursor-pointer shadow-md;
            }
            #lobby-room-list li .lobby-room-item:hover {
                @apply bg-indigo-500 border-indigo-400 shadow-lg text-white;
            }
            #lobby-room-list li .lobby-room-item:hover .room-name {
                @apply text-indigo-300;
            }
            #lobby-room-list li .lobby-room-item:hover .join-arrow {
                @apply translate-x-1 opacity-100;
            }
            #lobby-room-list li.no-rooms {
                @apply p-4 text-center text-slate-400;
            }
        </style>
    </head>
    <body
        class="bg-slate-900 text-white h-screen w-screen flex flex-col overflow-hidden"
    >
        <header
            id="main-header"
            class="fixed top-0 left-0 w-full bg-slate-800 bg-opacity-80 backdrop-blur-md shadow-lg z-40 flex items-center justify-between py-2 px-4 h-16"
            style="display: none"
        >

            <div class="h-6 w-px bg-slate-700 hidden sm:block"></div>

            <input type="file" id="add-image-input" accept="image/*" />

            <div class="h-6 w-px bg-slate-700"></div>

            <div id="cursor-mode-container" class="flex items-center">
                <div class="flex gap-2">
                    <button
                        id="mode-move"
                        class="cursor-mode-btn active"
                        title="Move (Default)"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-5 w-5"
                            viewBox="0 0 20 20"
                            fill="currentColor"
                        >
                            <path
                                d="M10 4.5a.75.75 0 01.75.75v10a.75.75 0 01-1.5 0V5.25a.75.75 0 01.75-.75z"
                            />
                            <path
                                d="M5.25 10a.75.75 0 01.75-.75h8.5a.75.75 0 010 1.5h-8.5a.75.75 0 01-.75-.75z"
                            />
                            <path d="M10 2l-3 3.5h6L10 2z" />
                            <path d="M10 18l-3-3.5h6L10 18z" />
                            <path d="M2 10l3.5-3v6L2 10z" />
                            <path d="M18 10l-3.5-3v6L18 10z" />
                        </svg>
                    </button>
                    <button
                        id="mode-select"
                        class="cursor-mode-btn"
                        title="Select"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-5 w-5"
                            viewBox="0 0 20 20"
                            fill="none"
                            stroke="currentColor"
                            stroke-width="1.5"
                            stroke-dasharray="2 2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        >
                            <rect x="3" y="3" width="14" height="14" rx="1" />
                        </svg>
                    </button>
                    <button
                        id="mode-draw"
                        class="cursor-mode-btn"
                        title="Draw (Pencil)"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-5 w-5"
                            viewBox="0 0 20 20"
                            fill="currentColor"
                        >
                            <path
                                d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"
                            />
                        </svg>
                    </button>
                </div>
                <button id="toggle-draw-controls">
                    <svg
                        class="w-4 h-4"
                        xmlns="http://www.w3.org/2000/svg"
                        viewBox="0 0 20 20"
                        fill="currentColor"
                    >
                        <path
                            fill-rule="evenodd"
                            d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"
                            clip-rule="evenodd"
                        />
                    </svg>
                </button>

                <div
                    id="draw-controls"
                    class="glass-panel"
                    style="display: none"
                >
                    <div id="draw-controls-tools">
                        <button
                            id="draw-tool-pencil"
                            class="draw-tool-btn active"
                            title="Pencil"
                        >
                            <svg
                                xmlns="http://www.w3.org/2000/svg"
                                class="h-5 w-5 mx-auto"
                                viewBox="0 0 20 20"
                                fill="currentColor"
                            >
                                <path
                                    d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"
                                />
                            </svg>
                        </button>
                        <button
                            id="draw-tool-eraser"
                            class="draw-tool-btn"
                            title="Eraser"
                        >
                            <svg
                                xmlns="http://www.w3.org/2000/svg"
                                class="h-5 w-5 mx-auto"
                                viewBox="0 0 20 20"
                                fill="currentColor"
                            >
                                <path
                                    d="M16.142 3.858a2.25 2.25 0 00-3.182 0L4.3 12.518a2.25 2.25 0 000 3.182l.06.06a2.25 2.25 0 003.182 0L16.2 6.9a2.25 2.25 0 000-3.182l-.06-.06zM5.57 14.43a.75.75 0 01-1.06 0l-.06-.06a.75.75 0 010-1.06l8.66-8.66a.75.75 0 011.06 0l.06.06a.75.75 0 010 1.06l-8.66 8.66z"
                                />
                            </svg>
                        </button>
                    </div>
                    <div id="draw-color-container">
                        <label for="draw-color">Color:</label>
                        <input type="color" id="draw-color" value="#FFFFFF" />
                    </div>
                    <div id="draw-thickness-container">
                        <label for="draw-thickness">Thickness:</label>
                        <input
                            type="range"
                            id="draw-thickness"
                            min="1"
                            max="10"
                            value="3"
                            step="0.5"
                        />
                    </div>
                    <div id="eraser-size-container" style="display: none">
                        <label for="eraser-size">Eraser Size:</label>
                        <input
                            type="range"
                            id="eraser-size"
                            min="5"
                            max="200"
                            value="103"
                            step="1"
                        />
                    </div>
                </div>
            </div>

            <button
                id="toggle-snap-grid"
                class="cursor-mode-btn ml-2"
                title="Snap to Grid"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                    stroke-width="2"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        d="M13 10V3L4 14h7v7l9-11h-7z"
                        clip-rule="evenodd"
                    ></path>
                </svg>
            </button>

            <button id="clear-notes-btn" class="header-btn ml-2">
                Clear Notes
            </button>
            <button id="clear-images-btn" class="header-btn">
                Clear Images
            </button>
            <button id="clear-lines-btn" class="header-btn">Clear Lines</button>
            <button id="clear-drawings-btn" class="header-btn">
                Clear Drawings
            </button>
            <button id="clear-all-btn" class="header-btn danger">
                Clear All
            </button>
            <button
                id="delete-room-btn"
                class="header-btn bg-red-800 hover:bg-red-700 text-white font-bold ml-1"
                title="Delete This Room Permanently"
            >
                Delete Room
            </button>
            <button
                id="manage-backups-btn"
                class="header-btn bg-teal-600 hover:bg-teal-500 text-white font-bold ml-1"
                title="Manage Room Backups"
            >
                Backups
            </button>
            <button
                id="board-settings-btn"
                class="header-btn bg-gray-600 hover:bg-gray-500 text-white font-bold ml-1"
                title="Board Settings"
            >
                Settings
            </button>

            <button
                id="invite-btn"
                class="header-btn ml-auto bg-indigo-600 hover:bg-indigo-500"
            >
                Invite
            </button>

            <button
                id="show-users-btn"
                class="header-btn ml-3"
                title="Show Users"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    class="h-5 w-5"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                >
                    <path
                        d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM11 6a3 3 0 11-6 0 3 3 0 016 0zM12 8a4 4 0 100-8 4 4 0 000 8zM14 10a1 1 0 011 1v1a1 1 0 01-1 1h-1v1a1 1 0 01-1 1H6a1 1 0 01-1-1v-1H4a1 1 0 01-1-1v-1a1 1 0 011-1h10zM5 11v1h10v-1H5z"
                    />
                    <path
                        d="M12.9 14.25c.218.087.48.13.7.13a3.5 3.5 0 003.5-3.5c0-.987-.41-1.884-1.077-2.523A3.986 3.986 0 0013 7a3.986 3.986 0 00-2.823 1.176A3.487 3.487 0 009 10.5a3.5 3.5 0 00.9 2.38c.218.087.48.13.7.13a2.5 2.5 0 002.3-1.23v2.47z"
                    />
                </svg>
            </button>
            <button
                id="leave-room-btn"
                class="header-btn bg-yellow-700 hover:bg-yellow-600 text-white font-bold ml-1"
                title="Leave this Room"
            >
                Leave Room
            </button>
            <div class="h-6 w-px bg-slate-700 ml-3"></div>
            <span
                id="board-name-display"
                class="text-sm text-indigo-300 font-medium ml-3"
                >Loading board...</span
            >

            <input
                type="text"
                id="board-name-input"
                class="ml-3 bg-slate-700 text-white text-sm rounded-md p-1 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                placeholder="Enter board name..."
            />
            <button id="switch-board-btn" class="header-btn ml-1">
                Switch
            </button>
        </header>

        <main id="board" class="flex-grow">
            <div id="selection-box"></div>

            <div id="canvas-container">
                <svg
                    id="svg-layer-connections"
                    class="absolute top-0 left-0 z-0"
                >
                    <defs>
                        <pattern
                            id="threadPattern"
                            patternUnits="userSpaceOnUse"
                            width="16"
                            height="16"
                        >
                            <image
                                href="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCABkAGQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD7v0jxfpfhvUJRdalLdySn/RYyN4EY+6oRF3Z69QR171H4w17TtStZ9U0q9ls9bsfllXTAks/B+ZHjwecZwpG78eK+R/Af7D76t9jfVbtLW0glYTeQQZN6vguu5SFQ4xjnBBBA6j7B+Gvw+svB+ixWLfZZYrckR3a22xHO49Qc4OAMnPJJINAFfw7qmn/E7w7BfQ+HLjW7e6VZFmvYEt8sOA7LJtZG7g7QemM8VseFPDeteH9GEGtXNvNHvaKKNU+ZICx2xOxYiQhcAngn9a6WSIxwzQWeLWRj5hKgCJmJyR68nrjnmsi8vNQZtnyTkcvaNgYGeejH8xnvxQBc0fwfFpckvl6hJdJKQ0NtcfMkKjOQgyeDxyc/yxPpej6Fa3lx5enW1ldIf3pSMKxJJOcj1OT6HmoP7Pu0Ed5bTC0ilXMtvIGMmeoCnPyjrxjv0GMVFL4otJZBZOAk7Hy9u3ILegxnn/dzjvigDc1CKbKS20tuYkH/AB7zwg7z7NnrTLW7sdcsXa909YVBMbx3UI5I7AEcisi1jk0m5zdzrO8gxBArL+7GB8oyODnPJ+hxVyS9stdmNm3lzXEJB2MvzRE9CVPOD2PQ9uKAJpNLtb1V+0WcV5Zx5ZGx0O4MMKB6qpyM8iqt/wCCNI8SXGl6lHvhls2aSF4XG1gyFWDDkMCD16ggEGnPcaj4f82XUVW808AYktQWaIY5Lp3HuufpS2+s2usWu7RLyGUldyvbsGi/HHA57ZzQBhr8P7jSr5ZW1+X7NgiKynj3W+ex6jn6YB9K47xFp/xF+1LZW6iG1nD+dqtpLE/2YYO0pE68nO35cnA3fNnFeq2t5HKiW1+8bX3liRkYq69cZXvjI4OB278Un9oXInKx2kkiIMHbwv1z6d+Bz+lAHh9jqOq6RALTUNf+yzw4QLFbPBuAAG5hiQFickkNj8uSvXpvC9pqkhuXvMs/P+sdf/QWA/HvRQBwlj4b8Zf2HqczWz2N1NdyvFCBHIUQuRvADqclcngjJbBG3IrV1HxfY6Db6bpV5uh+0FY1t5YyuflJOd2No4OT6DjOa9CgWSR0ks7sNB1aKT5gR7HqP5VXuJY9QY2t5awRhSGZLgb1PptJ6/UdPrQBxV3awJbhtG1VYScyGGR8qVI5EZHCg8Dd82BnA5NJYJda7Yx/2rb27eWfnsgoIYAnaUP8SAcjoScE4qHxx8KdO8ZWN1Y6fFd6HcTfvF1DRbp7ORJAwKuWT5XAIHDqc9DnOK8u8aaB8QvBuj2Bv/G1lq01mhja5uNP2RuxGBK4XhXAB5PyDJOBzQB61rE2paxMkWnXU9odwMqHBLRjOVV2IKcYyQG6YDDOau2saWcYudtvf3Ee5ftCJjjJyqsMtGevUk5zmvmjxB8WPF/hPwpB/Yvgm/1W7mj82TUIb1ovMGT+8ZSu5gSMgfKSBgEcVq/AjxV4y+J3w/fXtUttMsbY3bpZjSdyKwj+RvNDl+jhlxwQUOc0Ae72tjfwk3ljHJNaSqWk+0jM8Z4wOo3J1PGCOODzTrPXtHWR7m2uorO8DFJVumADN3w+OuTjkH6dK4q71n4pQW8J0qHQ7lyCfs9xHKqmPcQGaQN8vy44CMc57c1k6bJ4p8aGTVJ9NsdK1WwZ4WbEgaNl+8qMNpKMwB5yMAdcCgD0+HxRrUd7cnUNOk03SlZVhv8AekvmE9cqp3KBxgkd+QKr6xbx2MBl8P8Al20zyNL5MUe+K4kY7nYqpwWbn5s8EjOelfPHj/42fFzSdA0zS9O8NabfeI9QhQS2ro3+ioA/mEoH6YCFRnPz4IbHNf4YeEfjD4u8Qx67B4it/C3k7obvShaebalxjP7ov0/4EjKMAdxQB9CWesXHiHSzY+IrWXSNTBZPs6ThJxxnfDIp+YEf3TuzngYo/wCFjWmj6pBp63FzqSzYSO3tyJJA3QhgeT0PQn8+rLXwrZ6+ktn4vvI9cymGt2YJb4zgsIRgj6nf04YHiug0fQ18A6KLLTNOhfR4lIgt4EKyoM/dwOWIB+8PTn1oAnax1PW8XkFkLNJAD5c8jRPnHVlwcH8qK1k1lY8xtbyTMnBLsoxwDgZxkDPX6jtRQBk6nrd1oQiYwXGpQyuqk2iK724bgFxkHbkckZI54wOLEVsniSxguZ5445EcyQMrFlx254z9K811z4mWfwkS3g1TVrE2k8ohjnvLhYrh2IyAVP8ArDtySBzjBwM1mXtzpeo3v/CQaZ4nmkjlw02lWFz5lse5ZBglXx2TqSc54wAeuL4ka4u20+cSW9+jZilRHaORCDhi4XaDwcg9OD0YVlXljCt59q1BVkhnXLJHiaJZOhGNvOeuFOc54NZOnabc+L/CdvHHp32JplMtvDrMircIxHDboy+G5ySDnDY45re8Jabqmk+FbPT/ABf9hvNQmXy7lrRXNu5PHlpvJZ+O5xnBOAOAAc14vh03VNLZYpVhhm2C8tYZyhlhZcK8T8EKTj5lxgBsEEGoPg3obeH/AA1c6Vb2UWn6eL2UQW0KAJbwkAlFYAbiXLndgckjHy16NpvhfTdIUDT7EW6SMX2s5IyeT8pPH9PSqx8QapfXs1rbWDWMFu2xpbpSpcYBzGP4hyOcgdec8UAZun6dLpV9JBbWzzWwVfLf74BxtAKjkBQM/XPc1paxp4i09ri0sWe7jYSzWcWFM5xjGTjPHf0GPSr8d5dxWheFvt0wbaVJx35HsR6H8z1qSRo9SsUkvoZNi/MWXKGI+pHDD6/yoA8q8YXV5omrWGqQaSZ76dJoWtCBGvnlVMTFyM7cRmPjPzMnGc1ePiXT9N8NXF/aTwW1y4aZ7e8YoWK/ws6hgPmB6AjsM16BrU1naaf9nvwtxZAKWM/zDjGGY/xc4545+tTx2NrrFnH+7V4HxJ5VxEMHn+6Rx9etAHDw+L7eWyV9WiinATcZgCApA52sPu+mDtIxyTmtDRPECWMZmu5pXlkBMfnMgKR5JC8fLnaMnnqPoKoav8F/CmuTX32+1dftwU3Fl53mQyhWY/cfK4JY5AAyMA8DFch4k+A2qppd1b+H/Fd94f0/KiKxls4r2JfmU7cMAwTgfKHAAA4AGKAOj1f4yeGbTUJbe41bT3mi+VvNTcR3xkZ6Z/PNFc1CvxB0i3gs5fCWjeITCgQahDfPGJAO5V0JB9tzf7xooA8v+Ff7OXhDxRDaa94pvtX8W69PK8kLXt/OjWMYkYIhG4MGVg2eQMhsDivbtD8N6F8PrpbaLSrPTLO3CiKVI8M5fJIxyeoAwCdzHPrUknw5ufDurNf2KteaeySPd2+7eJXLM2UQDKvuZiScj5j7Y1V1XUdUc21xod8tn8xN1dRxbNoAzkBi2ecDgHg5xjkA6BtQtzCtvH5NmHO7ymGFOc9WHCv1OB/9eluPEL2c0FlKnmzTqxDScwqgHI/2jjnnrn8K4TxN4psdIs1svDkUepXikRHT7SZUZmwOAMY3d8EqPUjIzcm8f6VpGlwwWtrcyXzERRRyxFJmkOfvHHHQnIG3vzmgDq4pbjTVuLpJ5rsMc/YdygxHuE4GSeuCT/snBqnpGuzeNrN5Via0hUnYsjGOWNgSvzYyQ3Bypxjoe9YXh5Lk3EM2p3EMhiTf/ooYRncd3CszEgf72OchRji7/wAJ1YanceZp1ztLZRJGw32k4PygbvlAypJwByBnnFAGk15J4StZmeRtQYANuOEY5ON0hz0A9BgBTgcYq5a3T64iSxXREy9HtcbNpGeQ33xj8eeKy5tU1OO7soJra0WY/evMgoOBkRg5bPtgYABJ7VFr2kvhLrTbt4rvevm3HXK7ufqACcD6DigDUj1i50+JrWRbXT7ZDsSVpc7h1yq+nPfGPSkt7VkaF9PvpjAXZ5RcfMDnsjHoQQeASBk+wrPl13Q5o3gmRZ7xdokurxVjAYA4cbsepwyg8ZwTWX4i119CkjAurYRXKbnkbCoygqBIV3KUOW4YHGccrlaAO0fUrS82v5HlyR52zTYDI3Q8djx7VSvvEUmn3iW+oROsEigxXka7VkznKnJ+UgD15zxXGXujWaqdca7a2mhX5pLu5zHsV8jI+4jKCcELkgAFyM1l6D8ctP8AHd7JoOmyfbNWAKskcZZRhgFfHdeQQ2QpGDuGRQB3i2k18zzWl/cS27N8g8mNwn+yDxxnPr160Vh2+j+P7OHyZ44tWZWYLdfaI4iybjtBUAANtxnHGc49KKAO3j1KOAvFfvFD0I8rKRgdB85xk9OmPSn3MM15JG1nLGoY5dlUglMdv7315+hrnG8P6Xrmn2aajcp9ptnzBdu4NxHJgglSejYJHToeRWdqHiC/0W++zalqNrFpiKuzUpcx5Y5AGB/FxnqPQc8gA2dc+H3hjWLyO7v7SG71SPa6zKu2bI4DEqRzgkZPqfU15X8Q/hfqerabeT6Z4j1LTZ1PmWu64mnO9SRgQGQB8HHDcHjqenokkS6tGl5p8t7cM4BkuVzFHuC/6xY8jcG7gdc8c1k+FfGl34shvA1j5UtlvS31GRQYXOMZTJ3FffHYg4xyAfN0138UPC/h6PTrnXZY7oq3l2uu2dp9qfHO6MRblfJOcM24HJ2tjBp/A3xh4x1zQtT1bxDi1ms7824TTbY/aLpidoJ3swLjadoQKp3DsSa+iPEmj6Vr17Zt4lK3Mv3YMM0TW8voFBwSSDh8Hj6c814P06DS7a4nu3ghvbfWZS0EcZQNGVESDk/fMYVieg3k8KaAKCx+OviFrBn0TxZb2OjWszI8cdjHL57BmDLKJAduARlRzvB54zXTeDda8X31rNpV7LHZ6pp7FLsSQqY5ovmCzRbTxuAzsJJB4zjBPcw2rC6ZdNt1Z2kSS5kjiKq6kbQ/T74A6Hn5fTGJNU0+TUI4oolNvqkDru243yoWwQSRypx1xx7EUAfJHx61P4o6X4g8PaHpOqyW11r2qSyQ6gEhjVLWGJfMQkR9S8iFSRnCnt19C8PfCj4keItFmg+IHjqa+0+UxfZVtrO2tiOitGzIgkUv0yjrwccd+3+OXhXWPFen+HZ9Pt5LfUtB1iG8AeNjA8Cllk+fHGU3DJOMOCfbOtfH2qa7B9q1rR30LTrUD/RdWeEx3H3WEivG77ShxghuNwbng0AaHhz9lfwRpM9jqYsvtlzbReUsd7M86FAOAokLAAAnAIxznjrXpnhuTSliFpp1nDZwwcO0AWJUzxjAGM8fp+FefWOuyprSKdQmYzZzY3DrLHEqD7hIXcqHcnJViNqhvvGtjUvEC6tfNZ6dqkemXkCLK8e5GG08Kp67gdoHGGGDhgOCAegySS2+1CqXfGfNZFyf1FFcNH4ohj3xsJbl42KNJ9ndzkdiVGCR049OxyKKAOEuPi18O/FlrHqll4o0O3jaP95erexST3MQyAuM7m+Y8Y79M5Ocjw/4t1/4j3eq6JNBqWiWVqfIgudTshBLc56GPc5ckEfe8sdieeateC/g/wDDrwDe2t3oUOn6TromkjWDzFP21Hcny5Fzg9FIY5Ke4LBvZ9NWx1Rj9o09LRLdjHE0wAlBBxlR1AOAR6jHtkA890n4W+NLHVLUN8Rby60SDCzadJbRyXKHbkP5+Sep3YkVweBwMg+hWHgTSbGR7xZJI72bBeaVk3SNxyVUDGT1C4yST15qxNrQ0u4jikKGPAEN67bN2f4Txz34HX8zVfUZrJLea+t1jkvGBZnwSxwOVTIPHHKjjr3zQAyTTdIXXpLia1X7cqfPPKuPl6DJ4JA+bH1PvV+b7NnbaJFJO2Ha3iBhnI6F+Dn/AL6x9apbo9a0/wAvVmWEx5/e5w8J46E/TnPcdxjFe61GytZLW0jjIRmUwXTLtUvycswxzxkkZBzyOcEA6i2vgLNknYZwfmk/d4X37n6459qoyfarFRJa7WgkYkM5KeWD3YEnj3Azz0qGW3tNRkgZryZr1RgSxsuxm4IO0jaxH97bnFK948OoR2U9rLHezqSlzbktBIV7sAfkPTOeOQMtwKANSOT+0cfZ2WNl+9cFBtb2C96zrq3t/tUdrdWVu4x5ouGgEkXDA4OeVbIUjB6r7Un/AAj5xmXVHhjHztawkLCTxwWxuxnpgjr0PADF1y2mlbT0idHX5BA6MNwAxuHcr/tDjPWgBdQ8F+H9QuXuZdJs3eRdryCJUdwMnBIG5hljweOT61wXi74B6D4oglGizXXhi9j3YvNPmaJo3KgbsA7Wxgde3Q12baPc6ZJNey30l3CwBWyBG9cdQjADd0+7jOQeRmhZD4kjextH82zU7HkYlZbdx65HUccEfUYPAB83XH7N+uac/kN8R/HF4VyfN0++iSI5JPA8rg/ifrRX0xaeGGsbdIry/NzMo5kjCxg/8BOcUUAedan4U0vwrfXU1haokl1EryswHJyoyMYxkMc46nk8kk80k2pQ+JdQK61feXo0b3MMZ8siUiIOEkbZuKZY/KCB0PUZoooA9fdU1rRYRcxqyXEDSMmOATwQPY+lcd4DZre+1ddzSyQ3EqxzSks6qpKhQTxj5emO9FFAE/iqd7q40Ik+W13c+WzIACqqQcD2OMYOR6Y61vafdNatLCAsqmV4GMo3FlHqT9Tx05PHJoooA5nWNal8GeMNK0rSoo4bfVFkaV33O8e0DAjJb5V/2QNo7AV18N7JN/aMUuJI4XVVUj3HPHQ89sUUUAee3mtTWvxU0nRions7yC6lYTSSN5ZjKKNi7toyHOSVJ6YIrfi8Q3txDeQs6hre5NrHMqAOFC5B9M59se1FFAHI+DfF2p3V5NHNcGUrdtB5khLOVBUDJJ5PJqT4jfETWPB+ueEbexkjaLWtXj0+5WZSwCNn51AIAb5fpycgnBBRQB6/YqZrVHLYLeqhv1YE0UUUAf/Z"
                                x="0"
                                y="0"
                                width="16"
                                height="16"
                            />
                        </pattern>
                    </defs>
                </svg>

                <svg id="svg-layer-drawings">
                    <defs>
                        <pattern
                            id="dot-grid"
                            patternUnits="userSpaceOnUse"
                            width="20"
                            height="20"
                        >
                            <rect width="20" height="20" fill="#1e293b" />
                            <circle
                                cx="1"
                                cy="1"
                                r="1"
                                fill="rgba(255,255,255,0.1)"
                            />
                        </pattern>
                    </defs>
                    <rect
                        id="svg-bg-rect"
                        fill="url(#dot-grid)"
                        x="-50000"
                        y="-50000"
                        width="100000"
                        height="100000"
                    />
                    <g id="drawing-group"></g>
                    <g id="temp-drawing-group"></g>
                </svg>
            </div>

            <div
                id="line-control-panel"
                class="glass-panel"
                style="display: none"
            >
                <h3
                    id="line-panel-handle"
                    class="text-white text-md font-bold mb-2 cursor-grab active:cursor-grabbing"
                >
                    Configure Line
                </h3>

                <div>
                    <label for="line-type">Type:</label>
                    <select id="line-type">
                        <option value="solid">Thread</option>
                        <option value="dotted">Dotted</option>
                        <option value="arrow">Arrow</option>
                    </select>
                </div>

                <div id="line-color-control" style="display: none">
                    <label for="line-color">Color:</label>
                    <input type="color" id="line-color" value="#d90429" />
                </div>

                <div>
                    <label for="line-thickness">Thickness:</label>
                    <input
                        type="range"
                        id="line-thickness"
                        min="1"
                        max="10"
                        value="5"
                        step="0.5"
                    />
                </div>

                <button id="change-direction-btn" style="display: none">
                    Change Direction
                </button>
                <button id="connect-from-line-btn">
                    Connect From This Line
                </button>
                <button id="delete-line-btn">Delete Line</button>
                <button id="close-line-panel-btn">Close</button>
            </div>

            <div id="item-menu" class="context-menu glass-panel">
                <button id="item-menu-font">
                    <span>Change Font</span>
                    <span>&rsaquo;</span>
                </button>
                <div id="font-submenu">
                    <button
                        data-font="'Brush Script MT', cursive"
                        style="font-family: 'Brush Script MT', cursive"
                    >
                        Cursive
                    </button>
                </div>
                <div id="font-size-container" class="p-2" style="display: none">
                    <label
                        for="item-menu-font-size"
                        class="text-xs text-slate-400 block mb-1"
                        >Font Size</label
                    >
                    <input
                        type="range"
                        id="item-menu-font-size"
                        min="10"
                        max="24"
                        value="14"
                        step="1"
                        class="w-full"
                    />
                </div>
                <button id="item-menu-connect">
                    <span>Create Connection</span>
                    <span>&rsaquo;</span>
                </button>
                <div id="connection-submenu">
                    <button id="submenu-solid" data-type="solid">
                        Thread Line
                    </button>
                    <button id="submenu-dotted" data-type="dotted">
                        Dotted Line
                    </button>
                    <button id="submenu-arrow" data-type="arrow">Arrow</button>
                </div>
                <button id="item-menu-bring-front">Bring to Front</button>
                <button id="item-menu-send-back">Send to Back</button>
                <button id="item-menu-delete-node" style="color: #f87171">
                    Delete Node
                </button>
            </div>

            <div id="board-menu" class="context-menu glass-panel">
                <button id="board-menu-add-note">+ Add Note</button>
                <label
                    for="add-image-input"
                    id="board-menu-add-image-label"
                    class="context-menu-label-btn"
                >
                    + Add Image
                </label>
                <button id="board-menu-add-node">+ Add Node</button>
                <button id="board-menu-add-timeline">+ Add Timeline</button>
                <button id="board-menu-paste">Paste (Ctrl+V)</button>
            </div>

            <aside
                id="sidebar-menu"
                class="fixed right-0 top-0 h-full w-80 transition-transform duration-300 ease-in-out flex flex-col"
            >
                <div
                    class="flex justify-between items-center p-4 border-b border-slate-700 flex-shrink-0"
                >
                    <h3 class="text-lg font-bold text-white">Board Items</h3>
                    <button
                        id="close-sidebar-button"
                        class="p-2 rounded-full text-slate-400 hover:bg-slate-700 hover:text-white"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke-width="2"
                            stroke="currentColor"
                            class="w-6 h-6"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                d="M6 18L18 6M6 6l12 12"
                            />
                        </svg>
                    </button>
                </div>
                <div class="p-4 border-b border-slate-700 flex-shrink-0">
                    <input type="text" id="sidebar-search-input" placeholder="Search items..." class="w-full bg-slate-700 text-white placeholder-slate-400 p-2 rounded-lg border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                </div>
                <div
                    id="sidebar-item-list"
                    class="flex-grow overflow-y-auto p-4 space-y-3"
                >
                </div>
            </aside>
        </main>

        <div id="users-modal-overlay">
            <div id="users-modal" class="glass-panel">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-white">
                        Connected Users
                    </h2>
                    <button
                        id="close-users-modal-btn"
                        class="text-gray-400 hover:text-white"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            class="h-6 w-6"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"
                            />
                        </svg>
                    </button>
                </div>
                <ul
                    id="users-list"
                    class="max-h-60 overflow-y-auto text-white"
                ></ul>
            </div>
        </div>

        <footer
            class="bg-slate-900/80 backdrop-blur-sm border-t border-slate-700 text-slate-400 text-xs p-2 text-center flex-shrink-0 z-[10000] select-none"
            style="display: none"
        >
            Use <span class="text-indigo-400 font-bold">Move Tool</span> to pan.
            Use <span class="font-bold">Right-Click</span> for options. Use
            <span class="font-bold">Scroll</span> to zoom.
            <span id="user-role-display" class="ml-4 font-bold"></span>
            <button
                id="change-nickname-btn"
                class="ml-2 px-2 py-0.5 bg-slate-700 hover:bg-slate-600 rounded text-xs text-indigo-300"
                title="Change Nickname"
            >
                Change Nickname
            </button>
            <button
                id="password-settings-btn"
                class="ml-1 px-2 py-0.5 bg-slate-700 hover:bg-slate-600 rounded text-xs text-indigo-300"
                title="Password Settings"
            >
                Password
            </button>
        </footer>

        <button
            id="toggle-sidebar-button"
            class="header-btn fixed top-[4.75rem] right-6 z-30 transition-all duration-300 ease-in-out"
            title="Toggle Item List"
            style="display: none;"
        >
            <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke-width="2"
                stroke="currentColor"
                class="w-5 h-5"
            >
                <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
                />
            </svg>
        </button>

        <button
            id="center-board-btn"
            class="header-btn fixed bottom-12 left-6 z-30 transition-all duration-300 ease-in-out"
            title="Center Board"
            style="display: none;"
        >
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M10 9a1 1 0 011 1v.01a1 1 0 11-2 0V10a1 1 0 011-1z" clip-rule="evenodd" />
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-2a6 6 0 100-12 6 6 0 000 12zM10 4a1 1 0 011 1v1a1 1 0 11-2 0V5a1 1 0 011-1zM4 10a1 1 0 011-1h1a1 1 0 110 2H5a1 1 0 01-1-1zM14 10a1 1 0 011-1h1a1 1 0 110 2h-1a1 1 0 01-1-1zM10 14a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1z" clip-rule="evenodd" />
            </svg>
        </button>

        <div id="eraser-cursor"></div>
        <div id="pencil-cursor"></div>

        <div
            id="delete-room-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center"
            style="display: none"
        >
            <div
                id="delete-room-modal"
                class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full"
            >
                <h2 class="text-xl font-bold text-red-400 mb-4">
                    Are you sure?
                </h2>
                <p class="text-slate-300 mb-6">
                    You are about to permanently delete this room:
                    <strong id="delete-room-name" class="text-white"></strong>.
                    All notes, images, and connections will be lost forever.
                    This action cannot be undone.
                </p>
                <div class="flex justify-end gap-4">
                    <button id="cancel-delete-room-btn" class="header-btn">
                        Cancel
                    </button>
                    <button
                        id="confirm-delete-room-btn"
                        class="header-btn danger"
                    >
                        Yes, Delete Room
                    </button>
                </div>
            </div>
        </div>

        <div
            id="error-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[32000] flex items-center justify-center"
            style="display: none"
        >
            <div
                id="error-modal"
                class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full"
            >
                <h2
                    id="error-modal-title"
                    class="text-xl font-bold text-red-400 mb-4"
                >
                    Error
                </h2>
                <p id="error-modal-text" class="text-slate-300 mb-6">
                    An unknown error occurred.
                </p>
                <div class="flex justify-end gap-4">
                    <button
                        id="error-modal-ok-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        OK
                    </button>
                </div>
            </div>
        </div>

        <div
            id="backups-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center"
            style="display: none"
        >
            <div
                id="backups-modal"
                class="glass-panel p-6 rounded-lg shadow-xl max-w-lg w-full"
            >
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-white">Manage Backups</h2>
                    <button
                        id="close-backups-modal-btn"
                        class="text-gray-400 hover:text-white"
                    >
                        &times;
                    </button>
                </div>
                <button
                    id="create-new-backup-btn"
                    class="header-btn bg-teal-600 hover:bg-teal-500 text-white w-full mb-4"
                >
                    Create New Backup
                </button>
                <ul
                    id="backups-list"
                    class="max-h-60 overflow-y-auto text-white bg-slate-800/50 rounded-lg p-2"
                ></ul>
            </div>
        </div>

        <div
            id="restore-confirm-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[21000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-yellow-400 mb-4">
                    Restore Backup?
                </h2>
                <p class="text-slate-300 mb-6">
                    Are you sure you want to restore the backup from
                    <strong id="restore-backup-name" class="text-white"></strong
                    >? This will overwrite all current items on the board.
                </p>
                <div class="flex justify-end gap-4">
                    <button id="cancel-restore-btn" class="header-btn">
                        Cancel
                    </button>
                    <button
                        id="confirm-restore-btn"
                        class="header-btn bg-yellow-600 hover:bg-yellow-500"
                    >
                        Yes, Restore
                    </button>
                </div>
            </div>
        </div>

        <div
            id="nickname-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[30000] flex items-center justify-center"
            style="display: none"
        >
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2
                    id="nickname-modal-title"
                    class="text-xl font-bold text-white mb-4"
                >
                    Welcome!
                </h2>
                <p class="text-slate-300 mb-6">
                    Sign in with Google or continue as a guest.
                </p>

                <button
                    id="google-signin-btn"
                    class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-3 transition-colors duration-200"
                >
                    <svg
                        class="w-5 h-5"
                        viewBox="0 0 48 48"
                        xmlns="http://www.w3.org/2000/svg"
                    >
                        <path
                            fill="#EA4335"
                            d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"
                        ></path>
                        <path
                            fill="#4285F4"
                            d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.84 7.18l7.98 6.19C45.02 40.3 48 33.37 48 24.55z"
                        ></path>
                        <path
                            fill="#34A853"
                            d="M10.53 29.59c-.49-1.47-.78-3.04-.78-4.64s.29-3.17.78-4.64l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"
                        ></path>
                        <path
                            fill="#FBBC05"
                            d="M24 48c6.47 0 11.9-2.13 15.89-5.61l-7.98-6.19c-2.11 1.43-4.82 2.3-7.91 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"
                        ></path>
                        <path fill="none" d="M0 0h48v48H0z"></path>
                    </svg>
                    Sign in with Google
                </button>

                <div
                    class="my-4 flex items-center before:flex-1 before:border-t before:border-slate-600 before:mt-0.5 after:flex-1 after:border-t after:border-slate-600 after:mt-0.5"
                >
                    <p class="text-center font-semibold mx-4 text-slate-400">
                        OR
                    </p>
                </div>

                <p class="text-slate-300 mb-4">
                    Continue as a guest with a nickname:
                </p>
                <input
                    type="text"
                    id="nickname-input"
                    class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    placeholder="Type your nickname..."
                />
                <div class="flex justify-end gap-4 mt-6">
                    <button id="cancel-nickname-btn" class="header-btn">
                        Cancel
                    </button>
                    <button
                        id="save-nickname-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        Save
                    </button>
                </div>
            </div>
        </div>

        <div
            id="board-password-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[29000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-white mb-4">
                    Password Required
                </h2>
                <p class="text-slate-300 mb-6">
                    The board
                    <strong
                        id="board-password-name"
                        class="text-white"
                    ></strong>
                    is password protected.
                </p>
                <input
                    type="password"
                    id="board-password-input"
                    class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    placeholder="Enter board password..."
                />
                <p
                    id="board-password-error"
                    class="text-red-500 text-sm mt-2"
                    style="display: none"
                >
                    Wrong password
                </p>
                <div class="flex justify-end gap-4 mt-6">
                    <button id="cancel-board-password-btn" class="header-btn">
                        Cancel
                    </button>
                    <button
                        id="submit-board-password-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        Enter
                    </button>
                </div>
            </div>
        </div>

        <div
            id="new-board-password-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[29000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-white mb-4">New Board</h2>
                <p class="text-slate-300 mb-6">
                    You are creating the board
                    <strong id="new-board-name" class="text-white"></strong>.
                    Set a password (optional).
                </p>
                <input
                    type="password"
                    id="new-board-password-input"
                    class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    placeholder="Enter new password (optional)..."
                />
                <div class="flex items-center mt-4">
                    <input type="checkbox" id="new-board-hidden-checkbox" class="h-4 w-4 bg-slate-700 border-slate-600 rounded text-indigo-500 focus:ring-indigo-500">
                    <label for="new-board-hidden-checkbox" class="ml-2 text-sm text-slate-300">Hidden (don't show in lobby list)</label>
                </div>

                <div class="flex justify-end gap-4 mt-6">
                    <button id="cancel-new-board-btn" class="header-btn">
                        Cancel
                    </button>
                    <button
                        id="submit-new-board-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        Create Board
                    </button>
                </div>
            </div>
        </div>

        <div
            id="delete-backup-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[21000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-red-400 mb-4">
                    Delete Backup?
                </h2>
                <p class="text-slate-300 mb-6">
                    Are you sure you want to permanently delete this backup?
                    This action cannot be undone.
                </p>
                <div class="flex justify-end gap-4">
                    <button id="cancel-delete-backup-btn" class="header-btn">
                        Cancel
                    </button>
                    <button
                        id="confirm-delete-backup-btn"
                        class="header-btn danger"
                    >
                        Yes, Delete
                    </button>
                </div>
            </div>
        </div>

        <div
            id="invite-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-md w-full">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold text-white">Invite Users</h2>
                    <button
                        id="close-invite-modal-btn"
                        class="text-gray-400 hover:text-white"
                    >
                        &times;
                    </button>
                </div>

                <div id="invite-modal-user-view" style="display: none">
                    <button
                        id="generate-viewer-link-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500 w-full"
                    >
                        Generate Viewer Link
                        <br /><span class="text-xs font-normal"
                            >(View-only access)</span
                        >
                    </button>
                </div>

                <div id="invite-modal-owner-view" style="display: none">
                    <button
                        id="owner-generate-viewer-link-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500 w-full mb-3"
                    >
                        Generate Viewer Link
                        <br /><span class="text-xs font-normal"
                            >(View-only access)</span
                        >
                    </button>
                    <button
                        id="owner-generate-editor-link-btn"
                        class="header-btn bg-blue-600 hover:bg-blue-500 w-full"
                    >
                        Generate Editor Link
                        <br /><span class="text-xs font-normal"
                            >(Single-Use, Edit Access)</span
                        >
                    </button>
                </div>

                <div
                    id="invite-link-display"
                    style="display: none"
                    class="mt-4"
                >
                    <label class="block text-sm font-medium text-slate-300 mb-2"
                        >Share this link:</label
                    >
                    <div class="flex gap-2">
                        <input
                            type="text"
                            id="invite-link-input"
                            readonly
                            class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600"
                        />
                        <button
                            id="copy-invite-link-btn"
                            class="header-btn bg-slate-600 hover:bg-slate-500"
                        >
                            Copy
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div
            id="kick-confirm-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[21000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-red-400 mb-4">Kick User?</h2>
                <p class="text-slate-300 mb-6">
                    Are you sure you want to kick
                    <strong id="kick-user-name" class="text-white"></strong>
                    from this board?
                </p>
                <div class="flex justify-end gap-4">
                    <button id="cancel-kick-btn" class="header-btn">
                        Cancel
                    </button>
                    <button id="confirm-kick-btn" class="header-btn danger">
                        Yes, Kick
                    </button>
                </div>
            </div>
        </div>

        <div
            id="kicked-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[30000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-red-400 mb-4">
                    You have been kicked
                </h2>
                <p class="text-slate-300 mb-6">
                    You have been removed from this board by the owner.
                </p>
                <div class="flex justify-end gap-4">
                    <button
                        id="kicked-ok-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        OK
                    </button>
                </div>
            </div>
        </div>

        <div
            id="deleted-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[30000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-yellow-400 mb-4">
                    Board deleted
                </h2>
                <p class="text-slate-300 mb-6">
                    This board has been deleted by the owner.
                </p>
                <div class="flex justify-end gap-4">
                    <button
                        id="deleted-ok-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        OK
                    </button>
                </div>
            </div>
        </div>

        <div
            id="invalid-invite-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[30000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-yellow-400 mb-4">
                    Invalid Invite Link
                </h2>
                <p class="text-slate-300 mb-6">
                    The invite link you used is invalid or has already been
                    used. You have joined as a viewer.
                </p>
                <div class="flex justify-end gap-4">
                    <button
                        id="invalid-invite-ok-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        OK
                    </button>
                </div>
            </div>
        </div>

        <div
            id="board-settings-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-white mb-4">
                    Board Settings:
                    <strong
                        id="settings-board-name"
                        class="text-indigo-300"
                    ></strong>
                </h2>
                <div class="mb-4">
                    <label
                        for="board-password-change-input"
                        class="block text-sm font-medium text-slate-300 mb-2"
                        >Change Password</label
                    >
                    <input
                        type="password"
                        id="board-password-change-input"
                        class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        placeholder="Enter new password (or blank)"
                    />
                </div>

                <div class="mb-4">
                    <label class="flex items-center">
                        <input
                            type="checkbox"
                            id="remove-password-checkbox"
                            class="h-4 w-4 bg-slate-700 border-slate-600 rounded text-indigo-500 focus:ring-indigo-500"
                        />
                        <span class="ml-2 text-sm text-slate-300"
                            >Remove password</span
                        >
                    </label>
                </div>
                
                <div class="mb-6">
                    <label class="flex items-center">
                        <input
                            type="checkbox"
                            id="board-settings-hidden-checkbox"
                            class="h-4 w-4 bg-slate-700 border-slate-600 rounded text-indigo-500 focus:ring-indigo-500"
                        />
                        <span class="ml-2 text-sm text-slate-300"
                            >Hidden (don't show in lobby list)</span
                        >
                    </label>
                </div>
                
                <div class="flex justify-end gap-4">
                    <button id="cancel-board-settings-btn" class="header-btn">
                        Cancel
                    </button>
                    <button
                        id="submit-board-settings-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        Update
                    </button>
                </div>
            </div>
        </div>

        <div
            id="nickname-password-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[31000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-white mb-4">
                    Password Required
                </h2>
                <p
                    id="nickname-password-prompt-text"
                    class="text-slate-300 mb-6"
                >
                    This nickname is password protected. Please enter the
                    password.
                </p>
                <input
                    type="password"
                    id="nickname-password-input"
                    class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                    placeholder="Enter nickname password..."
                />
                <p
                    id="nickname-password-error"
                    class="text-red-500 text-sm mt-2"
                    style="display: none"
                >
                    Wrong password
                </p>
                <div class="flex justify-end gap-4 mt-6">
                    <button
                        id="cancel-nickname-password-btn"
                        class="header-btn"
                    >
                        Cancel
                    </button>
                    <button
                        id="submit-nickname-password-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        Submit
                    </button>
                </div>
            </div>
        </div>

        <div
            id="manage-nickname-password-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-white mb-4">
                    Nickname Settings:
                    <strong
                        id="manage-nickname-name"
                        class="text-indigo-300"
                    ></strong>
                </h2>
                <div class="mb-4">
                    <label
                        for="nickname-password-change-input"
                        class="block text-sm font-medium text-slate-300 mb-2"
                        >Set/Change Password</label
                    >
                    <input
                        type="password"
                        id="nickname-password-change-input"
                        class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        placeholder="Enter new password (or blank)"
                    />
                </div>
                <div class="mb-6">
                    <label class="flex items-center">
                        <input
                            type="checkbox"
                            id="remove-nickname-password-checkbox"
                            class="h-4 w-4 bg-slate-700 border-slate-600 rounded text-indigo-500 focus:ring-indigo-500"
                        />
                        <span class="ml-2 text-sm text-slate-300"
                            >Remove password</span
                        >
                    </label>
                </div>
                <div class="flex justify-end gap-4">
                    <button
                        id="cancel-nickname-password-settings-btn"
                        class="header-btn"
                    >
                        Cancel
                    </button>
                    <button
                        id="submit-nickname-password-settings-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        Update
                    </button>
                </div>
            </div>
        </div>

        <div
            id="lobby-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[28000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-lg w-full">
                <h2 class="text-2xl font-bold text-white mb-6">Room Lobby</h2>

                <div class="mb-4">
                    <label
                        for="room-search-input"
                        class="block text-sm font-medium text-slate-300 mb-2"
                        >Find a Room</label
                    >
                    <input
                        type="text"
                        id="room-search-input"
                        class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        placeholder="Search for rooms..."
                    />
                </div>

                <h3 class="text-lg font-semibold text-slate-200 mb-2">
                    Available Rooms
                </h3>
                <ul
                    id="lobby-room-list"
                    class="max-h-60 overflow-y-auto text-white bg-slate-800/50 rounded-lg p-2 mb-6"
                ></ul>

                <button
                    id="logout-guest-btn"
                    class="header-btn danger w-full mb-6"
                    style="display: none;"
                >
                    Logout from Guest Nickname
                </button>

                <div class="h-px bg-slate-700 my-6"></div>

                <h3 class="text-lg font-semibold text-slate-200 mb-2">
                    Create a New Room
                </h3>
                <div class="flex gap-4">
                    <input
                        type="text"
                        id="new-room-name-input"
                        class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                        placeholder="Enter new room name..."
                    />
                    <button
                        id="create-room-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500 flex-shrink-0 px-5"
                    >
                        Create
                    </button>
                </div>
            </div>
        </div>

        <div
            id="room-exists-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[29000] flex items-center justify-center"
            style="display: none"
        >
            <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
                <h2 class="text-xl font-bold text-yellow-400 mb-4">
                    Room Exists
                </h2>
                <p id="room-exists-text" class="text-slate-300 mb-6">
                    A room with this name already exists. Would you like to join
                    it?
                </p>
                <div class="flex justify-end gap-4">
                    <button id="cancel-join-room-btn" class="header-btn">
                        No
                    </button>
                    <button
                        id="confirm-join-room-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        Yes, Join
                    </button>
                </div>
            </div>
        </div>

        <script type="module">
                    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
                    import {
                        getAuth,
                        signInAnonymously,
                        signInWithCustomToken,
                        onAuthStateChanged,
                        GoogleAuthProvider,
                        signInWithPopup
                    } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";
                    import {
                        getFirestore,
                        doc,
                        getDoc,
                        addDoc,
                        setDoc,
                        updateDoc,
                        deleteDoc,
                        onSnapshot,
                        collection,
                        query,
                        where,
                        getDocs,
                        writeBatch,
                        serverTimestamp,
                        setLogLevel,
                        orderBy,
                        deleteField
                    } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";

                    const board = document.getElementById('board');
                    const canvasContainer = document.getElementById('canvas-container');
                    const svgLayerConnections = document.getElementById('svg-layer-connections');
                    const svgLayerDrawings = document.getElementById('svg-layer-drawings');
                    const drawingGroup = document.getElementById('drawing-group');
                    const tempDrawingGroup = document.getElementById('temp-drawing-group');
                    const selectionBox = document.getElementById('selection-box');
                    const svgBgRect = document.getElementById('svg-bg-rect');

                    const addImageInput = document.getElementById('add-image-input');

                    const clearNotesBtn = document.getElementById('clear-notes-btn');
                    const clearImagesBtn = document.getElementById('clear-images-btn');
                    const clearLinesBtn = document.getElementById('clear-lines-btn');
                    const clearDrawingsBtn = document.getElementById('clear-drawings-btn');
                    const clearAllBtn = document.getElementById('clear-all-btn');
                    const deleteRoomBtn = document.getElementById('delete-room-btn');
                    const inviteBtn = document.getElementById('invite-btn');

                    const modeMoveBtn = document.getElementById('mode-move');
                    const modeSelectBtn = document.getElementById('mode-select');
                    const modeDrawBtn = document.getElementById('mode-draw');
                    const toggleSnapGridBtn = document.getElementById('toggle-snap-grid');

                    const lineControlPanel = document.getElementById('line-control-panel');
                    const lineTypeSelect = document.getElementById('line-type');
                    const lineColorInput = document.getElementById('line-color');
                    const lineColorControl = document.getElementById('line-color-control');
                    const lineThicknessInput = document.getElementById('line-thickness');
                    const connectFromLineBtn = document.getElementById('connect-from-line-btn');
                    const deleteLineBtn = document.getElementById('delete-line-btn');
                    const closeLinePanelBtn = document.getElementById('close-line-panel-btn');
                    const linePanelHandle = document.getElementById('line-panel-handle');
                    const changeDirectionBtn = document.getElementById('change-direction-btn');

                    const itemMenu = document.getElementById('item-menu');
                    const itemMenuFontBtn = document.getElementById('item-menu-font');
                    const fontSubmenu = document.getElementById('font-submenu');
                    const itemMenuConnectBtn = document.getElementById('item-menu-connect');
                    const connectionSubmenu = document.getElementById('connection-submenu');
                    const itemMenuDeleteNodeBtn = document.getElementById('item-menu-delete-node');
                    const itemMenuBringFrontBtn = document.getElementById('item-menu-bring-front');
                    const itemMenuSendBackBtn = document.getElementById('item-menu-send-back');
                    const submenuSolid = document.getElementById('submenu-solid');
                    const submenuDotted = document.getElementById('submenu-dotted');
                    const submenuArrow = document.getElementById('submenu-arrow');

                    const boardMenu = document.getElementById('board-menu');
                    const boardMenuAddNoteBtn = document.getElementById('board-menu-add-note');
                    const boardMenuAddNodeBtn = document.getElementById('board-menu-add-node');
                    const boardMenuAddTimelineBtn = document.getElementById('board-menu-add-timeline');
                    const boardMenuPasteBtn = document.getElementById('board-menu-paste');

                    const toggleDrawControlsBtn = document.getElementById('toggle-draw-controls');
                    const drawControls = document.getElementById('draw-controls');
                    const drawColorInput = document.getElementById('draw-color');
                    const drawThicknessInput = document.getElementById('draw-thickness');
                    const drawToolPencilBtn = document.getElementById('draw-tool-pencil');
                    const drawToolEraserBtn = document.getElementById('draw-tool-eraser');
                    const eraserSizeSlider = document.getElementById('eraser-size');
                    const eraserSizeContainer = document.getElementById('eraser-size-container');
                    const drawThicknessContainer = document.getElementById('draw-thickness-container');
                    const drawColorContainer = document.getElementById('draw-color-container');

                    const fontSizeSlider = document.getElementById('item-menu-font-size');

                    const eraserCursor = document.getElementById('eraser-cursor');
                    const pencilCursor = document.getElementById('pencil-cursor');

                    const boardNameInput = document.getElementById('board-name-input');
                    const switchBoardBtn = document.getElementById('switch-board-btn');
                    const boardNameDisplay = document.getElementById('board-name-display');
                    const userRoleDisplay = document.getElementById('user-role-display');

                    const usersModalOverlay = document.getElementById('users-modal-overlay');
                    const usersModal = document.getElementById('users-modal');
                    const closeUsersModalBtn = document.getElementById('close-users-modal-btn');
                    const showUsersBtn = document.getElementById('show-users-btn');
                    const usersList = document.getElementById('users-list');

                    const changeNicknameBtn = document.getElementById('change-nickname-btn');

                    const deleteRoomModalOverlay = document.getElementById('delete-room-modal-overlay');
                    const cancelDeleteRoomBtn = document.getElementById('cancel-delete-room-btn');
                    const confirmDeleteRoomBtn = document.getElementById('confirm-delete-room-btn');
                    const deleteRoomName = document.getElementById('delete-room-name');

                    const manageBackupsBtn = document.getElementById('manage-backups-btn');
                    const backupsModalOverlay = document.getElementById('backups-modal-overlay');
                    const backupsModal = document.getElementById('backups-modal');
                    const closeBackupsModalBtn = document.getElementById('close-backups-modal-btn');
                    const createNewBackupBtn = document.getElementById('create-new-backup-btn');
                    const backupsList = document.getElementById('backups-list');

                    const restoreConfirmModalOverlay = document.getElementById('restore-confirm-modal-overlay');
                    const cancelRestoreBtn = document.getElementById('cancel-restore-btn');
                    const confirmRestoreBtn = document.getElementById('confirm-restore-btn');
                    const restoreBackupName = document.getElementById('restore-backup-name');

                    const nicknameModalOverlay = document.getElementById('nickname-modal-overlay');
                    const nicknameModalTitle = document.getElementById('nickname-modal-title');
                    const nicknameInput = document.getElementById('nickname-input');
                    const saveNicknameBtn = document.getElementById('save-nickname-btn');
                    const cancelNicknameBtn = document.getElementById('cancel-nickname-btn');
                    const googleSignInBtn = document.getElementById(
                        "google-signin-btn"
                    );

                    const boardPasswordModalOverlay = document.getElementById('board-password-modal-overlay');
                    const boardPasswordName = document.getElementById('board-password-name');
                    const boardPasswordInput = document.getElementById('board-password-input');
                    const cancelBoardPasswordBtn = document.getElementById('cancel-board-password-btn');
                    const submitBoardPasswordBtn = document.getElementById('submit-board-password-btn');

                    const newBoardPasswordModalOverlay = document.getElementById('new-board-password-modal-overlay');
                    const newBoardName = document.getElementById('new-board-name');
                    const newBoardPasswordInput = document.getElementById('new-board-password-input');
                    const cancelNewBoardBtn = document.getElementById('cancel-new-board-btn');
                    const submitNewBoardBtn = document.getElementById('submit-new-board-btn');

                    const deleteBackupModalOverlay = document.getElementById('delete-backup-modal-overlay');
                    const deleteBackupName = document.getElementById('delete-backup-name');
                    const cancelDeleteBackupBtn = document.getElementById('cancel-delete-backup-btn');
                    const confirmDeleteBackupBtn = document.getElementById('confirm-delete-backup-btn');

                    const inviteModalOverlay = document.getElementById('invite-modal-overlay');
                    const closeInviteModalBtn = document.getElementById('close-invite-modal-btn');
                    const generateViewerLinkBtn = document.getElementById('generate-viewer-link-btn');
                    const ownerGenerateViewerLinkBtn = document.getElementById('owner-generate-viewer-link-btn');
                    const ownerGenerateEditorLinkBtn = document.getElementById('owner-generate-editor-link-btn');
                    const inviteLinkDisplay = document.getElementById('invite-link-display');
                    const inviteLinkInput = document.getElementById('invite-link-input');
                    const copyInviteLinkBtn = document.getElementById('copy-invite-link-btn');

                    const kickConfirmModalOverlay = document.getElementById('kick-confirm-modal-overlay');
                    const kickUserName = document.getElementById('kick-user-name');
                    const cancelKickBtn = document.getElementById('cancel-kick-btn');
                    const confirmKickBtn = document.getElementById('confirm-kick-btn');

                    const kickedModalOverlay = document.getElementById('kicked-modal-overlay');
                    const kickedOkBtn = document.getElementById('kicked-ok-btn');

                    const deletedModalOverlay = document.getElementById('deleted-modal-overlay');
                    const deletedOkBtn = document.getElementById('deleted-ok-btn');

                    const invalidInviteModalOverlay = document.getElementById('invalid-invite-modal-overlay');
                    const invalidInviteOkBtn = document.getElementById('invalid-invite-ok-btn');

                    const boardSettingsBtn = document.getElementById('board-settings-btn');
                    const boardSettingsModalOverlay = document.getElementById('board-settings-modal-overlay');
                    const settingsBoardName = document.getElementById('settings-board-name');
                    const boardPasswordChangeInput = document.getElementById('board-password-change-input');
                    const removePasswordCheckbox = document.getElementById('remove-password-checkbox');
                    const cancelBoardSettingsBtn = document.getElementById('cancel-board-settings-btn');
                    const submitBoardSettingsBtn = document.getElementById('submit-board-settings-btn');

                    const errorModalOverlay = document.getElementById('error-modal-overlay');
                    const errorModalTitle = document.getElementById('error-modal-title');
                    const errorModalText = document.getElementById('error-modal-text');
                    const errorModalOkBtn = document.getElementById('error-modal-ok-btn');


                    const nicknamePasswordModalOverlay = document.getElementById('nickname-password-modal-overlay');
                    const nicknamePasswordPromptText = document.getElementById('nickname-password-prompt-text');
                    const nicknamePasswordInput = document.getElementById('nickname-password-input');
                    const cancelNicknamePasswordBtn = document.getElementById('cancel-nickname-password-btn');
                    const submitNicknamePasswordBtn = document.getElementById('submit-nickname-password-btn');

                    const manageNicknamePasswordModalOverlay = document.getElementById('manage-nickname-password-modal-overlay');
                    const manageNicknameName = document.getElementById('manage-nickname-name');
                    const nicknamePasswordChangeInput = document.getElementById('nickname-password-change-input');
                    const removeNicknamePasswordCheckbox = document.getElementById('remove-nickname-password-checkbox');
                    const cancelNicknamePasswordSettingsBtn = document.getElementById('cancel-nickname-password-settings-btn');
                    const submitNicknamePasswordSettingsBtn = document.getElementById('submit-nickname-password-settings-btn');

                    const passwordSettingsBtn = document.getElementById('password-settings-btn');


                    const lobbyModalOverlay = document.getElementById('lobby-modal-overlay');
                    const roomSearchInput = document.getElementById('room-search-input');
                    const lobbyRoomList = document.getElementById('lobby-room-list');
                    const newRoomNameInput = document.getElementById('new-room-name-input');
                    const createRoomBtn = document.getElementById('create-room-btn');

                    const roomExistsModalOverlay = document.getElementById('room-exists-modal-overlay');
                    const roomExistsText = document.getElementById('room-exists-text');
                    const cancelJoinRoomBtn = document.getElementById('cancel-join-room-btn');
                    const confirmJoinRoomBtn = document.getElementById('confirm-join-room-btn');

                    const leaveRoomBtn = document.getElementById('leave-room-btn');
                    
                    const logoutGuestBtn = document.getElementById('logout-guest-btn');

                    const sidebarMenu = document.getElementById('sidebar-menu');
                    const sidebarItemList = document.getElementById('sidebar-item-list');
                    const toggleSidebarBtn = document.getElementById('toggle-sidebar-button');
                    const closeSidebarBtn = document.getElementById('close-sidebar-button');
                    const sidebarSearchInput = document.getElementById('sidebar-search-input');
                    const centerBoardBtn = document.getElementById('center-board-btn');

                    let app, db, auth, userId;
                    let itemsCol, connectionsCol, drawingsCol, usersCol, backupsCol, invitesCol, boardRef;
                    let nicknamesCol;
                    let unsubscribeItems, unsubscribeConnections, unsubscribeDrawings, unsubscribeUsers, unsubscribeBackups, unsubscribeUserDoc;
                    let currentBoardId = null;

                    let sidebarItemCache = new Map();

                    let userNickname = "User";
                    let currentUserRole = "viewer";
                    let isBoardOwner = false;
                    let canEdit = false;
                    let presenceInterval;
                    let pendingRestoreBackupId = null;
                    let pendingKickUid = null;
                    let unsubscribeBoardsList = null;
                    let currentUserListHash = '';
                    let userListCache = new Map();

                    let allBoards = [];
                    let pendingRoomName = '', pendingHasPassword = false;
                    let isVoluntarilyLeaving = false;
                    let isSwitchingRooms = false;

                    let animationFrameMap = new Map();

                    const NICKNAME_STORAGE_KEY = 'evidenceBoardNickname';

                    const PENCIL_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>`;
                    const ERASER_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                              <path d="M16.142 3.858a2.25 2.25 0 00-3.182 0L4.3 12.518a2.25 2.25 0 000 3.182l.06.06a2.25 2.25 0 003.182 0L16.2 6.9a2.25 2.25 0 000-3.182l-.06-.06zM5.57 14.43a.75.75 0 01-1.06 0l-.06-.06a.75.75 0 010-1.06l8.66-8.66a.75.75 0 011.06 0l.06.06a.75.75 0 010 1.06l-8.66 8.66z" />
                                            </svg>`;

                    const MIN_DRAW_DISTANCE = 4;
                    const GRID_SIZE = 20;

                    let items = new Map();
                    let connections = [];
                    let itemConnectionsMap = new Map();

                    let isDragging = false;
                    let isResizing = false;
                    let isDrawingLine = false;
                    let isPanning = false;
                    let isSelecting = false;
                    let isDrawingFreehand = false;
                    let isDraggingPanel = false;
                    let isMovingTimelineEvent = false;
                    let isResizingTimelineEvent = false;

                    let drawingLineType = 'solid';
                    let drawTool = 'pencil';

                    let currentElement = null;
                    let currentItemForMenu = null;
                    let currentTimelineEventData = null;
                    let currentTimelineConfigData = null;
                    let selectedItems = new Map();
                    let selectedLines = new Map();
                    let selectedLine = null;

                    const timelineConfigModalOverlay = document.getElementById('timeline-config-modal-overlay');
                    const timelineConfigColorInput = document.getElementById('timeline-config-color');
                    const timelineConfigModeSelect = document.getElementById('timeline-config-mode');
                    const timelineConfigDirectionSelect = document.getElementById('timeline-config-direction');
                    const timelineConfigEventsList = document.getElementById('timeline-config-events-list');
                    const timelineConfigAddEventBtn = document.getElementById('timeline-config-add-event');
                    const timelineConfigCancelBtn = document.getElementById('timeline-config-cancel-btn');
                    const timelineConfigSaveBtn = document.getElementById('timeline-config-save-btn');

                    let startPos = { x: 0, y: 0 };
                    let startSize = { w: 0, h: 0 };
                    let panelStartPos = { x: 0, y: 0 };

                    let lineStartIdentifier = null;
                    let tempLine = null;
                    let currentFreehandPath = null;
                    let currentFreehandPoints = [];
                    let currentFreehandPathString = "";

                    let zIndexCounter = 10;
                    let cursorMode = 'move';
                    let snapToGrid = false;

                    let scale = 1;
                    let translateX = 0;
                    let translateY = 0;

                    let lastMousePos = { x: 0, y: 0 };
                    let lineClickPos = { x: 0, y: 0 };

                    const appId = 'evidence-board';
                    const firebaseConfig = {
                        apiKey: "AIzaSyCZjIpFdU4AX-4vwDfUlCEqw88_9p5YgLw",
                        authDomain: "evidence-board.firebaseapp.com",
                        projectId: "evidence-board",
                        storageBucket: "evidence-board.firebasestorage.app",
                        messagingSenderId: "63512059873",
                        appId: "1:63512059873:web:23d55acfebc8744a5d7ca0",
                        measurementId: "G-GQRV3HBDX1"
                    };

                    try {
                        app = initializeApp(firebaseConfig);
                        db = getFirestore(app);
                        auth = getAuth(app);
                        nicknamesCol = collection(db, 'artifacts', appId, 'public', 'data', 'nicknamePasswords');
                        setLogLevel('Debug');
                    } catch (e) {
                        console.error("Firebase initialization error:", e);
                        board.innerHTML = `<div class="text-red-500 p-4">Error initializing Firebase. Please check config.</div>`;
                    }


                    function detachListeners() {
                        animationFrameMap.forEach(frameId => cancelAnimationFrame(frameId));
                        animationFrameMap.clear();

                        if (unsubscribeItems) {
                            unsubscribeItems();
                            unsubscribeItems = null;
                        }
                        if (unsubscribeConnections) {
                            unsubscribeConnections();
                            unsubscribeConnections = null;
                        }
                        if (unsubscribeDrawings) {
                            unsubscribeDrawings();
                            unsubscribeDrawings = null;
                        }
                        if (unsubscribeUsers) {
                            unsubscribeUsers();
                            unsubscribeUsers = null;
                        }
                        if (unsubscribeBackups) {
                            unsubscribeBackups();
                            unsubscribeBackups = null;
                        }
                        if (unsubscribeUserDoc) {
                            unsubscribeUserDoc();
                            unsubscribeUserDoc = null;
                        }
                        if (unsubscribeBoardsList) {
                            unsubscribeBoardsList();
                            unsubscribeBoardsList = null;
                        }

                        userListCache.clear();

                        console.log("Detached all Firestore listeners.");
                    }


                    async function updateNicknameInFirestore(newNickname) {
                        userNickname = newNickname;


                        if (usersCol && userId) {
                            try {
                                const userRef = doc(usersCol, userId);
                                await updateDoc(userRef, { nickname: newNickname });
                            } catch (e) {
                                console.error("Error updating nickname in board's user collection:", e);
                            }
                        }
                    }

                    async function getNicknamePasswordDoc(nickname) {
                        try {
                            const nicknameRef = doc(nicknamesCol, nickname);
                            const nicknameSnap = await getDoc(nicknameRef);
                            return nicknameSnap;
                        } catch (e) {
                            console.error("Error checking nickname password:", e);
                            return null;
                        }
                    }


                    async function validateNicknamePassword(nickname, nicknameSnap) {
                        let passwordCorrect = false;
                        const expectedPassword = nicknameSnap.data().password;

                        const nicknamePasswordError = document.getElementById('nickname-password-error');
                        const nicknamePasswordInputEl = document.getElementById('nickname-password-input');

                        while (!passwordCorrect) {

                            nicknamePasswordError.style.display = 'none';
                            nicknamePasswordError.textContent = '';
                            nicknamePasswordInputEl.classList.remove('border-red-500', 'focus:ring-red-500');
                            nicknamePasswordInputEl.classList.add('border-slate-600', 'focus:ring-indigo-500');

                            const password = await showModalPrompt(
                                nicknamePasswordModalOverlay,
                                nicknamePasswordInput,
                                submitNicknamePasswordBtn,
                                cancelNicknamePasswordBtn,
                                {
                                    text: `The nickname <strong class="text-white">${nickname}</strong> is password protected. Please enter the password to use it.`,
                                    textEl: nicknamePasswordPromptText,
                                    closeOnOverlayClick: false,
                                    dontHideOnSubmit: true
                                }
                            );

                            if (password === null) {
                                nicknamePasswordModalOverlay.style.display = 'none';
                                nicknamePasswordError.style.display = 'none';
                                nicknamePasswordInputEl.classList.remove('border-red-500', 'focus:ring-red-500');
                                nicknamePasswordInputEl.classList.add('border-slate-600', 'focus:ring-indigo-500');
                                return false;
                            }

                            const hashedInput = await sha512(password);
                            if (hashedInput === expectedPassword) {
                                passwordCorrect = true;
                                nicknamePasswordError.style.display = 'none';
                                nicknamePasswordInputEl.classList.remove('border-red-500', 'focus:ring-red-500');
                                nicknamePasswordInputEl.classList.add('border-slate-600', 'focus:ring-indigo-500');
                            } else {
                                nicknamePasswordError.textContent = 'Wrong password';
                                nicknamePasswordError.style.display = 'block';
                                nicknamePasswordInputEl.classList.remove('border-slate-600', 'focus:ring-indigo-500');
                                nicknamePasswordInputEl.classList.add('border-red-500', 'focus:ring-red-500');
                            }
                        }
                        nicknamePasswordModalOverlay.style.display = 'none';
                        return true;
                    }

                    function showModalPrompt(overlay, inputEl, submitBtn, cancelBtn = null, data = {}) {
                        return new Promise((resolve) => {
                            overlay.style.display = 'flex';
                            inputEl.value = data.defaultValue || '';

                            if (data.title) data.titleEl.textContent = data.title;
                            if (data.text) data.textEl.innerHTML = data.text;
                            if (data.placeholder) inputEl.placeholder = data.placeholder;

                            inputEl.focus();


                            const dontHideOnSubmit = data.dontHideOnSubmit || false;

                            const onSubmit = (e) => {
                                e.preventDefault();
                                cleanup(dontHideOnSubmit);
                                resolve(inputEl.value);
                            };

                            const onCancel = (e) => {
                                if (e) e.preventDefault();
                                cleanup(false);
                                resolve(null);
                            };

                            const onEnter = (e) => {
                                if (e.key === 'Enter') {
                                    onSubmit(e);
                                }
                            };

                            const closeOnOverlayClick = data.closeOnOverlayClick !== false;

                            const onOverlayClick = (e) => {
                                if (e.target === overlay && closeOnOverlayClick) {
                                    onCancel(null);
                                }
                            };

                            submitBtn.addEventListener('click', onSubmit);
                            inputEl.addEventListener('keydown', onEnter);
                            if (cancelBtn) cancelBtn.addEventListener('click', onCancel);

                            overlay.addEventListener('click', onOverlayClick);


                            function cleanup(dontHide = false) {
                                if (!dontHide) {
                                    overlay.style.display = 'none';
                                }
                                submitBtn.removeEventListener('click', onSubmit);
                                inputEl.removeEventListener('keydown', onEnter);
                                if (cancelBtn) cancelBtn.removeEventListener('click', onCancel);

                                overlay.removeEventListener('click', onOverlayClick);

                            }
                        });
                    }

                    function showModalConfirm(overlay, confirmBtn, cancelBtn, data = {}) {
                        return new Promise((resolve) => {
                            overlay.style.display = 'flex';
                            if (data.text) data.textEl.innerHTML = data.text;

                            const onConfirm = () => {
                                cleanup();
                                resolve(true);
                            };

                            const onCancel = () => {
                                cleanup();
                                resolve(false);
                            };


                            const onOverlayClick = (e) => {
                                if (e.target === overlay) {
                                    onCancel();
                                }
                            };


                            confirmBtn.addEventListener('click', onConfirm);
                            cancelBtn.addEventListener('click', onCancel);
                            overlay.addEventListener('click', onOverlayClick);

                            function cleanup() {
                                overlay.style.display = 'none';
                                confirmBtn.removeEventListener('click', onConfirm);
                                cancelBtn.removeEventListener('click', onCancel);
                                overlay.removeEventListener('click', onOverlayClick);
                            }
                        });
                    }

                    function showModalAlert(overlay, okBtn, data = {}) {
                        return new Promise((resolve) => {
                             overlay.style.display = 'flex';
                             if (data.title && data.titleEl) data.titleEl.textContent = data.title;


                             if (data.text && data.textEl) data.textEl.innerHTML = data.text;

                             okBtn.focus();

                             const onOk = () => {
                                 cleanup();
                                 if(data.callback) data.callback();
                                 resolve();
                             };

                             const onEnter = (e) => {
                                if (e.key === 'Enter') {
                                    e.preventDefault();
                                    onOk();
                                }
                             };

                             function cleanup() {
                                overlay.style.display = 'none';
                                okBtn.removeEventListener('click', onOk);
                                document.removeEventListener('keydown', onEnter);
                             }

                             okBtn.addEventListener('click', onOk);
                             document.addEventListener('keydown', onEnter);
                        });
                    }

                    async function sha512(str) {
                        if (typeof crypto === 'undefined' || !crypto.subtle) {
                            console.warn('Web Crypto API not available. Using simple string.');
                            return str;
                        }
                        const text = new TextEncoder().encode(str);
                        const hashBuffer = await crypto.subtle.digest('SHA-512', text);
                        const hashArray = Array.from(new Uint8Array(hashBuffer));
                        const hexHash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                        return hexHash;
                    }


                    async function updateBoardOwnership(nickname, newUserId) {
                        console.log(`Checking for boards owned by '${nickname}' to update ownerId to '${newUserId}'...`);
                        try {
                            const boardsCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'boards');


                            const q = query(boardsCollectionRef, where('owner', '==', nickname));

                            const querySnapshot = await getDocs(q);

                            if (querySnapshot.empty) {
                                console.log("No boards found owned by this nickname. No updates needed.");
                                return;
                            }


                            const batch = writeBatch(db);
                            let updateCount = 0;

                            querySnapshot.forEach((docSnap) => {
                                const boardData = docSnap.data();

                                if (boardData.ownerId !== newUserId) {
                                    batch.update(docSnap.ref, { ownerId: newUserId });
                                    updateCount++;
                                }
                            });


                            if (updateCount > 0) {
                                await batch.commit();
                                console.log(`Successfully updated ownerId for ${updateCount} boards owned by '${nickname}'.`);
                            } else {
                                console.log("All boards owned by this nickname already have the correct ownerId.");
                            }

                        } catch (e) {
                            console.error("Error updating board ownership:", e);



                        }
                    }

                    function setupFirestoreListeners(boardId) {

                        detachListeners();

                        items.forEach(item => item.el.remove());
                        items.clear();
                        connections.forEach(conn => {
                            conn.lineEl.remove();
                            conn.hitBoxEl.remove();
                            if (conn.arrowHead) conn.arrowHead.remove();
                        });
                        connections = [];
                        drawingGroup.innerHTML = '';
                        itemConnectionsMap.clear();

                        boardRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', boardId);
                        itemsCol = collection(boardRef, 'items');
                        connectionsCol = collection(boardRef, 'connections');
                        drawingsCol = collection(boardRef, 'drawings');
                        usersCol = collection(boardRef, 'users');
                        backupsCol = collection(boardRef, 'backups');
                        invitesCol = collection(boardRef, 'invites');

                        userListCache.clear();

                        unsubscribeItems = onSnapshot(itemsCol, (snapshot) => {
                            let itemsChanged = false;
                            snapshot.docChanges().forEach((change) => {
                                const data = change.doc.data();
                                const id = change.doc.id;

                                if (change.type === 'added') {
                                    renderItem(id, data);
                                    if(data.type === 'note' || data.type === 'image') {
                                        itemsChanged = true;
                                        sidebarItemCache.set(id, data);
                                    }
                                }
                                if (change.type === 'modified') {
                                    const item = items.get(id);
                                    if (item) {
                                        
                                        if (isDragging && selectedItems.has(id)) {
                                            item.el.style.zIndex = data.zIndex;
                                        } else {
                                            
                                            const oldX = item.el.style.left;
                                            const oldY = item.el.style.top;
                                            const newX = data.x;
                                            const newY = data.y;

                                            if (oldX !== newX || oldY !== newY) {
                                                item.el.classList.add('item-transition');
                                                
                                                if (animationFrameMap.has(id)) {
                                                    cancelAnimationFrame(animationFrameMap.get(id));
                                                }

                                                function updateConnectionsDuringAnimation() {
                                                    updateAllConnectionsForItem(id);
                                                    animationFrameMap.set(id, requestAnimationFrame(updateConnectionsDuringAnimation));
                                                }
                                                
                                                const onTransitionEnd = () => {
                                                    if (animationFrameMap.has(id)) {
                                                        cancelAnimationFrame(animationFrameMap.get(id));
                                                        animationFrameMap.delete(id);
                                                    }
                                                    item.el.classList.remove('item-transition');
                                                    item.el.removeEventListener('transitionend', onTransitionEnd);
                                                    updateAllConnectionsForItem(id);
                                                };
                                                
                                                item.el.removeEventListener('transitionend', onTransitionEnd); 
                                                item.el.addEventListener('transitionend', onTransitionEnd);
                                                
                                                animationFrameMap.set(id, requestAnimationFrame(updateConnectionsDuringAnimation));
                                                
                                                item.el.style.left = newX;
                                                item.el.style.top = newY;
                                            } else {
                                                item.el.style.left = newX;
                                                item.el.style.top = newY;
                                            }
                                            
                                            item.el.style.width = data.width;
                                            item.el.style.height = data.height;
                                            item.el.style.zIndex = data.zIndex;
                                        }

                                        if (data.type === 'note') {
                                            const textarea = item.el.querySelector('textarea');
                                            if (textarea.value !== data.content) textarea.value = data.content;
                                            textarea.style.fontFamily = data.fontFamily;
                                            textarea.style.fontSize = data.fontSize;
                                        } else if (data.type === 'image') {
                                            const captionEl = item.el.querySelector('.caption');
                                            if (captionEl.innerHTML !== data.caption) captionEl.innerHTML = data.caption;
                                            captionEl.style.display = data.captionVisible ? 'block' : 'none';
                                            item.el.querySelector('.image-wrapper').classList.toggle('no-caption', !data.captionVisible);
                                            captionEl.style.fontFamily = data.fontFamily;
                                            captionEl.style.fontSize = data.fontSize;
                                        }
                                        else if (data.type === 'timeline') {
                                            const oldData = item.data;
                                            if (JSON.stringify(oldData.events) !== JSON.stringify(data.events) ||
                                                oldData.mainColor !== data.mainColor ||
                                                oldData.mode !== data.mode ||
                                                oldData.direction !== data.direction) 
                                            {
                                                renderTimelineSVG(item.el.querySelector('svg'), item.el, data);
                                            }
                                        }
                                        item.data = data;
                                        if (!item.el.classList.contains('item-transition')) {
                                            updateAllConnectionsForItem(id);
                                        }
                                    }
                                    if(data.type === 'note' || data.type === 'image') {
                                        itemsChanged = true;
                                        sidebarItemCache.set(id, data);
                                    }
                                }
                                if (change.type === 'removed') {
                                    const item = items.get(id);
                                    removeItemLocally(id);
                                    if(item && (item.data.type === 'note' || item.data.type === 'image')) {
                                        itemsChanged = true;
                                        sidebarItemCache.delete(id);
                                    }
                                }
                            });
                            
                            if (itemsChanged) {
                                renderSidebarList();
                            }
                        });

                        unsubscribeConnections = onSnapshot(connectionsCol, (snapshot) => {
                            snapshot.docChanges().forEach((change) => {
                                const data = change.doc.data();
                                const id = change.doc.id;

                                if (change.type === 'added') {
                                    renderConnection(id, data);
                                }
                                if (change.type === 'modified') {
                                    const conn = connections.find(c => c.id === id);
                                    if (conn) {
                                        conn.type = data.type;
                                        conn.color = data.color;
                                        conn.thickness = data.thickness;
                                        conn.startId = data.startId;
                                        conn.endId = data.endId;
                                        updateConnectionLine(conn);
                                    }
                                }
                                if (change.type === 'removed') {
                                    removeConnectionLocally(id);
                                }
                            });
                        });

                        const drawingsQuery = query(drawingsCol, orderBy("createdAt"));

                        unsubscribeDrawings = onSnapshot(drawingsQuery, (snapshot) => {
                            snapshot.docChanges().forEach((change) => {
                                const data = change.doc.data();
                                const id = change.doc.id;

                                if (change.type === 'added') {
                                    if (data && data.stroke && data.strokeWidth && data.d) {
                                        const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                        pathEl.setAttribute('class', 'freehand-drawing');
                                        pathEl.setAttribute('vector-effect', 'non-scaling-stroke');
                                        pathEl.setAttribute('fill', 'none');
                                        pathEl.setAttribute('stroke-linecap', 'round');
                                        pathEl.setAttribute('stroke-linejoin', 'round');
                                        pathEl.setAttribute('stroke', data.stroke);
                                        pathEl.setAttribute('stroke-width', data.strokeWidth);
                                        pathEl.setAttribute('d', data.d);
                                        pathEl.dataset.id = id;
                                        drawingGroup.appendChild(pathEl);
                                    }
                                }
                                if (change.type === 'modified') {
                                    const pathEl = drawingGroup.querySelector(`path[data-id="${id}"]`);
                                    if (pathEl) {
                                        pathEl.setAttribute('stroke', data.stroke);
                                        pathEl.setAttribute('stroke-width', data.strokeWidth);
                                        pathEl.setAttribute('d', data.d);
                                    }
                                }
                                if (change.type === 'removed') {
                                    const pathEl = drawingGroup.querySelector(`path[data-id="${id}"]`);
                                    if (pathEl) {
                                        pathEl.remove();
                                    }
                                }
                            });
                        });

                        unsubscribeUsers = onSnapshot(usersCol, (snapshot) => {

                            const newConnectedUsers = [];
                            userListCache.clear();

                            snapshot.docs.forEach(doc => {
                                const data = doc.data();
                                const id = doc.id;

                                userListCache.set(id, data);

                                newConnectedUsers.push({
                                    id: id,
                                    ...data
                                });
                            });

                            const myData = userListCache.get(userId);
                            if (myData) {
                                const newRole = myData.role;
                                const newOwnerStatus = (newRole === 'owner');

                                if (newRole !== currentUserRole || newOwnerStatus !== isBoardOwner) {
                                    console.log(`Funo do usurio atualizada de ${currentUserRole} (Dono: ${isBoardOwner}) para ${newRole} (Dono: ${newOwnerStatus})`);
                                    currentUserRole = newRole;
                                    isBoardOwner = newOwnerStatus;
                                    setEditingPermissions(currentUserRole === 'owner' || currentUserRole === 'editor');
                                }
                            }
                            updateUsersModal(newConnectedUsers);
                        });

                        unsubscribeUserDoc = onSnapshot(doc(usersCol, userId), async (doc) => {
                            if (isVoluntarilyLeaving) {
                                console.log("User doc change (delete/kick) ignored due to voluntary leave.");
                                return;
                            }
                            
                            if (!doc.exists()) {
                                await handleKick();
                            } else if (doc.data().kicked === true) {
                                await handleKick();
                            }
                        });

                        unsubscribeBackups = onSnapshot(backupsCol, (snapshot) => {
                            backupsList.innerHTML = '';
                            const docs = snapshot.docs;
                            docs.sort((a, b) => b.data().createdAt - a.data().createdAt);

                            docs.forEach(backupDoc => {
                                const backup = backupDoc.data();
                                const backupId = backupDoc.id;
                                const date = backup.createdAt?.toDate ? backup.createdAt.toDate().toLocaleString() : 'Unknown Date';

                                const li = document.createElement('li');
                                li.className = 'flex justify-between items-center p-2 border-b border-slate-700 last:border-b-0';
                                li.innerHTML = `
                                    <span class="text-sm">${date}</span>
                                    <div>
                                        <button class="permission-btn promote restore-btn text-xs" data-backup-id="${backupId}" data-backup-name="${date}">Restore</button>
                                        <button class="permission-btn demote delete-backup-btn text-xs" data-backup-id="${backupId}">Delete</button>
                                    </div>
                                `;
                                backupsList.appendChild(li);
                            });
                        });
                   }

                   async function handleKick() {
                        console.log("handleKick triggered");

                        if (isVoluntarilyLeaving) {
                            console.log("handleKick aborted, user is voluntarily leaving.");
                            return;
                        }

                        if (isSwitchingRooms) {
                            console.log("handleKick aborted, user is switching rooms.");
                            return;
                        }

                        if (currentCleanupFunction) {
                            window.removeEventListener('beforeunload', currentCleanupFunction);
                            window.removeEventListener('pagehide', currentCleanupFunction);
                        }
                        if (presenceInterval) {
                            clearInterval(presenceInterval);
                            presenceInterval = null;
                        }
                        currentCleanupFunction = () => {};

                        try {
                            if (boardRef) {
                                const boardSnap = await getDoc(boardRef);
                                if (!boardSnap.exists() || boardSnap.data()?.status === 'deleting') {
                                    leaveRoom(false);
                                    showModalAlert(deletedModalOverlay, deletedOkBtn);
                                } else {
                                    leaveRoom(true);
                                }
                            } else {
                                leaveRoom(true);
                            }
                        } catch (e) {
                            console.error("Erro ao verificar a existncia da sala:", e);
                            leaveRoom(true);
                        }
                   }

                   backupsList.addEventListener('click', async (e) => {
                       const target = e.target;
                       if (target.classList.contains('restore-btn')) {
                           if (!canEdit) return;
                           pendingRestoreBackupId = target.dataset.backupId;
                           restoreBackupName.textContent = target.dataset.backupName;
                           restoreConfirmModalOverlay.style.display = 'flex';
                       } else if (target.classList.contains('delete-backup-btn')) {
                           if (!canEdit) return;
                           const backupId = target.dataset.backupId;
                           const backupNameText = target.closest('li').querySelector('.text-sm').textContent;

                           const confirmed = await showModalConfirm(
                                deleteBackupModalOverlay,
                                confirmDeleteBackupBtn,
                                cancelDeleteBackupBtn,
                                {
                                    text: `Are you sure you want to permanently delete the backup from <strong class="text-white">${backupNameText}</strong>? This action cannot be undone.`,
                                    textEl: deleteBackupModalOverlay.querySelector('p')
                                }
                           );

                           if (confirmed) {
                               deleteBackup(backupId);
                           }
                       }
                   });

                   async function deleteBackup(backupId) {
                       if (!canEdit) return;
                       try {
                           await deleteDoc(doc(backupsCol, backupId));
                       } catch (e) {
                           console.error("Error deleting backup:", e);
                       }
                   }

                   cancelRestoreBtn.addEventListener('click', () => {
                       restoreConfirmModalOverlay.style.display = 'none';
                       pendingRestoreBackupId = null;
                   });

                   confirmRestoreBtn.addEventListener('click', () => {
                       if (!canEdit || !pendingRestoreBackupId) return;

                       const backupId = pendingRestoreBackupId;
                       pendingRestoreBackupId = null;
                       restoreConfirmModalOverlay.style.display = 'none';

                       startRestoreProcess(backupId);
                   });

                   async function clearBoardContent() {
                       if (!canEdit) return;

                       const itemsSnap = await getDocs(itemsCol);
                       const connectionsSnap = await getDocs(connectionsCol);
                       const drawingsSnap = await getDocs(drawingsCol);

                       const batch = writeBatch(db);

                       itemsSnap.docs.forEach(d => batch.delete(d.ref));
                       connectionsSnap.docs.forEach(d => batch.delete(d.ref));
                       drawingsSnap.docs.forEach(d => batch.delete(d.ref));

                       await batch.commit();
                   }

                   async function startRestoreProcess(backupId) {
                       if (!canEdit) return;

                       backupsModalOverlay.style.display = 'none';
                       console.log(`Restoring backup ${backupId}...`);

                       try {
                           const backupRef = doc(backupsCol, backupId);
                           const backupSnap = await getDoc(backupRef);

                           if (!backupSnap.exists()) {
                               console.error("Backup not found!");
                               return;
                           }

                           const backupData = backupSnap.data();

                           await clearBoardContent();

                           const batch = writeBatch(db);

                           if (backupData.items && Array.isArray(backupData.items)) {
                               backupData.items.forEach(item => {

                                   const newItemRef = doc(itemsCol, item.id);
                                   const data = { ...item };
                                   delete data.id;
                                   batch.set(newItemRef, data);
                               });
                           }

                           if (backupData.connections && Array.isArray(backupData.connections)) {
                               backupData.connections.forEach(conn => {

                                   const newConnRef = doc(connectionsCol, conn.id);
                                   const data = { ...conn };
                                   delete data.id;
                                   batch.set(newConnRef, data);
                               });
                           }

                           if (backupData.drawings && Array.isArray(backupData.drawings)) {
                               backupData.drawings.forEach(draw => {

                                   const newDrawRef = doc(drawingsCol, draw.id);
                                   const data = { ...draw };
                                   delete data.id;
                                   batch.set(newDrawRef, data);
                               });
                           }

                           await batch.commit();

                           console.log("Restore complete.");

                       } catch (e) {
                           console.error("Error restoring backup:", e);
                       }
                   }

                   createNewBackupBtn.addEventListener('click', async () => {
                       if (!canEdit) return;

                       const btn = createNewBackupBtn;
                       btn.disabled = true;
                       btn.textContent = "Creating Backup...";

                       try {
                           const itemsSnap = await getDocs(itemsCol);
                           const connectionsSnap = await getDocs(connectionsCol);
                           const drawingsSnap = await getDocs(drawingsCol);

                           const itemsData = itemsSnap.docs.map(itemDoc => ({ id: itemDoc.id, ...itemDoc.data() }));
                           const connectionsData = connectionsSnap.docs.map(connDoc => ({ id: connDoc.id, ...connDoc.data() }));
                           const drawingsData = drawingsSnap.docs.map(drawDoc => ({ id: drawDoc.id, ...drawDoc.data() }));

                           await addDoc(backupsCol, {
                               createdAt: serverTimestamp(),
                               items: itemsData,
                               connections: connectionsData,
                               drawings: drawingsData
                           });

                       } catch (e) {
                           console.error("Error creating backup:", e);
                       } finally {
                           btn.disabled = false;
                           btn.textContent = "Create New Backup";
                       }
                   });

                   manageBackupsBtn.addEventListener('click', () => {
                       if (!canEdit) return;
                       backupsModalOverlay.style.display = 'flex';
                   });

                   closeBackupsModalBtn.addEventListener('click', () => {
                       backupsModalOverlay.style.display = 'none';
                   });

                   boardSettingsBtn.addEventListener('click', async () => {
                       if (!isBoardOwner) return;

                       let currentHiddenStatus = false;
                       try {
                           const boardSnap = await getDoc(boardRef);
                           if (boardSnap.exists()) {
                               currentHiddenStatus = boardSnap.data().hidden === true;
                           }
                       } catch (e) {
                           console.error("Error fetching board settings:", e);
                           showModalAlert(errorModalOverlay, errorModalOkBtn, {
                                title: "Error",
                                titleEl: errorModalTitle,
                                text: "Could not load board settings. Please try again.",
                                textEl: errorModalText
                           });
                           return;
                       }

                       settingsBoardName.textContent = currentBoardId;
                       boardPasswordChangeInput.value = '';
                       removePasswordCheckbox.checked = false;
                       document.getElementById('board-settings-hidden-checkbox').checked = currentHiddenStatus;

                       boardSettingsModalOverlay.style.display = 'flex';
                   });


                   boardSettingsBtn.addEventListener('click', () => {
                       if (!isBoardOwner) return;
                       settingsBoardName.textContent = currentBoardId;
                       boardPasswordChangeInput.value = '';
                       removePasswordCheckbox.checked = false;
                       boardSettingsModalOverlay.style.display = 'flex';
                   });

            cancelBoardSettingsBtn.addEventListener('click', () => {
                       boardSettingsModalOverlay.style.display = 'none';
                   });

                   boardSettingsModalOverlay.addEventListener('click', (e) => {
                        if (e.target === boardSettingsModalOverlay) {
                            boardSettingsModalOverlay.style.display = 'none';
                        }
                   });

                    submitBoardSettingsBtn.addEventListener('click', async () => {
                        if (!isBoardOwner) return;

                        submitBoardSettingsBtn.disabled = true;
                        submitBoardSettingsBtn.textContent = 'Updating...';

                        try {
                            const boardMetaRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', currentBoardId);
                            const newPassword = boardPasswordChangeInput.value;
                            const isRemoving = removePasswordCheckbox.checked;

                            const isHidden = document.getElementById('board-settings-hidden-checkbox').checked;

                            const updateData = {
                                hidden: isHidden
                            };

                            if (isRemoving) {
                                updateData.hasPassword = false;
                                updateData.password = deleteField();
                            } else if (newPassword && newPassword.trim() !== "") {
                                updateData.hasPassword = true;
                                updateData.password = await sha512(newPassword);
                            }

                            if (Object.keys(updateData).length > 0) {
                                await updateDoc(boardMetaRef, updateData);
                            }

                            boardSettingsModalOverlay.style.display = 'none';

                        } catch (e) {
                            console.error("Error updating board settings:", e);
                            await showModalAlert(
                                errorModalOverlay,
                                errorModalOkBtn,
                                {
                                    title: "Error",
                                    titleEl: errorModalTitle,
                                    text: "Could not update board settings. Please try again.",
                                    textEl: errorModalText
                                }
                            );
                        } finally {
                            submitBoardSettingsBtn.disabled = false;
                            submitBoardSettingsBtn.textContent = 'Update';
                        }
                    });

            function updateUsersModal(users) {
                const now = new Date();
                const staleThreshold = new Date(now.getTime() - 60000);
                const activeUserIds = new Set();

                const sortedUsers = [...users].sort((a, b) => {
                    const order = { owner: 0, editor: 1, viewer: 2 };
                    return (order[a.role] || 9) - (order[b.role] || 9);
                });

                const activeUsers = [];

                sortedUsers.forEach(user => {
                    if(user.kicked) return;

                    const lastSeen = user.last_seen?.toDate ? user.last_seen.toDate() : null;
                    if (!lastSeen || lastSeen < staleThreshold) {
                        return;
                    }

                    if (!user.nickname || user.nickname === 'undefined') {
                        return;
                    }

                    activeUserIds.add(user.id);
                    activeUsers.push(user);
                });

                        console.log(`Rebuilding user modal DOM...`);

                        activeUsers.forEach(user => {
                            let li = usersList.querySelector(`li[data-uid="${user.id}"]`);


                            let roleBadge = '';
                            if (user.role === 'owner') roleBadge = '<span class="role-badge role-owner">Owner</span>';
                            else if (user.role === 'editor') roleBadge = '<span class="role-badge role-editor">Editor</span>';
                            else roleBadge = '<span class="role-badge role-viewer">Viewer</span>';

                            let permissionButtonsHTML = '';
                            if (isBoardOwner && user.id !== userId) {
                                if (user.role === 'viewer') {
                                    permissionButtonsHTML += `<button class="permission-btn promote" data-uid="${user.id}">Make Editor</button>`;
                                } else if (user.role === 'editor') {
                                    permissionButtonsHTML += `<button class="permission-btn demote" data-uid="${user.id}">Make Viewer</button>`;
                                }
                                permissionButtonsHTML += `<button class="permission-btn kick" data-uid="${user.id}" data-nickname="${user.nickname}">Kick</button>`;
                            }

                            const liContent = `
                                <span class="truncate ${user.id === userId ? 'font-bold text-indigo-300' : ''}">${user.nickname} ${user.id === userId ? '(You)' : ''}</span>
                                <div>
                                    ${roleBadge}
                                    ${permissionButtonsHTML}
                                </div>
                            `;

                            if (li) {

                                if (li.innerHTML.trim() !== liContent.trim()) {
                                     li.innerHTML = liContent;
                                }
                            } else {

                                li = document.createElement('li');
                                li.dataset.uid = user.id;
                                li.innerHTML = liContent;
                                usersList.appendChild(li);
                            }
                        });


                        usersList.querySelectorAll('li[data-uid]').forEach(li => {
                            if (!activeUserIds.has(li.dataset.uid)) {
                                li.remove();
                            }
                        });


                    }

                    async function changeUserRole(uid, newRole) {
                        if (!isBoardOwner) return;
                        try {
                            const userRef = doc(usersCol, uid);
                            await updateDoc(userRef, { role: newRole });
                        } catch (e) {
                            console.error("Error changing user role:", e);
                        }
                    }

            async function kickUser(uid) {
                if (!isBoardOwner || !uid) return;
                try {
                    const userRef = doc(usersCol, uid);
                    await updateDoc(userRef, {
                        kicked: true,
                        nickname: "[Kicked User]",
                        last_seen: serverTimestamp()
                    });
                    console.log(`User ${uid} marked as kicked.`);
                } catch (e) {
                    console.error("Error kicking user:", e);
                }
            }

                    cancelKickBtn.addEventListener('click', () => {
                        kickConfirmModalOverlay.style.display = 'none';
                        pendingKickUid = null;
                    });

                    confirmKickBtn.addEventListener('click', () => {
                        kickUser(pendingKickUid);
                        kickConfirmModalOverlay.style.display = 'none';
                        pendingKickUid = null;
                    });

                    showUsersBtn.addEventListener('click', () => usersModalOverlay.style.display = 'flex');
                    closeUsersModalBtn.addEventListener('click', () => usersModalOverlay.style.display = 'none');
                    usersModalOverlay.addEventListener('click', (e) => {
                        if (e.target === usersModalOverlay) {
                            usersModalOverlay.style.display = 'none';
                        }
                    });

                    usersList.addEventListener('click', async (e) => {
                        const btn = e.target.closest('.permission-btn');
                        if (!btn || !isBoardOwner) return;

                        const uidToChange = btn.dataset.uid;
                        if (btn.classList.contains('kick')) {
                            const nickToKick = btn.dataset.nickname;
                            pendingKickUid = uidToChange;
                            kickUserName.textContent = nickToKick;
                            kickConfirmModalOverlay.style.display = 'flex';
                        } else if (btn.classList.contains('promote')) {
                            await changeUserRole(uidToChange, 'editor');
                        } else if (btn.classList.contains('demote')) {
                            await changeUserRole(uidToChange, 'viewer');
                        }
                    });

                    inviteBtn.addEventListener('click', () => {
                       inviteLinkDisplay.style.display = 'none';
                       inviteLinkInput.value = '';

                       const userView = document.getElementById('invite-modal-user-view');
                       const ownerView = document.getElementById('invite-modal-owner-view');

                       if (isBoardOwner) {
                           userView.style.display = 'none';
                           ownerView.style.display = 'block';
                       } else {
                           userView.style.display = 'block';
                           ownerView.style.display = 'none';
                       }

                       inviteModalOverlay.style.display = 'flex';
                   });

                   closeInviteModalBtn.addEventListener('click', () => {
                        inviteModalOverlay.style.display = 'none';
                    });


                    inviteModalOverlay.addEventListener('click', (e) => {
                        if (e.target === inviteModalOverlay) {
                            inviteModalOverlay.style.display = 'none';
                        }
                    });


                    async function generateInviteLink(type) {
                        const baseUrl = window.location.origin + window.location.pathname;
                        let link = '';

                        if (type === 'viewer') {
                            link = `https://morsethecode.github.io/board/?board=${currentBoardId}`;
                            inviteLinkInput.value = link;
                            inviteLinkDisplay.style.display = 'block';
                        } else if (type === 'editor' && isBoardOwner) {
                            ownerGenerateEditorLinkBtn.disabled = true;
                            ownerGenerateEditorLinkBtn.textContent = 'Generating...';
                            try {
                                const inviteId = crypto.randomUUID();
                                const inviteRef = doc(invitesCol, inviteId);
                                await setDoc(inviteRef, {
                                    type: 'editor',
                                    createdAt: serverTimestamp()
                                });
                                link = `https://morsethecode.github.io/board/?board=${currentBoardId}&invite=${inviteId}`;
                                inviteLinkInput.value = link;
                                inviteLinkDisplay.style.display = 'block';
                            } catch (e) {
                                console.error("Error generating editor invite:", e);
                                inviteLinkInput.value = 'Error generating link.';
                            } finally {
                                ownerGenerateEditorLinkBtn.disabled = false;
                                ownerGenerateEditorLinkBtn.innerHTML = 'Generate Editor Link<br><span class="text-xs font-normal">(Single-Use, Edit Access)</span>';
                            }
                        }
                    }

                    generateViewerLinkBtn.addEventListener('click', () => generateInviteLink('viewer'));
                    ownerGenerateViewerLinkBtn.addEventListener('click', () => generateInviteLink('viewer'));
                    ownerGenerateEditorLinkBtn.addEventListener('click', () => generateInviteLink('editor'));

                    copyInviteLinkBtn.addEventListener('click', () => {
                        inviteLinkInput.select();
                        document.execCommand('copy');
                        copyInviteLinkBtn.textContent = 'Copied!';
                        setTimeout(() => {
                            copyInviteLinkBtn.textContent = 'Copy';
                        }, 1500);
                    });

                    invalidInviteOkBtn.addEventListener('click', () => {
                        invalidInviteModalOverlay.style.display = 'none';
                    });

                    function renderItem(id, data) {
                        if (items.has(id)) return;

                        const itemEl = document.createElement('div');
                        itemEl.id = id;
                        itemEl.className = 'item';
                        itemEl.style.left = data.x;
                        itemEl.style.top = data.y;
                        itemEl.style.width = data.width;
                        itemEl.style.height = data.height;
                        itemEl.style.zIndex = data.zIndex;

                        zIndexCounter = Math.max(zIndexCounter, parseInt(data.zIndex) || 10);
                        let contentHtml = '';

                        if (data.type === 'note') {
                            itemEl.classList.add('bg-yellow-100', 'text-black', 'item-note');
                            contentHtml = `
                                <div class="move-handle-note" title="Drag"></div>
                                <textarea class="flex-grow" readonly style="font-family: ${data.fontFamily || "'Brush Script MT', cursive"}; font-size: ${data.fontSize || '16px'};">${data.content || 'Write your note...'}</textarea>
                                <div class="resize-handle-note" title="Resize Note"></div>
                                <div class="edit-btn" title="Edit Note">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                                </div>
                                <div class="delete-btn" title="Delete">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                                </div>
                            `;
                        } else if (data.type === 'image') {
                            itemEl.classList.add('item-image');
                            itemEl.dataset.aspectRatio = data.aspectRatio;
                            contentHtml = `
                                <div class="image-wrapper ${data.captionVisible ? '' : 'no-caption'}">
                                    <img src="${data.content}" class="w-full h-auto object-cover pointer-events-none" />
                                </div>
                                <div class="caption p-3 pt-1 ${data.caption === 'Click to add caption...' ? 'text-gray-500' : ''}" contenteditable="true" style="display: ${data.captionVisible ? 'block' : 'none'}; font-family: ${data.fontFamily || "'Brush Script MT', cursive"}; font-size: ${data.fontSize || '14px'};">${data.caption || 'Click to add caption...'}</div>
                                <div class="resize-handle-image" title="Resize Image"></div>
                                <div class="edit-btn" title="Add/Edit Caption" style="right: 22px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                                </div>
                                <div class="delete-btn" title="Delete">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                                </div>
                            `;
                        } else if (data.type === 'node') {
                            itemEl.classList.add('item-node');
                            itemEl.dataset.type = 'node';
                            itemEl.style.minWidth = '0';
                            itemEl.style.minHeight = '0';
                            contentHtml = ``;
                        } else if (data.type === 'timeline') {
                            itemEl.classList.add('item-timeline');
                            itemEl.dataset.type = 'timeline';

                            const timelineModeClass = data.mode === 'vertical' ? 'timeline-vertical' : 'timeline-horizontal';
                            
                            contentHtml = `
                                <div class="timeline-svg-container" style="width: 100%; height: 100%; overflow: hidden; border-radius: 16px;">
                                    <svg class="timeline-svg ${timelineModeClass}" preserveAspectRatio="none"></svg>
                                </div>

                                <div class="resize-handle-image" title="Resize Timeline"></div>
                                <div class="edit-btn" title="Configure Timeline" style="right: 22px;">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                                </div>
                                <div class="delete-btn" title="Delete">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                                </div>
                            `;
                        }

                        itemEl.innerHTML = contentHtml;
                        canvasContainer.appendChild(itemEl);
                        items.set(id, { el: itemEl, data: data });

                        if (data.type === 'timeline') {
                            renderTimelineSVG(itemEl.querySelector('svg'), itemEl, data);
                        } else if (data.type === 'node') {
                            const counterScale = 1 / scale;
                            itemEl.style.transform = `scale(${counterScale})`;
                        }

                        setupItemEventListeners(itemEl, data.type);

                        updateAllConnectionsForItem(id);
                    }

                    function removeItemLocally(id) {
                        if (animationFrameMap.has(id)) {
                            cancelAnimationFrame(animationFrameMap.get(id));
                            animationFrameMap.delete(id);
                        }
                        const item = items.get(id);
                        if (item) {
                            item.el.remove();
                            items.delete(id);
                        }
                        if (selectedItems.has(id)) {
                            selectedItems.delete(id);
                        }
                        itemConnectionsMap.delete(id);
                    }

                    function renderConnection(id, data) {
                        if (connections.some(c => c.id === id)) return;

                        const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        lineEl.setAttribute('class', 'connector-line');

                        const hitBoxEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        hitBoxEl.setAttribute('style', 'fill:none; stroke:transparent; stroke-width:20px; vector-effect: non-scaling-stroke; cursor: pointer;');

                        const connection = {
                            id: id,
                            startId: data.startId,
                            endId: data.endId,
                            lineEl,
                            hitBoxEl,
                            type: data.type,
                            color: data.color,
                            thickness: data.thickness,
                            arrowHead: null
                        };

                        hitBoxEl.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            if (!canEdit) return;
                            lineClickPos = { x: e.clientX, y: e.clientY };
                            openLineConfigPanel(connection);
                        });

                        hitBoxEl.addEventListener('mousedown', (e) => {
                            if (e.button !== 0) return;
                            if (cursorMode === 'move' || cursorMode === 'select') {
                                e.preventDefault();
                                e.stopPropagation();
                                toggleLineSelection(connection, e);
                            }
                        });

                        connections.push(connection);
                        svgLayerConnections.appendChild(lineEl);
                        svgLayerConnections.appendChild(hitBoxEl);

                        if (!itemConnectionsMap.has(data.startId)) itemConnectionsMap.set(data.startId, new Set());
                        itemConnectionsMap.get(data.startId).add(id);
                        if (!itemConnectionsMap.has(data.endId)) itemConnectionsMap.set(data.endId, new Set());
                        itemConnectionsMap.get(data.endId).add(id);

                        updateConnectionLine(connection);
                    }

                    function removeConnectionLocally(id) {
                        const index = connections.findIndex(c => c.id === id);
                        if (index > -1) {
                            const conn = connections[index];

                            if (itemConnectionsMap.has(conn.startId)) {
                                itemConnectionsMap.get(conn.startId).delete(id);
                            }
                            if (itemConnectionsMap.has(conn.endId)) {
                                itemConnectionsMap.get(conn.endId).delete(id);
                            }

                            conn.lineEl.remove();
                            conn.hitBoxEl.remove();
                            if (conn.arrowHead) conn.arrowHead.remove();
                            connections.splice(index, 1);
                        }
                    }

                    async function mergePath(tempPath) {
                        if (!canEdit) return;
                        if (!tempPath) return;

                        let stroke = tempPath.getAttribute('stroke');
                        const strokeWidth = tempPath.getAttribute('stroke-width');
                        const d = tempPath.getAttribute('d');

                        if (!d || d.length < 2) {
                            tempPath.remove();
                            return;
                        }

                        try {
                            await addDoc(drawingsCol, {
                                d: d,
                                stroke: stroke,
                                strokeWidth: strokeWidth,
                                createdAt: serverTimestamp()
                            });
                        } catch (e) {
                            console.error("Error saving drawing: ", e);
                        }

                        tempPath.remove();
                    }

                    function midPoint(p1, p2) {
                        return {
                            x: (p1.x + p2.x) / 2,
                            y: (p1.y + p2.y) / 2
                        };
                    }

                    function updateEraserCursorSize() {
                        if (drawTool === 'eraser' && cursorMode === 'draw') {
                            const size = parseFloat(eraserSizeSlider.value) * scale;
                            eraserCursor.style.width = `${size}px`;
                            eraserCursor.style.height = `${size}px`;
                        }
                    }

                    function updatePencilCursor() {
                        if (drawTool === 'pencil' && cursorMode === 'draw') {
                            const size = parseFloat(drawThicknessInput.value) * scale;
                            pencilCursor.style.width = `${size}px`;
                            pencilCursor.style.height = `${size}px`;
                            pencilCursor.style.backgroundColor = drawColorInput.value;
                        }
                    }

                    eraserSizeSlider.addEventListener('input', updateEraserCursorSize);
                    drawThicknessInput.addEventListener('input', updatePencilCursor);
                    drawColorInput.addEventListener('input', updatePencilCursor);

                    fontSizeSlider.addEventListener('input', async (e) => {
                        if (!canEdit || !currentItemForMenu) return;

                        const newSize = e.target.value + 'px';
                        const itemRef = doc(itemsCol, currentItemForMenu.id);

                        try {
                            if (currentItemForMenu.classList.contains('item-image')) {
                                await updateDoc(itemRef, { fontSize: newSize });
                            } else if (currentItemForMenu.classList.contains('item-note')) {
                                await updateDoc(itemRef, { fontSize: newSize });
                            }
                        } catch (e) {
                            console.error("Error updating font size:", e);
                        }
                    });
                    fontSizeSlider.addEventListener('mousedown', (e) => e.stopPropagation());
                    
                    function updateNodeScaling() {
                        const nodes = document.querySelectorAll('.item-node');
                        const counterScale = 1 / scale;
                        nodes.forEach(node => {
                            node.style.transform = `scale(${counterScale})`;
                        });
                    }

                    function updateTransform() {
                        canvasContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                    }

                    const SVG_ORIGIN_X = 10000;
                    const SVG_ORIGIN_Y = 10000;

                    function worldToSvg(worldPos) {
                        return {
                            x: worldPos.x + SVG_ORIGIN_X,
                            y: worldPos.y + SVG_ORIGIN_Y
                        };
                    }

                    function screenToWorld(x, y) {
                        const boardRect = board.getBoundingClientRect();
                        const screenX = x - boardRect.left;
                        const screenY = y - boardRect.top;
                        return {
                            x: (screenX - translateX) / scale,
                            y: (screenY - translateY) / scale
                        };
                    }

                    function worldToScreen(x, y) {
                        const boardRect = board.getBoundingClientRect();
                        const screenX = (x * scale) + translateX + boardRect.left;
                        const screenY = (y * scale) + translateY + boardRect.top;
                        return {
                            x: screenX,
                            y: screenY
                        };
                    }

                    function updateSelectionVisuals() {
                        items.forEach(item => {
                            item.el.classList.toggle('selected', selectedItems.has(item.el.id));
                        });
                        connections.forEach(conn => {
                            conn.lineEl.classList.toggle('selected-line', selectedLines.has(conn.id));
                        });
                    }

                    function closeAllPopups() {
                        hideLineControlPanel();
                        hideItemMenu();
                        boardMenu.style.display = 'none';
                        drawControls.style.display = 'none';
                        toggleDrawControlsBtn.classList.remove('active');
                    }

                    function clearSelection() {
                        selectedItems.clear();
                        selectedLines.clear();
                        updateSelectionVisuals();
                        selectedLine = null;
                    }

                    async function selectItem(element, e) {
                        const ctrlPressed = e && e.ctrlKey;

                        if (!ctrlPressed) {
                            clearSelection();
                        }

                        if (ctrlPressed) {
                            if (selectedItems.has(element.id)) {
                                selectedItems.delete(element.id);
                            } else {
                                selectedItems.set(element.id, element);
                            }
                        } else {
                            selectedItems.set(element.id, element);
                        }

                        if (canEdit) {
                            const newZIndex = ++zIndexCounter;
                            element.style.zIndex = newZIndex;

                            try {
                                const itemRef = doc(itemsCol, element.id);
                                await updateDoc(itemRef, { zIndex: newZIndex });
                            } catch (e) {
                                console.error("Error updating z-index:", e);
                            }
                        }

                        updateSelectionVisuals();
                    }

                    function toggleLineSelection(lineData, e) {
                        const ctrlPressed = e && e.ctrlKey;

                        if (!ctrlPressed) {
                            clearSelection();
                        }

                        if (ctrlPressed) {
                            if (selectedLines.has(lineData.id)) {
                                selectedLines.delete(lineData.id);
                            } else {
                                selectedLines.set(lineData.id, lineData);
                            }
                        } else {
                            selectedLines.set(lineData.id, lineData);
                        }

                        updateSelectionVisuals();
                    }

                    function openLineConfigPanel(lineData) {
                        if (!canEdit) return;
                        clearSelection();
                        hideItemMenu();
                        boardMenu.style.display = 'none';
                        drawControls.style.display = 'none';
                        toggleDrawControlsBtn.classList.remove('active');

                        lineData.lineEl.classList.add('selected-line');
                        selectedLines.set(lineData.id, lineData);
                        selectedLine = lineData;
                        showLineControlPanel(lineData);
                    }

                    function showItemMenu(itemEl, e) {
                        closeAllPopups();
                        currentItemForMenu = itemEl;
                        const boardRect = board.getBoundingClientRect();

                        itemMenu.style.display = 'flex';
                        const menuWidth = 190;
                        let menuLeft = e.clientX - boardRect.left;

                        if (menuLeft + menuWidth > board.offsetWidth) {
                            menuLeft = board.offsetWidth - menuWidth - 10;
                        }
                        menuLeft = Math.max(10, menuLeft);

                        let menuTop = e.clientY - boardRect.top;
                        const menuHeight = itemMenu.offsetHeight;
                        const boardHeight = board.offsetHeight;

                        if (menuTop + menuHeight > boardHeight) {
                            menuTop = boardHeight - menuHeight - 10;
                        }
                        menuTop = Math.max(10, menuTop);

                        itemMenu.style.left = `${menuLeft}px`;
                        itemMenu.style.top = `${menuTop}px`;

                        const fontSizeContainer = document.getElementById('font-size-container');

                        const isImage = itemEl.classList.contains('item-image');
                        const isNote = itemEl.classList.contains('item-note');
                        const isNode = itemEl.classList.contains('item-node');
                        const isTimeline = itemEl.classList.contains('item-timeline');
                        const captionEl = itemEl.querySelector('.caption');

                        const showFontControls = isNote || (isImage && captionEl && captionEl.style.display !== 'none');

                        if (canEdit) {
                            itemMenuFontBtn.style.display = showFontControls ? 'flex' : 'none';
                            fontSizeContainer.style.display = showFontControls ? 'block' : 'none';
                            itemMenuConnectBtn.style.display = (isNode || isNote || isImage || isTimeline) ? 'flex' : 'none';
                            itemMenuDeleteNodeBtn.style.display = isNode ? 'flex' : 'none';
                            itemMenuBringFrontBtn.style.display = 'flex';
                            itemMenuSendBackBtn.style.display = 'flex';

                            if (showFontControls) {
                                const el = isNote ? itemEl.querySelector('textarea') : itemEl.querySelector('.caption');
                                const currentSize = window.getComputedStyle(el).fontSize;
                                document.getElementById('item-menu-font-size').value = parseFloat(currentSize) || 14;
                            }
                        } else {
                            itemMenuFontBtn.style.display = 'none';
                            fontSizeContainer.style.display = 'none';
                            itemMenuConnectBtn.style.display = 'none';
                            itemMenuDeleteNodeBtn.style.display = 'none';
                            itemMenuBringFrontBtn.style.display = 'none';
                            itemMenuSendBackBtn.style.display = 'none';
                        }

                        connectionSubmenu.style.display = 'none';
                        fontSubmenu.style.display = 'none';
                    }

                    function showBoardMenu(e) {
                        closeAllPopups();
                        const boardRect = board.getBoundingClientRect();
                        boardMenu.style.display = 'flex';

                        let menuTop = e.clientY - boardRect.top;
                        const menuHeight = boardMenu.offsetHeight;
                        const boardHeight = board.offsetHeight;

                        if (menuTop + menuHeight > boardHeight) {
                            menuTop = boardHeight - menuHeight - 10;
                        }
                        menuTop = Math.max(10, menuTop);

                        let menuLeft = e.clientX - boardRect.left;
                        const menuWidth = boardMenu.offsetWidth;
                        const boardWidth = board.offsetWidth;

                        if (menuLeft + menuWidth > boardWidth) {
                            menuLeft = boardWidth - menuWidth - 10;
                        }
                        menuLeft = Math.max(10, menuLeft);

                        boardMenu.style.left = `${menuLeft}px`;
                        boardMenu.style.top = `${menuTop}px`;

                        lastMousePos.x = menuLeft + boardRect.left;
                        lastMousePos.y = menuTop + boardRect.top;
                    }

                    function hideItemMenu() {
                        if (itemMenu) itemMenu.style.display = 'none';
                        if (connectionSubmenu) connectionSubmenu.style.display = 'none';
                        if (fontSubmenu) fontSubmenu.style.display = 'none';
                        currentItemForMenu = null;
                    }

                    function setCursorMode(mode) {
                        if (!canEdit && mode === 'draw') mode = 'move';

                        cursorMode = mode;

                        eraserCursor.style.display = 'none';
                        pencilCursor.style.display = 'none';
                        board.classList.remove('eraser-active');
                        board.classList.remove('pencil-active');

                        modeMoveBtn.classList.toggle('active', mode === 'move');
                        modeSelectBtn.classList.toggle('active', mode === 'select');
                        modeDrawBtn.classList.toggle('active', mode === 'draw');

                        toggleDrawControlsBtn.style.display = (mode === 'draw') ? 'block' : 'none';
                        if (mode !== 'draw') {
                            drawControls.style.display = 'none';
                            toggleDrawControlsBtn.classList.remove('active');
                        }

                        if (mode === 'move') {
                            board.style.cursor = 'grab';
                        } else if (mode === 'select') {
                            board.style.cursor = 'default';
                        } else if (mode === 'draw') {
                            setDrawTool(drawTool);
                        }

                        svgLayerDrawings.style.pointerEvents = (mode === 'draw' && canEdit) ? 'auto' : 'none';
                    }

                    modeMoveBtn.addEventListener('click', () => setCursorMode('move'));
                    modeSelectBtn.addEventListener('click', () => setCursorMode('select'));
                    modeDrawBtn.addEventListener('click', () => {
                        if (!canEdit) return;
                        setCursorMode('draw');

                    });

                    toggleSnapGridBtn.addEventListener('click', () => {
                        snapToGrid = !snapToGrid;
                        toggleSnapGridBtn.classList.toggle('active', snapToGrid);
                    });

                    toggleDrawControlsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isActive = toggleDrawControlsBtn.classList.toggle('active');
                        drawControls.style.display = isActive ? 'flex' : 'none';
                    });

                    drawControls.addEventListener('mousedown', (e) => e.stopPropagation());

                    function setDrawTool(tool) {
                        drawTool = tool;
                        drawToolPencilBtn.classList.toggle('active', tool === 'pencil');
                        drawToolEraserBtn.classList.toggle('active', tool === 'eraser');

                        if (tool === 'pencil') {
                            modeDrawBtn.innerHTML = PENCIL_ICON_SVG;
                            modeDrawBtn.title = 'Draw (Pencil)';
                            drawThicknessContainer.style.display = 'block';
                            eraserSizeContainer.style.display = 'none';
                            drawColorContainer.style.display = 'block';

                            board.style.cursor = 'none';
                            board.classList.add('pencil-active');
                            board.classList.remove('eraser-active');
                            pencilCursor.style.display = 'block';
                            eraserCursor.style.display = 'none';
                            updatePencilCursor();

                        } else {
                            modeDrawBtn.innerHTML = ERASER_ICON_SVG;
                            modeDrawBtn.title = 'Draw (Eraser)';
                            drawThicknessContainer.style.display = 'none';
                            eraserSizeContainer.style.display = 'block';
                            drawColorContainer.style.display = 'none';

                            board.style.cursor = 'none';
                            board.classList.add('eraser-active');
                            board.classList.remove('pencil-active');
                            eraserCursor.style.display = 'block';
                            pencilCursor.style.display = 'none';
                            updateEraserCursorSize();
                        }
                    }

                    drawToolPencilBtn.addEventListener('click', () => setDrawTool('pencil'));
                    drawToolEraserBtn.addEventListener('click', () => setDrawTool('eraser'));

                    linePanelHandle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        isDraggingPanel = true;
                        const panelRect = lineControlPanel.getBoundingClientRect();
                        panelStartPos.x = e.clientX - panelRect.left;
                        panelStartPos.y = e.clientY - panelRect.top;

                        linePanelHandle.style.cursor = 'grabbing';

                        document.addEventListener('mousemove', onPanelMouseMove);
                        document.addEventListener('mouseup', onPanelMouseUp);
                    });

                    function onPanelMouseMove(e) {
                        if (!isDraggingPanel) return;
                        e.preventDefault();

                        const boardRect = board.getBoundingClientRect();
                        let newX = (e.clientX - panelStartPos.x) - boardRect.left;
                        let newY = (e.clientY - panelStartPos.y) - boardRect.top;

                        newX = Math.max(10, Math.min(newX, board.offsetWidth - lineControlPanel.offsetWidth - 10));
                        newY = Math.max(10, Math.min(newY, board.offsetHeight - lineControlPanel.offsetHeight - 10));

                        lineControlPanel.style.left = `${newX}px`;
                        lineControlPanel.style.top = `${newY}px`;
                    }

                    function onPanelMouseUp(e) {
                        isDraggingPanel = false;
                        linePanelHandle.style.cursor = 'grab';
                        document.removeEventListener('mousemove', onPanelMouseMove);
                        document.removeEventListener('mouseup', onPanelMouseUp);
                    }

                    board.addEventListener('contextmenu', (e) => {
                        e.preventDefault();

                        if (!canEdit) {
                            return;
                        }

                        const target = e.target;
                        const isControl = target.classList.contains('delete-btn') ||
                                          target.closest('.delete-btn') ||
                                          target.classList.contains('edit-btn') ||
                                          target.closest('.edit-btn') ||
                                          target.classList.contains('resize-handle-note') ||
                                          target.closest('.resize-handle-note') ||
                                          target.classList.contains('resize-handle-image') ||
                                          target.closest('.resize-handle-image') ||
                                          target.classList.contains('move-handle-note') ||
                                          target.closest('.move-handle-note');

                        if (isControl) {
                            return;
                        }

                        lastMousePos = { x: e.clientX, y: e.clientY };
                        const isBoardClick = e.target === board || e.target === canvasContainer || e.target === svgLayerConnections || e.target.closest('#svg-layer-drawings');

                        if (isBoardClick) {
                            showBoardMenu(e);
                        } else {
                            const itemEl = e.target.closest('.item');
                            if(itemEl) {
                                e.stopPropagation();
                                showItemMenu(itemEl, e);
                            } else {
                                closeAllPopups();
                            }
                        }
                    });

                    board.addEventListener('mousedown', (e) => {
                        closeAllPopups();

                        const isBoardClick = e.target === board || e.target === canvasContainer || e.target === svgLayerConnections || e.target.closest('#svg-layer-drawings');

                        if (cursorMode === 'draw' && !isBoardClick) {
                            const itemEl = e.target.closest('.item');
                            if (itemEl) {
                                e.stopPropagation();
                                selectItem(itemEl, e);
                                onItemDragStart(e, itemEl);
                                return;
                            }
                        }

                        if (!isBoardClick) return;

                        startPos.x = e.clientX;
                        startPos.y = e.clientY;

                        if (!e.ctrlKey) {
                            clearSelection();
                        }

                        if (cursorMode === 'move') {
                            isPanning = true;
                            startPos.x = e.clientX - translateX;
                            startPos.y = e.clientY - translateY;
                            board.style.cursor = 'grabbing';
                        }
                        else if (cursorMode === 'select') {
                            isSelecting = true;
                            selectionBox.style.display = 'block';

                            const boardRect = board.getBoundingClientRect();
                            const selBoxStartX = e.clientX - boardRect.left;
                            const selBoxStartY = e.clientY - boardRect.top;

                            selectionBox.style.left = `${selBoxStartX}px`;
                            selectionBox.style.top = `${selBoxStartY}px`;
                            selectionBox.style.width = '0px';
                            selectionBox.style.height = '0px';
                        }
                        else if (cursorMode === 'draw') {
                            if (!canEdit) return;
                            isDrawingFreehand = true;
                            const worldPos = screenToWorld(e.clientX, e.clientY);
                            const svgPos = worldToSvg(worldPos);

                            currentFreehandPoints = [svgPos];
                            currentFreehandPathString = `M${svgPos.x} ${svgPos.y}`;

                            currentFreehandPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            currentFreehandPath.setAttribute('class', 'temp-drawing-path');
                            currentFreehandPath.setAttribute('d', currentFreehandPathString);
                            currentFreehandPath.setAttribute('vector-effect', 'non-scaling-stroke');
                            currentFreehandPath.setAttribute('fill', 'none');
                            currentFreehandPath.setAttribute('stroke-linecap', 'round');
                            currentFreehandPath.setAttribute('stroke-linejoin', 'round');

                            if (drawTool === 'pencil') {
                                currentFreehandPath.setAttribute('stroke', drawColorInput.value);
                                currentFreehandPath.setAttribute('stroke-width', drawThicknessInput.value);
                            } else {
                                currentFreehandPath.setAttribute('stroke', 'url(#dot-grid)');
                                currentFreehandPath.setAttribute('stroke-width', eraserSizeSlider.value);
                            }

                            tempDrawingGroup.appendChild(currentFreehandPath);
                        }

                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    });

                    board.addEventListener('mousemove', (e) => {


                        lastMousePos = { x: e.clientX, y: e.clientY };
                    });

                    board.addEventListener('wheel', (e) => {
                        e.preventDefault();

                        const boardRect = board.getBoundingClientRect();
                        const mouseX = e.clientX - boardRect.left;
                        const mouseY = e.clientY - boardRect.top;

                        const mouseWorldX_before = (mouseX - translateX) / scale;
                        const mouseWorldY_before = (mouseY - translateY) / scale;

                        const scaleFactor = (e.deltaY > 0) ? 0.9 : 1.1;
                        let newScale = scale * scaleFactor;
                        scale = Math.max(0.1, Math.min(newScale, 3.0));

                        translateX = mouseX - mouseWorldX_before * scale;
                        translateY = mouseY - mouseWorldY_before * scale;

                        updateTransform();
                        updateNodeScaling();
                        updateEraserCursorSize();
                        updatePencilCursor();

                    });

                    board.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'copy';
                    });

                    board.addEventListener('drop', (e) => {
                        e.preventDefault();
                        closeAllPopups();
                        if (!canEdit) return;

                        if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                            const file = e.dataTransfer.files[0];
                            if (file.type.startsWith('image/')) {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    createItem('image', event.target.result, e.clientX, e.clientY);
                                };
                                reader.readAsDataURL(file);
                                return;
                            }
                        }
                    });

                    board.addEventListener('mouseenter', () => {

                    });
                    board.addEventListener('mouseleave', (e) => {

                    });

                    document.addEventListener('keydown', async (e) => {
                        if (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable || document.activeElement.tagName === 'INPUT') {
                            return;
                        }
                        if (!canEdit) return;

                        if (e.key === 'Delete' || e.key === 'Backspace') {

                            const itemsToDelete = Array.from(selectedItems.keys());
                            for (const id of itemsToDelete) {
                                await deleteItem(id, true);
                            }
                            selectedItems.clear();

                            if (selectedLines.size > 0) {
                                const lineBatch = writeBatch(db);
                                selectedLines.forEach((line, id) => {
                                    lineBatch.delete(doc(connectionsCol, id));
                                });
                                selectedLines.clear();
                                await lineBatch.commit().catch(e => console.error("Error deleting selected lines:", e));
                            }
                        }
                    });

                    document.addEventListener('paste', onPaste);

                    async function onPaste(e) {
                        if (document.activeElement.tagName === 'TEXTAREA' ||
                            document.activeElement.isContentEditable ||
                            document.activeElement.tagName === 'INPUT') {
                            return;
                        }

                        e.preventDefault();
                        closeAllPopups();
                        if (!canEdit) return;

                        if (e.clipboardData && e.clipboardData.files && e.clipboardData.files.length > 0) {
                            const imageFile = Array.from(e.clipboardData.files).find(f => f.type.startsWith('image/'));
                            if (imageFile) {
                                const reader = new FileReader();
                                reader.onload = (event) => {
                                    createItem('image', event.target.result, lastMousePos.x, lastMousePos.y);
                                };
                                reader.readAsDataURL(imageFile);
                                return;
                            }
                        }

                        await handlePasteLegacy();
                    }

                    async function handlePasteLegacy() {
                        if (!canEdit) return;
                        try {
                            const clipboardItems = await navigator.clipboard.read();

                            for (const item of clipboardItems) {
                                const imageType = item.types.find(type => type.startsWith('image/'));
                                if (imageType) {
                                    const blob = await item.getType(imageType);
                                    const reader = new FileReader();
                                    reader.onload = (event) => {
                                        createItem('image', event.target.result, lastMousePos.x, lastMousePos.y);
                                    };
                                    reader.readAsDataURL(blob);
                                    return;
                                }

                                if (item.types.includes('text/plain')) {
                                    const blob = await item.getType('text/plain');
                                    const text = await blob.text();
                                    if (text) {
                                        createItem('note', text, lastMousePos.x, lastMousePos.y);
                                    }
                                    return;
                                }
                            }
                        } catch (err) {
                            console.error('Failed to read clipboard contents: ', err);
                        }
                    }

                    async function createItem(type, content = '', x = 50, y = 50) {
                        if (!canEdit) return null;

                        const boardRect = board.getBoundingClientRect();
                        const viewMin = screenToWorld(boardRect.left, boardRect.top);
                        const viewMax = screenToWorld(boardRect.right, boardRect.bottom);
                        const worldPos = screenToWorld(x, y);

                        let itemWidth = 200;
                        let itemHeight = 150;

                        if (type === 'image') {
                            itemWidth = 250;
                            itemHeight = 200;
                        } else if (type === 'node') {
                            itemWidth = 20;
                            itemHeight = 20;
                        }

                        let finalX = worldPos.x - (itemWidth / 2);
                        let finalY = worldPos.y - (itemHeight / 2);

                        finalX = Math.max(viewMin.x + 5, Math.min(finalX, viewMax.x - itemWidth - 5));
                        finalY = Math.max(viewMin.y + 5, Math.min(finalY, viewMax.y - itemHeight - 5));

                        const itemData = {
                            type: type,
                            x: `${finalX}px`,
                            y: `${finalY}px`,
                            zIndex: ++zIndexCounter,
                        };

                        if (type === 'note') {
                            itemData.width = '200px';
                            itemData.height = '150px';
                            itemData.content = content || 'Write your note...';
                            itemData.fontFamily = "'Brush Script MT', cursive";
                            itemData.fontSize = '16px';
                        } else if (type === 'image') {
                            itemData.width = '250px';
                            itemData.height = 'auto';
                            itemData.content = content;
                            itemData.caption = 'Click to add caption...';
                            itemData.captionVisible = false;
                            itemData.fontFamily = "'Brush Script MT', cursive";
                            itemData.fontSize = '14px';

                            const img = new Image();
                            img.onload = () => {
                                itemData.aspectRatio = img.naturalHeight / img.naturalWidth;
                                addDoc(itemsCol, itemData).catch(e => console.error("Error creating item: ", e));
                            };
                            img.src = content;
                            return;
                        } else if (type === 'node') {
                            itemData.width = '20px';
                            itemData.height = '20px';
                        } else if (type === 'timeline') {
                            itemWidth = 400;
                            itemHeight = 200;
                            finalX = worldPos.x - (itemWidth / 2);
                            finalY = worldPos.y - (itemHeight / 2);
                            
                            itemData.x = `${finalX}px`;
                            itemData.y = `${finalY}px`;
                            itemData.width = `${itemWidth}px`;
                            itemData.height = `${itemHeight}px`;
                            itemData.mainColor = "#3b82f6";
                            itemData.mode = "horizontal";
                            itemData.direction = "l-r";
                            itemData.events = [];
                        }

                        try {
                            const docRef = await addDoc(itemsCol, itemData);
                            return docRef.id;
                        } catch (e) {
                            console.error("Error creating item: ", e);
                            return null;
                        }
                    }

                    async function setupItemEventListeners(itemEl, type) {

                        itemEl.addEventListener('mousedown', (e) => {
                            if (e.button !== 0) return;
                            closeAllPopups();

                            const target = e.target;
                            const isTextarea = target.tagName === 'TEXTAREA';
                            const isEditable = (isTextarea && !target.readOnly) || target.isContentEditable;

                            const isControl = target.classList.contains('move-handle-note') ||
                                              target.classList.contains('delete-btn') ||
                                              target.closest('.delete-btn') ||
                                              target.classList.contains('edit-btn') ||
                                              target.closest('.edit-btn') ||
                                              target.classList.contains('resize-handle-note') ||
                                              target.closest('.resize-handle-note') ||
                                              target.classList.contains('resize-handle-image') ||
                                              target.closest('.resize-handle-image');

                            if (itemEl.classList.contains('item-timeline') && target.closest('.timeline-svg-container')) {
                                e.stopPropagation();
                                return;
                            }

                            if ((isEditable || isControl) && canEdit) {
                                if (isEditable) {
                                    target.focus();
                                }
                                e.stopPropagation();
                                return;
                            }

                            selectItem(itemEl, e);
                            e.stopPropagation();

                            if (cursorMode === 'move' || (cursorMode === 'draw' && canEdit)) {
                                onItemDragStart(e, itemEl);
                            }
                        });

                        itemEl.addEventListener('contextmenu', (e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            if (!canEdit) {
                                return;
                            }

                            const target = e.target;
                            const isControl = target.classList.contains('delete-btn') ||
                                              target.closest('.delete-btn') ||
                                              target.classList.contains('edit-btn') ||
                                              target.closest('.edit-btn') ||
                                              target.classList.contains('resize-handle-note') ||
                                              target.closest('.resize-handle-note') ||
                                              target.classList.contains('resize-handle-image') ||
                                              target.closest('.resize-handle-image') ||
                                              target.classList.contains('move-handle-note') ||
                                              target.closest('.move-handle-note');

                            if (isControl) return;
                            showItemMenu(itemEl, e);
                        });

                        if (type === 'image') {
                            itemEl.querySelector('.resize-handle-image').addEventListener('mousedown', onResizeStart);
                            itemEl.querySelector('.edit-btn').addEventListener('mousedown', (e) => {
                                if (!canEdit || e.button !== 0) return;
                                e.stopPropagation();
                                selectItem(itemEl, e);
                                onToggleCaption(e, itemEl);
                            });

                            const captionEl = itemEl.querySelector('.caption');
                            captionEl.addEventListener('blur', async () => {
                                if (!canEdit) return;
                                const itemRef = doc(itemsCol, itemEl.id);
                                await updateDoc(itemRef, { caption: captionEl.innerHTML });
                            });

                        } else if (type === 'note') {
                            const textarea = itemEl.querySelector('textarea');
                            const editBtn = itemEl.querySelector('.edit-btn');

                            editBtn.addEventListener('mousedown', (e) => {
                                if (!canEdit || e.button !== 0) return;
                                e.stopPropagation();
                                selectItem(itemEl, e);
                                if (textarea.readOnly) {
                                    textarea.readOnly = false;
                                    setTimeout(() => {
                                        textarea.focus();
                                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                                    }, 0);
                                } else {
                                    textarea.readOnly = true;
                                }
                            });

                            textarea.addEventListener('blur', async () => {
                                if (!canEdit) return;
                                textarea.readOnly = true;
                                const itemRef = doc(itemsCol, itemEl.id);
                                await updateDoc(itemRef, { content: textarea.value });
                            });

                            itemEl.querySelector('.resize-handle-note').addEventListener('mousedown', onResizeStart);
                            itemEl.querySelector('.move-handle-note').addEventListener('mousedown', (e) => {
                                if (e.button !== 0) return;
                                closeAllPopups();
                                e.stopPropagation();
                                selectItem(itemEl, e);
                                onItemDragStart(e, itemEl);
                            });
                        } else if (type === 'timeline') {
                            itemEl.querySelector('.resize-handle-image').addEventListener('mousedown', onResizeStart);
                            itemEl.querySelector('.delete-btn').addEventListener('mousedown', onDelete);
                            
                            const editBtn = itemEl.querySelector('.edit-btn');
                            editBtn.addEventListener('mousedown', (e) => {
                                if (!canEdit || e.button !== 0) return;
                                e.stopPropagation();
                                selectItem(itemEl, e);
                                openTimelineConfigModal(itemEl);
                            });
                            
                            const svgContainer = itemEl.querySelector('.timeline-svg-container');
                            
                            svgContainer.addEventListener('mousedown', (e) => {
                                if (e.button !== 0) return;
                                e.stopPropagation();

                                const target = e.target.closest('[data-event-id]') || e.target;
                                const eventId = target.dataset.eventId;
                                
                                if (eventId && canEdit) {
                                    const itemData = items.get(itemEl.id).data;
                                    const event = itemData.events.find(ev => ev.id === eventId);
                                    if (!event) return;

                                    currentTimelineEventData = {
                                        itemEl: itemEl,
                                        itemData: itemData,
                                        event: event,
                                        eventId: eventId,
                                        isAlt: target.dataset.isAlt === 'true',
                                        startPos_world: screenToWorld(e.clientX, e.clientY),
                                        startPosition: event.position || 0.5,
                                        startLineLength: event.lineLength || 40
                                    };

                                    if (target.classList.contains('timeline-event-move-handle')) {
                                        isMovingTimelineEvent = true;
                                    } else if (target.classList.contains('timeline-event-resize-handle')) {
                                        isResizingTimelineEvent = true;
                                    }

                                    document.addEventListener('mousemove', onMouseMove);
                                    document.addEventListener('mouseup', onMouseUp);
                                    
                                } else {
                                    e.stopPropagation();
                                    selectItem(itemEl, e);
                                    if (cursorMode === 'move' || (cursorMode === 'draw' && canEdit)) {
                                        onItemDragStart(e, itemEl);
                                    }
                                    e.stopPropagation();
                                }
                            });

                            svgContainer.addEventListener('contextmenu', (e) => {
                                e.preventDefault();
                                e.stopPropagation();

                                if (!canEdit) {
                                    return;
                                }

                                showItemMenu(itemEl, e);
                            });
                        }

                        if (type !== 'node') {
                            itemEl.querySelector('.delete-btn').addEventListener('mousedown', onDelete);
                        }

                        const captionEl = itemEl.querySelector('.caption');
                        if (captionEl) {
                            captionEl.addEventListener('focus', () => {
                                if (!canEdit) {
                                    captionEl.blur();
                                    return;
                                }
                                if (captionEl.innerHTML === 'Click to add caption...') {
                                    captionEl.innerHTML = '';
                                    captionEl.classList.remove('text-gray-500');
                                }
                            });
                            captionEl.addEventListener('blur', () => {
                                if (captionEl.innerHTML.trim() === '' || captionEl.innerHTML === '<br>') {
                                    captionEl.innerHTML = 'Click to add caption...';
                                    captionEl.classList.add('text-gray-500');
                                }
                            });
                        }
                    }

                    async function onToggleCaption(e, itemEl) {
                        if (!canEdit) return;
                        e.stopPropagation();
                        const targetItem = itemEl || currentItemForMenu;
                        if (!targetItem) return;

                        const captionEl = targetItem.querySelector('.caption');
                        const wrapperEl = targetItem.querySelector('.image-wrapper');
                        let isVisible = false;

                        if (captionEl && wrapperEl) {
                            if (captionEl.style.display === 'none' || captionEl.style.display === '') {
                                isVisible = true;
                                captionEl.focus();
                            }
                        }

                        try {
                            const itemRef = doc(itemsCol, targetItem.id);
                            await updateDoc(itemRef, { captionVisible: isVisible });
                        } catch (err) {
                            console.error("Error toggling caption: ", err);
                        }

                        if (!itemEl) {
                            hideItemMenu();
                        }
                    }

                    boardMenuAddNoteBtn.addEventListener('click', () => {
                        if (!canEdit) return;
                        createItem('note', '', lastMousePos.x, lastMousePos.y);
                        closeAllPopups();
                    });

                    boardMenuAddNodeBtn.addEventListener('click', () => {
                        if (!canEdit) return;
                        createItem('node', '', lastMousePos.x, lastMousePos.y);
                        closeAllPopups();
                    });

                    boardMenuAddTimelineBtn.addEventListener('click', () => {
                        if (!canEdit) return;
                        createItem('timeline', '', lastMousePos.x, lastMousePos.y);
                        closeAllPopups();
                    });

                    boardMenuPasteBtn.addEventListener('click', () => {
                        if (!canEdit) return;
                        onPaste({ clipboardData: null, preventDefault: () => {} });
                        closeAllPopups();
                    });


                    switchBoardBtn.addEventListener('click', () => {
                        const newBoardId = boardNameInput.value.trim();
                        if (newBoardId && newBoardId !== currentBoardId) {

                            loadBoard(newBoardId, null, true);
                        } else {
                            boardNameInput.value = "";
                        }
                    });


                    boardNameInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            switchBoardBtn.click();
                        }
                    });


                    addImageInput.addEventListener('change', (e) => {
                        if (!canEdit) return;
                        const file = e.target.files[0];
                        if (file && file.type.startsWith('image/')) {
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                createItem('image', event.target.result, lastMousePos.x, lastMousePos.y);
                            };
                            reader.readAsDataURL(file);
                        }
                        e.target.value = null;
                        closeAllPopups();
                    });

                    async function batchDelete(collectionRef, querySnapshot) {
                        if (!canEdit) return;
                        const batch = writeBatch(db);
                        querySnapshot.docs.forEach((docToDelete) => {
                            batch.delete(docToDelete.ref);
                        });
                        await batch.commit();
                    }

                    clearNotesBtn.addEventListener('click', async () => {
                        if (!canEdit) return;
                        try {
                            const q = query(itemsCol, where('type', '==', 'note'));
                            const snapshot = await getDocs(q);
                            await batchDelete(itemsCol, snapshot);
                        } catch (e) {
                            console.error("Error clearing notes:", e);
                        }
                    });

                    clearImagesBtn.addEventListener('click', async () => {
                        if (!canEdit) return;
                        try {
                            const q = query(itemsCol, where('type', '==', 'image'));
                            const snapshot = await getDocs(q);
                            await batchDelete(itemsCol, snapshot);
                        } catch (e) {
                            console.error("Error clearing images:", e);
                        }
                    });

                    clearLinesBtn.addEventListener('click', async () => {
                        if (!canEdit) return;
                         try {
                            const snapshot = await getDocs(connectionsCol);
                            await batchDelete(connectionsCol, snapshot);
                        } catch (e) {
                            console.error("Error clearing lines:", e);
                        }
                    });

                    clearDrawingsBtn.addEventListener('click', async () => {
                        if (!canEdit) return;
                         try {
                            const snapshot = await getDocs(drawingsCol);
                            await batchDelete(drawingsCol, snapshot);
                        } catch (e) {
                            console.error("Error clearing drawings:", e);
                        }
                    });

                    async function clearAllBoard(isDeletingRoom = false) {
                        if (!canEdit) return;
                        await clearNotesBtn.click();
                        await clearImagesBtn.click();
                        await clearLinesBtn.click();
                        await clearDrawingsBtn.click();

                        try {
                            const q = query(itemsCol, where('type', '==', 'node'));
                            const snapshot = await getDocs(q);
                            await batchDelete(itemsCol, snapshot);
                        } catch (e) {
                            console.error("Error clearing nodes:", e);
            }

            try {
                const q = query(itemsCol, where('type', '==', 'timeline'));
                const snapshot = await getDocs(q);
                await batchDelete(itemsCol, snapshot);
            } catch (e) {
                console.error("Error clearing timelines:", e);
            }

            if (!isDeletingRoom) {
                translateX = 0;
                            translateY = 0;
                            scale = 1;
                            updateTransform();
                        }
                    }

                    clearAllBtn.addEventListener('click', () => clearAllBoard(false));

                    deleteRoomBtn.addEventListener('click', () => {
                        if (!isBoardOwner) return;
                        deleteRoomName.textContent = currentBoardId;
                        deleteRoomModalOverlay.style.display = 'flex';
                    });

                    cancelDeleteRoomBtn.addEventListener('click', () => {
                        deleteRoomModalOverlay.style.display = 'none';
                    });


                    deleteRoomModalOverlay.addEventListener('click', (e) => {
                        if (e.target === deleteRoomModalOverlay) {
                            deleteRoomModalOverlay.style.display = 'none';
                        }
                    });


                    confirmDeleteRoomBtn.addEventListener('click', async () => {
                        if (!isBoardOwner) return;

                        try {
                            if (boardRef) {
                                await updateDoc(boardRef, { status: 'deleting' });
                            }
                        } catch (e) {
                            console.error("Erro ao marcar a sala para excluso:", e);
                        }
                        if (currentCleanupFunction) {
                            window.removeEventListener('beforeunload', currentCleanupFunction);
                            window.removeEventListener('pagehide', currentCleanupFunction);
                        }
                        if (presenceInterval) {
                            clearInterval(presenceInterval);
                            presenceInterval = null;
                        }
                        currentCleanupFunction = () => {};

                        try {
                            await clearAllBoard(true);

                            if (usersCol) {
                                const usersSnap = await getDocs(usersCol);
                                await batchDelete(usersCol, usersSnap);
                            }

                            if (backupsCol) {
                                const backupsSnap = await getDocs(backupsCol);
                                await batchDelete(backupsCol, backupsSnap);
                            }

                            if (invitesCol) {
                                const invitesSnap = await getDocs(invitesCol);
                                await batchDelete(invitesCol, invitesSnap);
                            }

                            if (boardRef) {
                                await deleteDoc(boardRef);
                            }

                            deleteRoomModalOverlay.style.display = 'none';
                            
                            detachListeners();

                            items.forEach(item => item.el.remove());
                            items.clear();
                            connections.forEach(conn => {
                                conn.lineEl.remove();
                                conn.hitBoxEl.remove();
                                if (conn.arrowHead) conn.arrowHead.remove();
                            });
                            connections = [];
                            drawingGroup.innerHTML = '';
                            itemConnectionsMap.clear();

                            document.querySelector('header').style.display = 'none';
                            document.querySelector('footer').style.display = 'none';
                            toggleSidebarBtn.style.display = 'none';
                            document.getElementById('center-board-btn').style.display = 'none';

                            currentBoardId = null;
                            isBoardOwner = false;
                            canEdit = false;

                            showLobby();

                        } catch (e) {
                            console.error("Error deleting room:", e);
                            deleteRoomModalOverlay.style.display = 'none';
                            showLobby();
                        }
                    });

                    let dragOffsets = new Map();

                    function onItemDragStart(e, itemEl) {
                        if (!canEdit || isResizing || isDrawingLine) return;

                        e.preventDefault();
                        isDragging = true;
                        currentElement = itemEl;
                        dragOffsets.clear();

                        const worldMouse = screenToWorld(e.clientX, e.clientY);

                        if (!selectedItems.has(itemEl.id)) {
                             clearSelection();
                             selectItem(itemEl, null);
                        }

                        selectedItems.forEach((el, id) => {
                             const worldLeft = parseFloat(el.style.left);
                             const worldTop = parseFloat(el.style.top);

                             dragOffsets.set(id, {
                                 startX: worldLeft,
                                 startY: worldTop
                             });
                        });

                        const clickedItemStart = dragOffsets.get(currentElement.id);
                        startPos.x = worldMouse.x - clickedItemStart.startX;
                        startPos.y = worldMouse.y - clickedItemStart.startY;

                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    }

                    function onResizeStart(e) {
                        if (!canEdit || e.button !== 0) return;
                        e.preventDefault();
                        e.stopPropagation();

                        isResizing = true;
                        currentElement = e.target.closest('.item');
                        clearSelection();
                        selectItem(currentElement, e);

                        const computedStyle = window.getComputedStyle(currentElement);
                        startSize.w = parseFloat(computedStyle.width);
                        startSize.h = parseFloat(computedStyle.height);

                        startPos.x = e.clientX;
                        startPos.y = e.clientY;

                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);
                    }

                    async function deleteItem(id, skipConfirm = false) {
                        if (!canEdit || !items.has(id)) return;

                        try {
                            const batch = writeBatch(db);

                            batch.delete(doc(itemsCol, id));

                            const q1 = query(connectionsCol, where('startId', '==', id));
                            const q2 = query(connectionsCol, where('endId', '==', id));

                            const [snap1, snap2] = await Promise.all([getDocs(q1), getDocs(q2)]);

                            snap1.docs.forEach(d => batch.delete(d.ref));
                            snap2.docs.forEach(d => batch.delete(d.ref));

                            await batch.commit();

                            hideLineControlPanel();
                        } catch (e) {
                            console.error("Error deleting item and its connections:", e);
                        }
                    }

                    function onDelete(e) {
                        if (!canEdit || e.button !== 0) return;
                        e.stopPropagation();
                        const itemEl = e.target.closest('.item');
                        deleteItem(itemEl.id, true);
                    }

                    async function startDrawingLine(e, identifier, lineType) {
                        if (!canEdit) return;
                        e.preventDefault();
                        e.stopPropagation();

                        isDrawingLine = true;
                        drawingLineType = lineType;

                        let startPoint;
                        let startId = identifier;

                        if (!items.has(identifier)) {
                            const clickedConn = connections.find(c => c.id === identifier);
                            if (!clickedConn) {
                                isDrawingLine = false;
                                return;
                            }

                            const oldStartId = clickedConn.startId;
                            const oldEndId = clickedConn.endId;
                            const oldType = clickedConn.type;
                            const oldThickness = clickedConn.thickness;

                            const currentDrawingLineType = drawingLineType;
                            const currentThickness = lineThicknessInput.value;

                            await deleteLine(clickedConn.id);

                            drawingLineType = oldType;
                            lineThicknessInput.value = oldThickness;

                            const newNodeId = await createItem('node', '', lineClickPos.x, lineClickPos.y);
                            if (!newNodeId) {
                                isDrawingLine = false;
                                return;
                            }

                            await createConnection(oldStartId, newNodeId);
                            await createConnection(newNodeId, oldEndId);

                            drawingLineType = currentDrawingLineType;
                            lineThicknessInput.value = currentThickness;

                            startId = newNodeId;

                            let newNodeEl = items.get(newNodeId)?.el;
                            let attempts = 0;
                            while(!newNodeEl && attempts < 50) {
                                await new Promise(r => setTimeout(r, 100));
                                newNodeEl = items.get(newNodeId)?.el;
                                attempts++;
                            }

                            if (!newNodeEl) {
                                isDrawingLine = false;
                                return;
                            }
                            startPoint = getElementCenter(newNodeEl);

                        } else {
                            const startEl = items.get(identifier)?.el;
                            if (!startEl) {
                                isDrawingLine = false;
                                return;
                            }
                            startPoint = getElementCenter(startEl);
                        }

                        lineStartIdentifier = startId;

                        if (!startPoint) {
                            isDrawingLine = false;
                            return;
                        }

                        const svgStart = worldToSvg(startPoint);

                        tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        tempLine.setAttribute('class', 'connector-line');
                        tempLine.setAttribute('style', 'pointer-events: none;');

                        const thickness = lineThicknessInput.value;
                        tempLine.setAttribute('stroke-width', thickness);

                        tempLine.setAttribute('stroke', 'url(#threadPattern)');
                        if (lineType === 'dotted') {
                            const dash = thickness * 2;
                            const gap = thickness;
                            tempLine.setAttribute('stroke-dasharray', `${dash} ${gap}`);
                        }

                        tempLine.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgStart.x} ${svgStart.y}`);
                        svgLayerConnections.appendChild(tempLine);

                        document.addEventListener('mousemove', onMouseMove);
                        document.addEventListener('mouseup', onMouseUp);

                        hideItemMenu();
                        hideLineControlPanel();
                    }

                    async function createConnection(startId, endId) {
                        if (!canEdit || startId === endId) return;

                        if (connections.some(c => (c.startId === startId && c.endId === endId) || (c.startId === endId && c.endId === startId))) {
                            return;
                        }

                        const connectionData = {
                            startId,
                            endId,
                            type: drawingLineType,
                            color: lineColorInput.value,
                            thickness: parseFloat(lineThicknessInput.value),
                        };

                        try {
                            await addDoc(connectionsCol, connectionData);
                        } catch (e) {
                            console.error("Error creating connection:", e);
                        }
                    }

                    function getLineMidpoint(connectionId) {
                        const parentConn = connections.find(c => c.id === connectionId);
                        if (!parentConn) return null;

                        let startPoint;
                        const startEl = items.get(parentConn.startId)?.el;
                        if (!startEl) return null;
                        startPoint = getElementCenter(startEl);

                        let endPoint;
                        const endEl = items.get(parentConn.endId)?.el;
                        if (!endEl) return null;
                        endPoint = getElementCenter(endEl);

                        if (!startPoint || !endPoint) return null;

                        return {
                            x: (startPoint.x + endPoint.x) / 2,
                            y: (startPoint.y + endPoint.y) / 2
                        };
                    }

                    function updateConnectionLine(connection) {
                        let startPoint, endPoint;

                        const startEl = items.get(connection.startId)?.el;
                        if (startEl) startPoint = getElementCenter(startEl);

                        const endEl = items.get(connection.endId)?.el;
                        if (endEl) endPoint = getElementCenter(endEl);

                        if (!startPoint || !endPoint) {
                            return;
                        }

                        let actualStartPoint = { ...startPoint };
                        let actualEndPoint = { ...endPoint };

                        const dx = endPoint.x - startPoint.x;
                        const dy = endPoint.y - startPoint.y;
                        const len = Math.sqrt(dx * dx + dy * dy);

                        if (len > 0) {
                            const nx = dx / len;
                            const ny = dy / len;
                            const absNx = Math.abs(nx);
                            const absNy = Math.abs(ny);

                            if (endEl) {
                                const endWidth = parseFloat(window.getComputedStyle(endEl).width);
                                const endHeight = parseFloat(window.getComputedStyle(endEl).height);

                                let insetScaleEnd = 0;
                                if(absNx > 0.001 && absNy > 0.001) {
                                    insetScaleEnd = Math.min(endWidth / 2 / absNx, endHeight / 2 / absNy);
                                } else if (absNx > 0.001) {
                                    insetScaleEnd = endWidth / 2 / absNx;
                                } else if (absNy > 0.001) {
                                    insetScaleEnd = endHeight / 2 / absNy;
                                }

                                actualEndPoint.x = endPoint.x - nx * insetScaleEnd;
                                actualEndPoint.y = endPoint.y - ny * insetScaleEnd;
                            }

                            if (startEl) {
                                const startWidth = parseFloat(window.getComputedStyle(startEl).width);
                                const startHeight = parseFloat(window.getComputedStyle(startEl).height);

                                let insetScaleStart = 0;
                                if(absNx > 0.001 && absNy > 0.001) {
                                    insetScaleStart = Math.min(startWidth / 2 / absNx, startHeight / 2 / absNy);
                                } else if (absNx > 0.001) {
                                    insetScaleStart = startWidth / 2 / absNx;
                                } else if (absNy > 0.001) {
                                    insetScaleStart = startHeight / 2 / absNy;
                                }

                                actualStartPoint.x = startPoint.x + nx * insetScaleStart;
                                actualStartPoint.y = startPoint.y + ny * insetScaleStart;
                            }
                        }

                        const svgStart = worldToSvg(actualStartPoint);
                        const svgEnd = worldToSvg(actualEndPoint);

                        connection.lineEl.setAttribute('stroke-width', connection.thickness);

                        connection.lineEl.setAttribute('stroke', 'url(#threadPattern)');
                        if (connection.type === 'dotted') {
                            const thickness = connection.thickness || 3;
                            const dash = thickness * 2;
                            const gap = thickness;
                            connection.lineEl.setAttribute('stroke-dasharray', `${dash} ${gap}`);
                        } else {
                            connection.lineEl.setAttribute('stroke-dasharray', '0');
                        }

                        if (connection.arrowHead) {
                            connection.arrowHead.remove();
                            connection.arrowHead = null;
                        }

                        connection.lineEl.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgEnd.x} ${svgEnd.y}`);
                        connection.hitBoxEl.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgEnd.x} ${svgEnd.y}`);

                        if (connection.type === 'arrow') {
                            const angle = Math.atan2(actualEndPoint.y - actualStartPoint.y, actualEndPoint.x - actualStartPoint.x);

                            const dynamicArrowSize = connection.thickness * 3.5;

                            const lineEndX = actualEndPoint.x - dynamicArrowSize * Math.cos(angle);
                            const lineEndY = actualEndPoint.y - dynamicArrowSize * Math.sin(angle);
                            const svgLineEnd = worldToSvg({ x: lineEndX, y: lineEndY });
                            connection.lineEl.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgLineEnd.x} ${svgLineEnd.y}`);
                            connection.hitBoxEl.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgLineEnd.x} ${svgLineEnd.y}`);

                            const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            arrowHead.setAttribute('fill', 'url(#threadPattern)');
                            arrowHead.setAttribute('vector-effect', 'non-scaling-stroke');

                            const svgP1 = worldToSvg(actualEndPoint);
                            const svgP2 = worldToSvg({ x: actualEndPoint.x - dynamicArrowSize * Math.cos(angle - Math.PI / 6), y: actualEndPoint.y - dynamicArrowSize * Math.sin(angle - Math.PI / 6) });
                            const svgP3 = worldToSvg({ x: actualEndPoint.x - dynamicArrowSize * Math.cos(angle + Math.PI / 6), y: actualEndPoint.y - dynamicArrowSize * Math.sin(angle + Math.PI / 6) });

                            const arrowPoints = [
                                `${svgP1.x},${svgP1.y}`,
                                `${svgP2.x},${svgP2.y}`,
                                `${svgP3.x},${svgP3.y}`
                            ].join(' ');
                            arrowHead.setAttribute('points', arrowPoints);

                            svgLayerConnections.appendChild(arrowHead);
                            connection.arrowHead = arrowHead;
                        }
                    }

                    function updateAllConnectionsForItem(itemId) {
                        const connectionIds = itemConnectionsMap.get(itemId);
                        if (connectionIds) {
                            connectionIds.forEach(connId => {
                                const conn = connections.find(c => c.id === connId);
                                if (conn) {
                                    updateConnectionLine(conn);
                                }
                            });
                        }
                    }

                    function renderTimelineSVG(svgEl, itemEl, data) {
                        if (!svgEl || !itemEl) return;

                        const w = parseFloat(data.width);
                        const h = parseFloat(data.height);
                        svgEl.innerHTML = '';

                        const timelineModeClass = data.mode === 'vertical' ? 'timeline-vertical' : 'timeline-horizontal';
                        svgEl.setAttribute('class', `timeline-svg ${timelineModeClass}`);

                        const mainColor = data.mainColor || '#3b82f6';
                        const strokeWidth = 4;
                        const ballRadius = 8;
                        const arrowSize = 10;
                        const handleRadius = 5;
                        const textOffset = 10;
                        const imagePadding = 5;
                        const itemPadding = 20;

                        let line = { x1: 0, y1: 0, x2: 0, y2: 0 };
                        let ball = { cx: 0, cy: 0 };
                        let arrowPath = "";
                        let mainLineCenterY, mainLineCenterX;

                        let minContentX = 0, maxContentX = w;
                        let minContentY = 0, maxContentY = h;

                        if (data.mode === 'horizontal') {
                            mainLineCenterY = h / 2;
                            line.y1 = line.y2 = mainLineCenterY;
                            
                            if (data.direction === 'l-r') {
                                line.x1 = itemPadding + ballRadius;
                                line.x2 = w - itemPadding - arrowSize;
                                ball.cx = itemPadding;
                                ball.cy = mainLineCenterY;
                                arrowPath = `M${w - itemPadding - arrowSize},${mainLineCenterY - arrowSize / 2} L${w - itemPadding},${mainLineCenterY} L${w - itemPadding - arrowSize},${mainLineCenterY + arrowSize / 2} Z`;
                            } else {
                                line.x1 = w - itemPadding - ballRadius;
                                line.x2 = itemPadding + arrowSize;
                                ball.cx = w - itemPadding;
                                ball.cy = mainLineCenterY;
                                arrowPath = `M${itemPadding + arrowSize},${mainLineCenterY - arrowSize / 2} L${itemPadding},${mainLineCenterY} L${itemPadding + arrowSize},${mainLineCenterY + arrowSize / 2} Z`;
                            }
                            minContentY = mainLineCenterY - ballRadius;
                            maxContentY = mainLineCenterY + ballRadius;
                            minContentX = 0;
                            maxContentX = w;
                        } else {
                            mainLineCenterX = w / 2;
                            line.x1 = line.x2 = mainLineCenterX;
                            
                            if (data.direction === 't-b') {
                                line.y1 = itemPadding + ballRadius;
                                line.y2 = h - itemPadding - arrowSize;
                                ball.cx = mainLineCenterX;
                                ball.cy = itemPadding;
                                arrowPath = `M${mainLineCenterX - arrowSize / 2},${h - itemPadding - arrowSize} L${mainLineCenterX},${h - itemPadding} L${mainLineCenterX + arrowSize / 2},${h - itemPadding - arrowSize} Z`;
                            } else {
                                line.y1 = h - itemPadding - ballRadius;
                                line.y2 = itemPadding + arrowSize;
                                ball.cx = mainLineCenterX;
                                ball.cy = h - itemPadding;
                                arrowPath = `M${mainLineCenterX - arrowSize / 2},${itemPadding + arrowSize} L${mainLineCenterX},${itemPadding} L${mainLineCenterX + arrowSize / 2},${itemPadding + arrowSize} Z`;
                            }
                            minContentX = mainLineCenterX - ballRadius;
                            maxContentX = mainLineCenterX + ballRadius;
                            minContentY = 0;
                            maxContentY = h;
                        }

                        const eventsData = (data.events || []).map((event, index) => {
                            const eventColor = event.color || '#FFFFFF';
                            const eventLineLength = event.lineLength || 40;
                            let eventPos = { x: 0, y: 0 };
                            let eventLine = { x1: 0, y1: 0, x2: 0, y2: 0 };
                            let textPos = { x: 0, y: 0 };
                            let textAnchor = 'middle';
                            let imagePos = { x: 0, y: 0 };
                            const isAlt = index % 2 === 0;

                            let textEl = null;
                            if (event.text) {
                                textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                textEl.setAttribute('fill', eventColor);
                                textEl.setAttribute('class', 'timeline-event-text');
                                
                                const lines = event.text.split('\n');
                                lines.forEach((line, i) => {
                                    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                                    tspan.textContent = line || ' ';
                                    tspan.setAttribute('x', 0);
                                    tspan.setAttribute('dy', (i === 0) ? '0' : '1.2em');
                                    textEl.appendChild(tspan);
                                });
                                
                                svgEl.appendChild(textEl);
                            }

                            const textBBox = textEl ? textEl.getBBox() : { x: 0, y: 0, width: 0, height: 0 };
                            const textHeight = textBBox.height;
                            const textWidth = textBBox.width;
                            
                            const linesCount = textEl ? textEl.querySelectorAll('tspan').length : 1;
                            const singleLineHeight = (linesCount > 0) ? (textHeight / linesCount) : 0;
                            
                            if (data.mode === 'horizontal') {
                                const mainLineWidth = line.x2 - line.x1;
                                eventPos.x = line.x1 + (mainLineWidth * event.position);
                                eventPos.y = mainLineCenterY;
                                
                                eventLine.x1 = eventPos.x;
                                eventLine.y1 = eventPos.y;
                                eventLine.x2 = eventPos.x;
                                eventLine.y2 = isAlt ? (eventPos.y - eventLineLength) : (eventPos.y + eventLineLength);
                                
                                textPos.x = eventLine.x2;
                                textAnchor = 'middle';
                                
                                imagePos.x = eventLine.x2 - 50;

                                if (isAlt) {
                                    imagePos.y = eventLine.y2 - (event.image ? 50 : 0) - (textHeight > 0 ? textHeight : 0) - (event.image && event.text ? imagePadding : 0);
                                    
                                    const baseTextY = event.image ? (imagePos.y + 50 + imagePadding + (textHeight > 0 ? (singleLineHeight * 0.85) : 0)) : (eventLine.y2 - textOffset);
                                    textPos.y = baseTextY - textHeight + singleLineHeight;
                                    
                                } else {
                                    textPos.y = eventLine.y2 + 15 + textOffset;
                                    imagePos.y = textPos.y + (textHeight > 0 ? textHeight : 0) + (event.image && event.text ? imagePadding : 0);
                                }
                            } else {
                                const mainLineHeight = line.y2 - line.y1;
                                eventPos.x = mainLineCenterX;
                                eventPos.y = line.y1 + (mainLineHeight * event.position);
                                
                                eventLine.x1 = eventPos.x;
                                eventLine.y1 = eventPos.y;
                                eventLine.x2 = isAlt ? (eventPos.x - eventLineLength) : (eventPos.x + eventLineLength);
                                eventLine.y2 = eventPos.y;
                                
                                const textCenterYOffset = textBBox.y + (textHeight / 2);
                                textPos.y = eventLine.y2 - textCenterYOffset;
                                
                                if (isAlt) {
                                    textAnchor = 'end';
                                    textPos.x = eventLine.x2 - textOffset;
                                    imagePos.x = textPos.x - (textWidth > 0 ? textWidth : 0) - (event.image && event.text ? imagePadding : 0) - (event.image ? 100 : 0);
                                } else {
                                    textAnchor = 'start';
                                    textPos.x = eventLine.x2 + textOffset;
                                    imagePos.x = textPos.x + (textWidth > 0 ? textWidth : 0) + (event.image && event.text ? imagePadding : 0);
                                }
                                imagePos.y = textPos.y - 15;
                            }

                            if (textEl) {
                                textEl.setAttribute('x', textPos.x);
                                textEl.setAttribute('y', textPos.y);
                                textEl.setAttribute('text-anchor', textAnchor);
                                textEl.querySelectorAll('tspan').forEach(tspan => {
                                    tspan.setAttribute('x', textPos.x);
                                });
                            }

                            const final_textBBox = textEl ? textEl.getBBox() : { x: 0, y: 0, width: 0, height: 0 };
                            let final_imgBBox = { x: imagePos.x, y: imagePos.y, width: (event.image ? 100 : 0), height: (event.image ? 50 : 0) };

                            minContentY = Math.min(minContentY, eventLine.y2, final_textBBox.y, final_imgBBox.y);
                            maxContentY = Math.max(maxContentY, eventLine.y2, final_textBBox.y + final_textBBox.height, final_imgBBox.y + final_imgBBox.height);
                            minContentX = Math.min(minContentX, eventLine.x2, final_textBBox.x, final_imgBBox.x);
                            maxContentX = Math.max(maxContentX, eventLine.x2, final_textBBox.x + final_textBBox.width, final_imgBBox.x + final_imgBBox.width);

                            if (textEl) textEl.remove();

                            return { event, eventColor, eventLine, textPos, textAnchor, imagePos, eventPos, isAlt };
                        });

                        let newW_px = w, newH_px = h;
                        let viewBox_x = 0, viewBox_y = 0, viewBox_w = w, viewBox_h = h;

                        if (data.mode === 'horizontal') {
                            const requiredHeight = (maxContentY - minContentY) + (itemPadding * 2);
                            newH_px = Math.max(100, requiredHeight);
                            viewBox_y = minContentY - itemPadding;
                            viewBox_h = newH_px;
                            viewBox_w = w;
                        } else {
                            const requiredWidth = (maxContentX - minContentX) + (itemPadding * 2);
                            newW_px = Math.max(150, requiredWidth);
                            viewBox_x = minContentX - itemPadding;
                            viewBox_w = newW_px;
                            viewBox_h = h;
                        }
                        
                        const needsWidthUpdate = (data.mode === 'vertical' && Math.abs(newW_px - w) > 1);
                        const needsHeightUpdate = (data.mode === 'horizontal' && Math.abs(newH_px - h) > 1);

                        if ((needsWidthUpdate || needsHeightUpdate) && !isResizing && !isMovingTimelineEvent && !isResizingTimelineEvent) {
                            if (typeof itemsCol !== 'undefined' && itemsCol) {
                                try {
                                    const itemRef = doc(itemsCol, itemEl.id);
                                    if (needsWidthUpdate) {
                                        updateDoc(itemRef, { width: `${newW_px}px` });
                                    }
                                    if (needsHeightUpdate) {
                                        updateDoc(itemRef, { height: `${newH_px}px` });
                                    }
                                } catch (e) {
                                    console.error("Error auto-resizing timeline:", e);
                                }
                            }
                        }
                        
                        svgEl.setAttribute('viewBox', `${viewBox_x} ${viewBox_y} ${viewBox_w} ${viewBox_h}`);
                        
                        const mainLineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        mainLineEl.setAttribute('x1', line.x1);
                        mainLineEl.setAttribute('y1', line.y1);
                        mainLineEl.setAttribute('x2', line.x2);
                        mainLineEl.setAttribute('y2', line.y2);
                        mainLineEl.setAttribute('stroke', mainColor);
                        mainLineEl.setAttribute('stroke-width', strokeWidth);
                        mainLineEl.setAttribute('class', 'timeline-main-line');
                        svgEl.appendChild(mainLineEl);
                        
                        const ballEl = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        ballEl.setAttribute('cx', ball.cx);
                        ballEl.setAttribute('cy', ball.cy);
                        ballEl.setAttribute('r', ballRadius);
                        ballEl.setAttribute('fill', mainColor);
                        ballEl.setAttribute('class', 'timeline-ball');
                        svgEl.appendChild(ballEl);
                        
                        const arrowEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        arrowEl.setAttribute('d', arrowPath);
                        arrowEl.setAttribute('fill', mainColor);
                        arrowEl.setAttribute('class', 'timeline-arrow');
                        svgEl.appendChild(arrowEl);

                        eventsData.forEach(({ event, eventColor, eventLine, textPos, textAnchor, imagePos, eventPos, isAlt }) => {
                            const eventLineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            eventLineEl.setAttribute('x1', eventLine.x1);
                            eventLineEl.setAttribute('y1', eventLine.y1);
                            eventLineEl.setAttribute('x2', eventLine.x2);
                            eventLineEl.setAttribute('y2', eventLine.y2);
                            eventLineEl.setAttribute('stroke', eventColor);
                            eventLineEl.setAttribute('stroke-width', 2);
                            eventLineEl.setAttribute('class', 'timeline-event-line');
                            svgEl.appendChild(eventLineEl);
                            
                            if (event.text) {
                                const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                textEl.setAttribute('x', textPos.x);
                                textEl.setAttribute('y', textPos.y);
                                textEl.setAttribute('fill', eventColor);
                                textEl.setAttribute('text-anchor', textAnchor);
                                textEl.setAttribute('class', 'timeline-event-text');
                                
                                const lines = event.text.split('\n');
                                lines.forEach((line, i) => {
                                    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                                    tspan.textContent = line || ' ';
                                    tspan.setAttribute('x', textPos.x);
                                    tspan.setAttribute('dy', (i === 0) ? '0' : '1.2em');
                                    textEl.appendChild(tspan);
                                });
                                
                                svgEl.appendChild(textEl);
                            }

                            if (event.image) {
                                const imgEl = document.createElementNS('http://www.w3.org/2000/svg', 'image');
                                imgEl.setAttribute('x', imagePos.x);
                                imgEl.setAttribute('y', imagePos.y);
                                imgEl.setAttribute('width', 100);
                                imgEl.setAttribute('height', 50);
                                imgEl.setAttribute('href', event.image);
                                svgEl.appendChild(imgEl);
                            }

                            const moveHandle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            moveHandle.setAttribute('cx', eventPos.x);
                            moveHandle.setAttribute('cy', eventPos.y);
                            moveHandle.setAttribute('r', handleRadius);
                            moveHandle.setAttribute('class', 'timeline-event-move-handle');
                            moveHandle.dataset.eventId = event.id;
                            moveHandle.dataset.isAlt = isAlt;
                            svgEl.appendChild(moveHandle);

                            const resizeHandle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            resizeHandle.setAttribute('cx', eventLine.x2);
                            resizeHandle.setAttribute('cy', eventLine.y2);
                            resizeHandle.setAttribute('r', handleRadius);
                            resizeHandle.setAttribute('class', 'timeline-event-resize-handle');
                            resizeHandle.dataset.eventId = event.id;
                            resizeHandle.dataset.isAlt = isAlt;
                            svgEl.appendChild(resizeHandle);
                        });
                    }

                    function onMouseMove(e) {

                        if (isPanning) {
                            e.preventDefault();
                            translateX = e.clientX - startPos.x;
                            translateY = e.clientY - startPos.y;
                            updateTransform();
                            return;
                        }

                        const mouseX = e.clientX;
                        const mouseY = e.clientY;
                        const worldMouse = screenToWorld(mouseX, mouseY);
                        const worldMouseX = worldMouse.x;
                        const worldMouseY = worldMouse.y;

                        if (isDragging) {
                            if (!canEdit) return;
                            let newClickedItemX = worldMouseX - startPos.x;
                            let newClickedItemY = worldMouseY - startPos.y;

                            const clickedItemStart = dragOffsets.get(currentElement.id);
                            const deltaX = newClickedItemX - clickedItemStart.startX;
                            const deltaY = newClickedItemY - clickedItemStart.startY;

                            selectedItems.forEach((el, id) => {
                                const originalPos = dragOffsets.get(id);
                                const newX = originalPos.startX + deltaX;
                                const newY = originalPos.startY + deltaY;

                                el.style.left = `${newX}px`;
                                el.style.top = `${newY}px`;

                                updateAllConnectionsForItem(id);
                            });

                        } else if (isResizing) {
                            if (!canEdit) return;
                            const deltaX_screen = mouseX - startPos.x;
                            const deltaY_screen = mouseY - startPos.y;

                            const deltaX_world = deltaX_screen / scale;
                            const deltaY_world = deltaY_screen / scale;

                            const aspectRatio = currentElement.dataset.aspectRatio;

                            if (aspectRatio) {
                                const newWidth = Math.max(150, startSize.w + deltaX_world);
                                currentElement.style.width = `${newWidth}px`;
                                currentElement.style.height = 'auto';
                            } else {
                                const newWidth = Math.max(150, startSize.w + deltaX_world);
                                const newHeight = Math.max(100, startSize.h + deltaY_world);

                                currentElement.style.width = `${newWidth}px`;
                                currentElement.style.height = `${newHeight}px`;
                            }

                            updateAllConnectionsForItem(currentElement.id);
                            if (currentElement.classList.contains('item-timeline')) {
                                const item = items.get(currentElement.id);
                                if (item) {
                                    const tempData = { ...item.data };
                                    tempData.width = currentElement.style.width;
                                    tempData.height = currentElement.style.height;
                                    renderTimelineSVG(currentElement.querySelector('svg'), currentElement, tempData);
                                }
                            }

                        } else if (isDrawingLine) {
                            if (!canEdit) return;
                            let startPoint;
                            if (!items.get(lineStartIdentifier)) return;
                            startPoint = getElementCenter(items.get(lineStartIdentifier).el);

                            if(startPoint) {
                                const svgStart = worldToSvg(startPoint);
                                const svgMouse = worldToSvg(worldMouse);
                                tempLine.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgMouse.x} ${svgMouse.y}`);
                            }
                        }
                        else if (isSelecting) {
                            const boardRect = board.getBoundingClientRect();

                            const currentSelX = mouseX - boardRect.left;
                            const currentSelY = mouseY - boardRect.top;

                            const selBoxStartX = startPos.x - boardRect.left;
                            const selBoxStartY = startPos.y - boardRect.top;

                            const left = Math.min(selBoxStartX, currentSelX);
                            const top = Math.min(selBoxStartY, currentSelY);
                            const width = Math.abs(selBoxStartX - currentSelX);
                            const height = Math.abs(selBoxStartY - currentSelY);

                            selectionBox.style.left = `${left}px`;
                            selectionBox.style.top = `${top}px`;
                            selectionBox.style.width = `${width}px`;
                            selectionBox.style.height = `${height}px`;
                        } else if (isDrawingFreehand) {
                            if (!canEdit) return;
                            const svgPos = worldToSvg(worldMouse);

                            const lastPoint = currentFreehandPoints[currentFreehandPoints.length - 1];
                            const dx = svgPos.x - lastPoint.x;
                            const dy = svgPos.y - lastPoint.y;
                            if (Math.sqrt(dx*dx + dy*dy) < MIN_DRAW_DISTANCE) {
                                return;
                            }

                            currentFreehandPoints.push(svgPos);

                            const points = currentFreehandPoints;

                            if (points.length > 2) {
                                const last = points[points.length - 1];
                                const secondLast = points[points.length - 2];

                                const M_curr = midPoint(secondLast, last);

                                const newSegment = `Q${secondLast.x},${secondLast.y} ${M_curr.x},${M_curr.y}`;
                                currentFreehandPathString += " " + newSegment;

                                if (currentFreehandPathString) {
                                    currentFreehandPath.setAttribute('d', currentFreehandPathString);
                                }
                            }
                        }

                        else if (isMovingTimelineEvent) {
                            if (!canEdit) return;
                            
                            const { itemData, event, startPos_world, startPosition } = currentTimelineEventData;
                            const w = parseFloat(itemData.width);
                            const h = parseFloat(itemData.height);
                            const padding = 20, ballRadius = 8, arrowSize = 10;
                            
                            let newPosition = startPosition;

                            if (itemData.mode === 'horizontal') {
                                const line_x1 = (itemData.direction === 'l-r') ? (padding + ballRadius) : (padding + arrowSize);
                                const line_x2 = (itemData.direction === 'l-r') ? (w - padding - arrowSize) : (w - padding - ballRadius);
                                const mainLineWidth = line_x2 - line_x1;
                                
                                if (Math.abs(mainLineWidth) > 1) {
                                    const deltaX_world = worldMouse.x - startPos_world.x;
                                    const positionDelta = deltaX_world / mainLineWidth;
                                    newPosition = startPosition + positionDelta;
                                }
                            } else {
                                const line_y1 = (itemData.direction === 't-b') ? (padding + ballRadius) : (padding + arrowSize);
                                const line_y2 = (itemData.direction === 't-b') ? (h - padding - arrowSize) : (h - padding - ballRadius);
                                const mainLineHeight = line_y2 - line_y1;

                                if (Math.abs(mainLineHeight) > 1) {
                                    const deltaY_world = worldMouse.y - startPos_world.y;
                                    const positionDelta = deltaY_world / mainLineHeight;
                                    newPosition = startPosition + positionDelta;
                                }
                            }

                            event.position = Math.max(0, Math.min(1, newPosition));
                            
                            renderTimelineSVG(currentTimelineEventData.itemEl.querySelector('svg'), currentTimelineEventData.itemEl, itemData);

                        } else if (isResizingTimelineEvent) {
                            if (!canEdit) return;

                            const { itemData, event, startPos_world, startLineLength, isAlt } = currentTimelineEventData;
                            let newLength = startLineLength;
                            
                            if (itemData.mode === 'horizontal') {
                                const deltaY_world = worldMouse.y - startPos_world.y;
                                newLength = isAlt ? (startLineLength - deltaY_world) : (startLineLength + deltaY_world);
                            } else {
                                const deltaX_world = worldMouse.x - startPos_world.x;
                                newLength = isAlt ? (startLineLength - deltaX_world) : (startLineLength + deltaX_world);
                            }

                            event.lineLength = Math.max(10, newLength);
                            
                            renderTimelineSVG(currentTimelineEventData.itemEl.querySelector('svg'), currentTimelineEventData.itemEl, itemData);
                        }
                    }

                    async function onMouseUp(e) {
                        if (isDrawingLine) {
                            if (!canEdit) return;
                            let endIdentifier = null;
                            const endElement = e.target.closest('.item');
                            const endConn = connections.find(c => c.hitBoxEl === e.target);

                            if (endElement) {
                                endIdentifier = endElement.id;
                                if (endIdentifier && endIdentifier !== lineStartIdentifier) {
                                    await createConnection(lineStartIdentifier, endIdentifier);
                                }
                            } else if (endConn && endConn.id !== lineStartIdentifier) {

                                const oldStartId = endConn.startId;
                                const oldEndId = endConn.endId;
                                const oldType = endConn.type;
                                const oldThickness = endConn.thickness;

                                await deleteLine(endConn.id);

                                const currentDrawingLineType = drawingLineType;
                                const currentThickness = lineThicknessInput.value;

                                drawingLineType = oldType;
                                lineThicknessInput.value = oldThickness;

                                const newNodeId = await createItem('node', '', e.clientX, e.clientY);

                                if (newNodeId) {
                                    await createConnection(lineStartIdentifier, newNodeId);
                                    await createConnection(oldStartId, newNodeId);
                                    await createConnection(newNodeId, oldEndId);
                                }

                                drawingLineType = currentDrawingLineType;
                                lineThicknessInput.value = currentThickness;
                            }

                            if(tempLine) tempLine.remove();
                            tempLine = null;
                        }

                        if (isSelecting) {
                            selectionBox.style.display = 'none';

                            const boardRect = board.getBoundingClientRect();
                            const selLeft = parseFloat(selectionBox.style.left) - boardRect.left;
                            const selTop = parseFloat(selectionBox.style.top) - boardRect.top;
                            const selRight = selLeft + parseFloat(selectionBox.style.width);
                            const selBottom = selTop + parseFloat(selectionBox.style.height);

                            const worldSel = {
                                left: (selLeft - translateX) / scale,
                                top: (selTop - translateY) / scale,
                                right: (selRight - translateX) / scale,
                                bottom: (selBottom - translateY) / scale
                            };

                            if (!e.ctrlKey) {
                                clearSelection();
                            }

                            items.forEach((item, id) => {
                                const itemStyle = window.getComputedStyle(item.el);
                                const itemLeft = parseFloat(itemStyle.left);
                                const itemTop = parseFloat(itemStyle.top);
                                const itemRight = itemLeft + (item.el.offsetWidth / scale);
                                const itemBottom = itemTop + (item.el.offsetHeight / scale);

                                if (worldSel.left < itemRight && worldSel.right > itemLeft &&
                                    worldSel.top < itemBottom && worldSel.bottom > itemTop)
                                {
                                    selectedItems.set(id, item.el);
                                }
                            });

                            connections.forEach(conn => {
                                const midPoint = getLineMidpoint(conn.id);
                                if (midPoint) {
                                    if (worldSel.left < midPoint.x && worldSel.right > midPoint.x &&
                                        worldSel.top < midPoint.y && worldSel.bottom > midPoint.y)
                                    {
                                        selectedLines.set(conn.id, conn);
                                    }
                                }
                            });

                            updateSelectionVisuals();
                        }

                        if (isDrawingFreehand) {
                            if (!canEdit) return;

                            if (drawTool === 'pencil') {
                                if (currentFreehandPoints.length > 1) {
                                    const last = currentFreehandPoints[currentFreehandPoints.length - 1];
                                    const newSegment = `L${last.x},${last.y}`;
                                    currentFreehandPathString += " " + newSegment;
                                    currentFreehandPath.setAttribute('d', currentFreehandPathString);
                                }
                                await mergePath(currentFreehandPath);
                            } else {
                                if (currentFreehandPath) {
                                    const eraserRect = currentFreehandPath.getBBox();
                                    currentFreehandPath.remove();

                                    const pathsToDelete = new Set();
                                    const batch = writeBatch(db);

                                    drawingGroup.querySelectorAll('path.freehand-drawing').forEach(pathEl => {
                                        const pathRect = pathEl.getBBox();
                                        if (!(eraserRect.x > pathRect.x + pathRect.width ||
                                              eraserRect.x + eraserRect.width < pathRect.x ||
                                              eraserRect.y > pathRect.y + pathRect.height ||
                                              eraserRect.y + eraserRect.height < pathRect.y)) {

                                            pathsToDelete.add(pathEl.dataset.id);
                                        }
                                    });

                                    if (pathsToDelete.size > 0) {
                                        pathsToDelete.forEach(id => {
                                            batch.delete(doc(drawingsCol, id));
                                        });
                                        await batch.commit();
                                    }
                                }
                            }

                            currentFreehandPath = null;
                            currentFreehandPoints = [];
                            currentFreehandPathString = "";
                        }

                        if (isMovingTimelineEvent || isResizingTimelineEvent) {
                            if (canEdit && currentTimelineEventData) {
                                try {
                                    const itemRef = doc(itemsCol, currentTimelineEventData.itemEl.id);

                                    isMovingTimelineEvent = false;
                                    isResizingTimelineEvent = false;

                                    await updateDoc(itemRef, {
                                        events: currentTimelineEventData.itemData.events
                                    });

                                    renderTimelineSVG(currentTimelineEventData.itemEl.querySelector('svg'), currentTimelineEventData.itemEl, currentTimelineEventData.itemData);
                                    
                                } catch (e) {
                                    console.error("Error updating timeline event:", e);
                                    isMovingTimelineEvent = false;
                                    isResizingTimelineEvent = false;
                                }
                            } else {
                                isMovingTimelineEvent = false;
                                isResizingTimelineEvent = false;
                            }
                            
                            currentTimelineEventData = null;
                        }

                        if (isDragging) {
                            if (!canEdit) return;
                            const batch = writeBatch(db);
                            selectedItems.forEach((el, id) => {
                                let newX = parseFloat(el.style.left);
                                let newY = parseFloat(el.style.top);

                                if (snapToGrid) {
                                    newX = Math.round(newX / GRID_SIZE) * GRID_SIZE;
                                    newY = Math.round(newY / GRID_SIZE) * GRID_SIZE;
                                    el.style.left = `${newX}px`;
                                    el.style.top = `${newY}px`;
                                    updateAllConnectionsForItem(id);
                                }

                                const itemRef = doc(itemsCol, id);
                                batch.update(itemRef, { x: `${newX}px`, y: `${newY}px` });
                            });
                            await batch.commit();
                        }

                        if (isResizing) {
                            if (!canEdit) {
                                isResizing = false;
                            } else {
                                try {
                                    const newWidth = currentElement.style.width;
                                    const newHeight = currentElement.style.height;
                                    
                                    const itemRef = doc(itemsCol, currentElement.id);
                                    
                                    isResizing = false; 
                                    
                                    await updateDoc(itemRef, {
                                        width: newWidth,
                                        height: newHeight
                                    });

                                    if (currentElement.classList.contains('item-timeline')) {
                                        const item = items.get(currentElement.id);
                                        if (item) {
                                            item.data.width = newWidth;
                                            item.data.height = newHeight;
                                            renderTimelineSVG(currentElement.querySelector('svg'), currentElement, item.data);
                                        }
                                    }
                                } catch(e) {
                                    console.error("Error updating size:", e);
                                    isResizing = false;
                                }
                            }
                        }

                        if (isPanning) {
                            if (cursorMode === 'move') {
                                board.style.cursor = 'grab';
                            }
                        }

                        isPanning = false;
                        isDragging = false;
                        isDrawingLine = false;
                        isSelecting = false;
                        isDrawingFreehand = false;

                        currentElement = null;
                        lineStartIdentifier = null;
                        dragOffsets.clear();

                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    }


                    document.addEventListener('mousemove', (e) => {

                        lastMousePos = { x: e.clientX, y: e.clientY };

                        if (cursorMode !== 'draw' || !canEdit) {
                            eraserCursor.style.display = 'none';
                            pencilCursor.style.display = 'none';
                            return;
                        }


                        const boardRect = board.getBoundingClientRect();
                        const isInsideBoard = e.clientX >= boardRect.left &&
                                            e.clientX <= boardRect.right &&
                                            e.clientY >= boardRect.top &&
                                            e.clientY <= boardRect.bottom;

                        if (isInsideBoard) {
                            if (drawTool === 'eraser') {
                                eraserCursor.style.display = 'block';
                                eraserCursor.style.left = `${e.clientX}px`;
                                eraserCursor.style.top = `${e.clientY}px`;
                            } else {
                                pencilCursor.style.display = 'block';
                                pencilCursor.style.left = `${e.clientX}px`;
                                pencilCursor.style.top = `${e.clientY}px`;
                            }
                        } else {
                            eraserCursor.style.display = 'none';
                            pencilCursor.style.display = 'none';
                        }
                    });

                    function getElementCenter(element) {
                        const computedStyle = window.getComputedStyle(element);
                        const worldLeft = parseFloat(computedStyle.left);
                        const worldTop = parseFloat(computedStyle.top);

                        const worldWidth = parseFloat(computedStyle.width);
                        const worldHeight = parseFloat(computedStyle.height);

                        return {
                            x: worldLeft + worldWidth / 2,
                            y: worldTop + worldHeight / 2
                        };
                    }

                    function showLineControlPanel(lineData) {
                        const boardRect = board.getBoundingClientRect();

                        let panelX, panelY;
                        if (lastMousePos.x > 0) {
                            panelX = lastMousePos.x - boardRect.left - 110;
                            panelY = lastMousePos.y - boardRect.top - 60;
                        } else {

                            const midPoint = getLineMidpoint(lineData.id);
                            if (midPoint) {
                                const screenPos = worldToScreen(midPoint.x, midPoint.y);
                                panelX = screenPos.x - boardRect.left - 110;
                                panelY = screenPos.y - boardRect.top - 60;
                            } else {
                                panelX = 100; panelY = 100;
                            }
                        }
                        const panelHeight = lineControlPanel.offsetHeight || 180;
                        const boardHeight = board.offsetHeight;

                        panelX = Math.max(10, Math.min(panelX, board.offsetWidth - 230));
                        panelY = Math.max(10, Math.min(panelY, boardHeight - panelHeight - 10));

                        lineControlPanel.style.display = 'flex';
                        lineControlPanel.style.left = `${panelX}px`;
                        lineControlPanel.style.top = `${panelY}px`;

                        lineTypeSelect.value = lineData.type;
                        lineColorInput.value = lineData.color;
                        lineThicknessInput.value = lineData.thickness;

                        lineColorControl.style.display = 'none';
                        changeDirectionBtn.style.display = (lineData.type === 'arrow') ? 'block' : 'none';
                    }

                    function hideLineControlPanel() {
                        lineControlPanel.style.display = 'none';
                        selectedLine = null;
                        changeDirectionBtn.style.display = 'none';
                    }

                    async function deleteLine(lineId) {
                        if (!canEdit) return;
                        try {
                            await deleteDoc(doc(connectionsCol, lineId));
                        } catch (e) {
                            console.error("Error deleting line:", e);
                        }
                    }

                    lineTypeSelect.addEventListener('change', async (e) => {
                        if (!canEdit || !selectedLine) return;
                        try {
                            const lineRef = doc(connectionsCol, selectedLine.id);
                            await updateDoc(lineRef, { type: e.target.value });
                            changeDirectionBtn.style.display = (e.target.value === 'arrow') ? 'block' : 'none';
                        } catch (err) {
                            console.error("Error updating line type:", err);
                        }
                    });

                    lineColorInput.addEventListener('input', async (e) => {
                        if (!canEdit || !selectedLine) return;
                         try {
                            const lineRef = doc(connectionsCol, selectedLine.id);
                            await updateDoc(lineRef, { color: e.target.value });
                        } catch (err) {
                            console.error("Error updating line color:", err);
                        }
                    });

                    lineThicknessInput.addEventListener('input', async (e) => {
                        if (!canEdit || !selectedLine) return;
                         try {
                            const lineRef = doc(connectionsCol, selectedLine.id);
                            await updateDoc(lineRef, { thickness: parseFloat(e.target.value) });
                        } catch (err) {
                            console.error("Error updating line thickness:", err);
                        }
                    });

                    connectFromLineBtn.addEventListener('click', (e) => {
                        if (!canEdit || !selectedLine) return;
                        startDrawingLine(e, selectedLine.id, 'solid');
                    });

                    changeDirectionBtn.addEventListener('click', async () => {
                        if (!canEdit || !selectedLine) return;
                        try {
                            const lineRef = doc(connectionsCol, selectedLine.id);
                            await updateDoc(lineRef, {
                                startId: selectedLine.endId,
                                endId: selectedLine.startId
                            });
                        } catch (err) {
                            console.error("Error changing line direction:", err);
                        }
                    });

                    deleteLineBtn.addEventListener('click', () => {
                        if (!canEdit || !selectedLine) return;
                        deleteLine(selectedLine.id);
                        hideLineControlPanel();
                    });

                    closeLinePanelBtn.addEventListener('click', hideLineControlPanel);

                    lineControlPanel.querySelectorAll('button, input, select').forEach(el => {
                        el.addEventListener('mousedown', (e) => e.stopPropagation());
                    });

                    itemMenu.addEventListener('mousedown', (e) => e.stopPropagation());

                    itemMenuFontBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isHidden = fontSubmenu.style.display === 'none' || fontSubmenu.style.display === '';
                        fontSubmenu.style.display = isHidden ? 'flex' : 'none';
                        connectionSubmenu.style.display = 'none';

                        if (isHidden) {
                            const subMenuRect = fontSubmenu.getBoundingClientRect();
                            const boardRect = board.getBoundingClientRect();

                            if (subMenuRect.bottom > boardRect.bottom) {
                                const itemMenuRect = itemMenu.getBoundingClientRect();
                                const overflowAmount = subMenuRect.bottom - boardRect.bottom;
                                const currentTop = itemMenuRect.top - boardRect.top;

                                const newTop = currentTop - overflowAmount - 10;

                                itemMenu.style.top = `${Math.max(10, newTop)}px`;
                            }
                        }
                    });

                    fontSubmenu.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (!canEdit || e.target.tagName !== 'BUTTON' || !currentItemForMenu) return;

                        const font = e.target.dataset.font;

                        try {
                            const itemRef = doc(itemsCol, currentItemForMenu.id);
                            await updateDoc(itemRef, { fontFamily: font });
                        } catch (err) {
                            console.error("Error updating font family:", err);
                        }

                        hideItemMenu();
                    });

                    itemMenuConnectBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isHidden = connectionSubmenu.style.display === 'none' || connectionSubmenu.style.display === '';
                        connectionSubmenu.style.display = isHidden ? 'flex' : 'none';
                        fontSubmenu.style.display = 'none';

                        if (isHidden) {
                            const subMenuRect = connectionSubmenu.getBoundingClientRect();
                            const boardRect = board.getBoundingClientRect();

                            if (subMenuRect.bottom > boardRect.bottom) {
                                const itemMenuRect = itemMenu.getBoundingClientRect();
                                const overflowAmount = subMenuRect.bottom - boardRect.bottom;
                                const currentTop = itemMenuRect.top - boardRect.top;

                                const newTop = currentTop - overflowAmount - 10;

                                itemMenu.style.top = `${Math.max(10, newTop)}px`;
                            }
                        }
                    });

                    itemMenuDeleteNodeBtn.addEventListener('click', (e) => {
                        if (!canEdit) return;
                        e.stopPropagation();
                        if (currentItemForMenu) {
                            deleteItem(currentItemForMenu.id, true);
                        }
                        hideItemMenu();
                    });

                    itemMenuBringFrontBtn.addEventListener('click', async (e) => {
                        if (!canEdit) return;
                        e.stopPropagation();
                        if (currentItemForMenu) {
                            const newZIndex = ++zIndexCounter;
                            try {
                                const itemRef = doc(itemsCol, currentItemForMenu.id);
                                await updateDoc(itemRef, { zIndex: newZIndex });
                            } catch(err) {
                                console.error("Error bringing to front:", err);
                            }
                        }
                        hideItemMenu();
                    });

                    itemMenuSendBackBtn.addEventListener('click', async (e) => {
                        if (!canEdit) return;
                        e.stopPropagation();
                        if (currentItemForMenu) {
                             try {
                                const itemRef = doc(itemsCol, currentItemForMenu.id);
                                await updateDoc(itemRef, { zIndex: 9 });
                            } catch(err) {
                                console.error("Error sending to back:", err);
                            }
                        }
                        hideItemMenu();
                    });

                    submenuSolid.addEventListener('click', (e) => startDrawingLine(e, currentItemForMenu.id, 'solid'));
                    submenuDotted.addEventListener('click', (e) => startDrawingLine(e, currentItemForMenu.id, 'dotted'));
                    submenuArrow.addEventListener('click', (e) => startDrawingLine(e, currentItemForMenu.id, 'arrow'));

                    boardMenu.querySelectorAll('button, label').forEach(el => {
                        el.addEventListener('mousedown', (e) => e.stopPropagation());
                    });

                    setCursorMode('move');

                    function setEditingPermissions(canUserEdit) {
                        canEdit = canUserEdit;


                        if (canEdit) {
                            document.body.classList.remove('read-only');
                        } else {
                            document.body.classList.add('read-only');
                            document.body.classList.remove('is-owner');
                            userRoleDisplay.textContent = `Role: Viewer`;
                            userRoleDisplay.className = "ml-4 font-bold text-gray-400";
                            setCursorMode('move');
                            return;
                        }


                        if (currentUserRole === 'owner') {
                             document.body.classList.add('is-owner');
                             userRoleDisplay.textContent = `Role: Owner`;
                             userRoleDisplay.className = "ml-4 font-bold text-red-400";


                             if (isBoardOwner) {
                                userRoleDisplay.textContent = `Role: Owner`;
                             }
                        } else if (currentUserRole === 'editor') {
                             document.body.classList.remove('is-owner');
                             userRoleDisplay.textContent = `Role: Editor`;
                             userRoleDisplay.className = "ml-4 font-bold text-blue-400";
                        }
                    }

            async function setupPresence() {
                if (presenceInterval) clearInterval(presenceInterval);

                const userRef = doc(usersCol, userId);
                const nicknameRef = doc(nicknamesCol, userNickname);

                await setDoc(userRef, {
                    nickname: userNickname,
                    role: currentUserRole,
                    last_seen: serverTimestamp(),
                    kicked: false
                }, { merge: true });

                await setDoc(nicknameRef, {
                    last_seen: serverTimestamp(),
                    currentUserId: userId
                }, { merge: true });

                presenceInterval = setInterval(() => {
                    setDoc(userRef, {
                        last_seen: serverTimestamp(),
                        nickname: userNickname
                    }, { merge: true });

                    setDoc(nicknameRef, {
                        last_seen: serverTimestamp()
                    }, { merge: true });
                }, 15000);

                let isCleaningUp = false;
                const cleanup = async () => {
                    if (isCleaningUp) return;
                    isCleaningUp = true;
                    
                    isVoluntarilyLeaving = true;
                    console.log("Cleanup triggered, setting isVoluntarilyLeaving=true");

                    if (presenceInterval) clearInterval(presenceInterval);
                    presenceInterval = null;

                    try {
                        // We no longer delete the user doc, just let last_seen go stale
                        // if (userRef) {
                        //     const userSnap = await getDoc(userRef);
                        //     if (userSnap.exists() && !userSnap.data().kicked) {
                        //         await deleteDoc(userRef);
                        //     }
                        // }

                        if (nicknameRef) {
                            await setDoc(nicknameRef, {
                                currentUserId: deleteField(),
                                last_seen: serverTimestamp()
                            }, { merge: true });
                        }
                    } catch (e) {
                        console.error("Error during cleanup:", e);
                    }
                };

                window.addEventListener('beforeunload', cleanup);
                window.addEventListener('pagehide', cleanup);

                return cleanup;
            }

                    let currentCleanupFunction = () => {};

            leaveRoomBtn.addEventListener('click', () => {
                leaveRoom(false);
            });

            async function leaveRoom(isKicked = false) {
                
                if (isKicked) {
                    console.log("leaveRoom called (kicked=true)");
                    
                    detachListeners();

                    items.forEach(item => item.el.remove());
                    items.clear();
                    connections.forEach(conn => {
                        conn.lineEl.remove();
                        conn.hitBoxEl.remove();
                        if (conn.arrowHead) conn.arrowHead.remove();
                    });
                    connections = [];
                    drawingGroup.innerHTML = '';
                    itemConnectionsMap.clear();

                    document.querySelector('header').style.display = 'none';
                    document.querySelector('footer').style.display = 'none';
                    toggleSidebarBtn.style.display = 'none';
                    document.getElementById('center-board-btn').style.display = 'none';

                    currentBoardId = null;
                    isBoardOwner = false;
                    canEdit = false;

                    showLobby();
                    
                    showModalAlert(kickedModalOverlay, kickedOkBtn, {
                    });

                } else {
                    console.log("leaveRoom called (kicked=false)");
                    isVoluntarilyLeaving = true;

                    if (currentCleanupFunction) {
                        window.removeEventListener('beforeunload', currentCleanupFunction);
                        window.removeEventListener('pagehide', currentCleanupFunction);
                        await currentCleanupFunction();
                    }
                    currentCleanupFunction = () => {};

                    detachListeners();

                    items.forEach(item => item.el.remove());
                    items.clear();
                    connections.forEach(conn => {
                        conn.lineEl.remove();
                        conn.hitBoxEl.remove();
                        if (conn.arrowHead) conn.arrowHead.remove();
                    });
                    connections = [];
                    drawingGroup.innerHTML = '';
                    itemConnectionsMap.clear();

                    document.querySelector('header').style.display = 'none';
                    document.querySelector('footer').style.display = 'none';
                    toggleSidebarBtn.style.display = 'none';
                    document.getElementById('center-board-btn').style.display = 'none';

                    currentBoardId = null;
                    isBoardOwner = false;
                    canEdit = false;

                    showLobby();
                    
                    setTimeout(() => { 
                        isVoluntarilyLeaving = false; 
                        console.log("isVoluntarilyLeaving flag reset");
                    }, 1500);
                }
            }

            async function loadBoard(boardId, token = null, forceReload = false) {
                isSwitchingRooms = true;
                console.log("loadBoard started, isSwitchingRooms=true");

                if (!boardId || boardId.trim() === "") {
                    boardId = "default-board";
                }

                if (unsubscribeBoardsList) {
                    unsubscribeBoardsList();
                    unsubscribeBoardsList = null;
                }

                const sanitizedBoardId = boardId.trim().replace(/[^a-zA-Z-0-9-]/g, '_');
                boardNameDisplay.textContent = `Loading: ${sanitizedBoardId}...`;

                lobbyModalOverlay.style.display = 'none';

                const boardPasswordError = document.getElementById('board-password-error');
                const boardPasswordInputEl = document.getElementById('board-password-input');

                if (userId) {
                    const usersColForCheck = collection(db, 'artifacts', appId, 'public', 'data', 'boards', sanitizedBoardId, 'users');
                    const userRefForCheck = doc(usersColForCheck, userId);
                    const userSnap = await getDoc(userRefForCheck);

                    if (userSnap.exists() && userSnap.data().kicked === true) {
                        console.log("Kicked user attempting to rejoin. Access denied.");

                        await showModalAlert(errorModalOverlay, errorModalOkBtn, {
                            title: "Access Denied",
                            titleEl: errorModalTitle,
                            text: "You have been kicked from this room and cannot rejoin.",
                            textEl: errorModalText
                        });

                        showLobby();
                        return;
                    }
                }


                        try {
                            const boardMetaRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', sanitizedBoardId);
                            const boardSnap = await getDoc(boardMetaRef);

                            let boardOwnerId = null;


                            if (boardSnap.exists()) {
                                const boardData = boardSnap.data();
                                boardOwnerId = boardData.ownerId;

                                if (boardData.hasPassword) {
                                    let passwordCorrect = false;


                                    while (!passwordCorrect) {

                                        boardPasswordError.style.display = 'none';
                                        boardPasswordError.textContent = '';
                                        boardPasswordInputEl.classList.remove('border-red-500', 'focus:ring-red-500');
                                        boardPasswordInputEl.classList.add('border-slate-600', 'focus:ring-indigo-500');

                                        const password = await showModalPrompt(
                                            boardPasswordModalOverlay,
                                            boardPasswordInput,
                                            submitBoardPasswordBtn,
                                            cancelBoardPasswordBtn,
                                            {
                                                text: `The board <strong id="board-password-name" class="text-white">${sanitizedBoardId}</strong> is password protected.`,
                                                textEl: boardPasswordModalOverlay.querySelector('p'),
                                                dontHideOnSubmit: true
                                            }
                                        );

                                        if (password === null) {
                                            boardPasswordModalOverlay.style.display = 'none';
                                            boardPasswordError.style.display = 'none';
                                            boardPasswordInputEl.classList.remove('border-red-500', 'focus:ring-red-500');
                                            boardPasswordInputEl.classList.add('border-slate-600', 'focus:ring-indigo-500');
                                            boardNameDisplay.textContent = `Board: ${currentBoardId}`;
                                            if(currentBoardId && currentBoardId !== sanitizedBoardId) {

                                            } else if (!currentBoardId) {

                                            }
                                            showLobby();
                                            return;
                                        }

                                        const hashedInput = await sha512(password);
                                        if (hashedInput === boardData.password) {
                                            passwordCorrect = true;
                                            boardPasswordError.style.display = 'none';
                                            boardPasswordInputEl.classList.remove('border-red-500', 'focus:ring-red-500');
                                            boardPasswordInputEl.classList.add('border-slate-600', 'focus:ring-indigo-500');
                                        } else {

                                            boardPasswordError.textContent = 'Wrong password';
                                            boardPasswordError.style.display = 'block';
                                            boardPasswordInputEl.classList.remove('border-slate-600', 'focus:ring-indigo-500');
                                            boardPasswordInputEl.classList.add('border-red-500', 'focus:ring-red-500');

                                        }
                                    }
                                    boardPasswordModalOverlay.style.display = 'none';
                                }
                            } else {
                                const newPassword = await showModalPrompt(
                                    newBoardPasswordModalOverlay,
                                    newBoardPasswordInput,
                                    submitNewBoardBtn,
                                    cancelNewBoardBtn,
                                    {
                                        text: `You are creating the board <strong id="new-board-name" class="text-white">${sanitizedBoardId}</strong>.`,
                                        textEl: newBoardPasswordModalOverlay.querySelector('p')
                                    }
                                );

                                if (newPassword === null) {
                                    boardNameDisplay.textContent = `Board: ${currentBoardId}`;
                                    if (!currentBoardId) {
                                        showLobby();
                                    }
                                    return;
                                }


                                let passwordData = {
                                    hasPassword: false,
                                    owner: userNickname,
                                    ownerId: userId,
                                    hidden: false
                                };
                                boardOwnerId = userId;

                                if (newPassword && newPassword.trim() !== "") {
                                    passwordData.hasPassword = true;
                                    passwordData.password = await sha512(newPassword);
                                }
                                await setDoc(boardMetaRef, passwordData);
                            }



                            currentBoardId = sanitizedBoardId;
                            boardRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', currentBoardId);
                            usersCol = collection(boardRef, 'users');
                            invitesCol = collection(boardRef, 'invites');

                            const userRef = doc(usersCol, userId);
                            const userSnap = await getDoc(userRef);

                            let intendedRole = userSnap.exists() ? userSnap.data().role : 'viewer';



                            const ownerHash = await sha512(userNickname);
                            if (boardOwnerId === userId || boardOwnerId === ownerHash) {
                                isBoardOwner = true;
                                intendedRole = 'owner';
                            } else {
                                isBoardOwner = false;
                            }

                            let inviteConsumed = false;

                            if (token && intendedRole !== 'owner') {
                                const inviteRef = doc(invitesCol, token);
                                const inviteSnap = await getDoc(inviteRef);

                                if (inviteSnap.exists() && inviteSnap.data().type === 'editor') {
                                    intendedRole = 'editor';
                                    await deleteDoc(inviteRef);
                                    inviteConsumed = true;
                                } else if (token) {
                                    showModalAlert(invalidInviteModalOverlay, invalidInviteOkBtn);
                                    inviteConsumed = true;
                                }
                            }

                            currentUserRole = intendedRole;

                            setEditingPermissions(currentUserRole === 'owner' || currentUserRole === 'editor');

                            boardNameDisplay.textContent = `Board: ${currentBoardId}`;
                            boardNameInput.value = "";
                            
                            currentCleanupFunction = await setupPresence(); 

                            setupFirestoreListeners(currentBoardId);

                            isSwitchingRooms = false;
                            console.log("isSwitchingRooms flag reset");

                            document.querySelector('header').style.display = 'flex';
                            document.querySelector('footer').style.display = 'flex';
                            toggleSidebarBtn.style.display = 'block';
                            document.getElementById('center-board-btn').style.display = 'block';

                            if (inviteConsumed) {
                                window.history.replaceState({}, document.title, `${window.location.pathname}?board=${currentBoardId}`);
                            }

                        } catch (e) {
                            console.error("Error loading board:", e);
                            boardNameDisplay.textContent = `Board: ${currentBoardId}`;
                        }
                    }


                    changeNicknameBtn.addEventListener('click', async () => {
                        let newNickname = await showModalPrompt(
                            nicknameModalOverlay,
                            nicknameInput,
                            saveNicknameBtn,
                            cancelNicknameBtn,
                            {
                                title: "Change Nickname",
                                titleEl: nicknameModalTitle,
                                text: "What would you like to be called?",
                                textEl: nicknameModalOverlay.querySelector('p'),
                                defaultValue: userNickname,
                                placeholder: "Enter your nickname...",
                                closeOnOverlayClick: false
                            }
                        );

                        if (newNickname) {
                            newNickname = newNickname.trim();

                            if (newNickname !== "" && newNickname !== userNickname) {

                                const oldNickname = userNickname;

                                const newNicknameRef = doc(nicknamesCol, newNickname);
                                const newNicknameSnap = await getDoc(newNicknameRef);
                                let isTaken = false;

                                if (newNicknameSnap.exists()) {
                                    const nicknameData = newNicknameSnap.data();


                                    if (nicknameData.password) {
                                        const passwordValid = await validateNicknamePassword(newNickname, newNicknameSnap);
                                        if (!passwordValid) {
                                            return;
                                        }
                                    }


                                    if (nicknameData.currentUserId && nicknameData.currentUserId !== userId) {
                                        const lastSeen = nicknameData.last_seen?.toDate ? nicknameData.last_seen.toDate() : null;
                                        const oneMinuteAgo = new Date(Date.now() - 60000);

                                        if (lastSeen && lastSeen < oneMinuteAgo) {

                                            isTaken = false;
                                        } else {

                                            isTaken = true;
                                        }
                                    }
                                }

                                if (isTaken) {
                                    await showModalAlert(
                                        errorModalOverlay,
                                        errorModalOkBtn,
                                        {
                                            title: "Nickname In Use",
                                            titleEl: errorModalTitle,
                                            text: `The nickname "${newNickname}" is already in use by someone else. Please choose a different nickname.`,
                                            textEl: errorModalText
                                        }
                                    );
                                    return;
                                }




                                const batch = writeBatch(db);


                                const oldNicknameRef = doc(nicknamesCol, userNickname);
                                batch.update(oldNicknameRef, {
                                    currentUserId: deleteField(),
                                    last_seen: serverTimestamp()
                                });


                                batch.set(newNicknameRef, {
                                    currentUserId: userId,
                                    last_seen: serverTimestamp()
                                }, { merge: true });

                                await batch.commit();

                                await updateNicknameInFirestore(newNickname);


                                try {
                                    console.log(`Updating board ownership from '${oldNickname}' to '${newNickname}' for ownerId '${userId}'...`);
                                    const boardsCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'boards');


                                    const q = query(boardsCollectionRef, where('ownerId', '==', userId));
                                    const querySnapshot = await getDocs(q);

                                    if (!querySnapshot.empty) {
                                        const updateBatch = writeBatch(db);
                                        let updatedCount = 0;
                                        querySnapshot.forEach((docSnap) => {

                                            if (docSnap.data().owner === oldNickname) {
                                                updateBatch.update(docSnap.ref, { owner: newNickname });
                                                updatedCount++;
                                            }
                                        });

                                        if (updatedCount > 0) {
                                            await updateBatch.commit();
                                            console.log(`Updated 'owner' field for ${updatedCount} boards.`);
                                        } else {
                                            console.log("No boards found with matching old nickname to update.");
                                        }
                                    } else {
                                        console.log("This user does not own any boards (by ownerId), no 'owner' field to update.");
                                    }

                                } catch (e) {
                                    console.error("Error updating 'owner' nickname in boards collection:", e);
                                }

                                localStorage.setItem(NICKNAME_STORAGE_KEY, userNickname);
                            }
                        }
                    });


                    nicknamePasswordChangeInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            submitNicknamePasswordSettingsBtn.click();
                        }
                    });


                    passwordSettingsBtn.addEventListener('click', () => {
                        manageNicknameName.textContent = userNickname;
                        nicknamePasswordChangeInput.value = '';
                        removeNicknamePasswordCheckbox.checked = false;
                        manageNicknamePasswordModalOverlay.style.display = 'flex';
                    });

                    manageNicknamePasswordModalOverlay.addEventListener('click', (e) => {
                        if (e.target === manageNicknamePasswordModalOverlay) {

                        }
                    });


                    submitNicknamePasswordSettingsBtn.addEventListener('click', async () => {
                        submitNicknamePasswordSettingsBtn.disabled = true;
                        submitNicknamePasswordSettingsBtn.textContent = 'Saving...';

                        try {
                            const nicknameRef = doc(nicknamesCol, userNickname);
                            const newPassword = nicknamePasswordChangeInput.value;

                            if (removeNicknamePasswordCheckbox.checked) {
                                await updateDoc(nicknameRef, {
                                    password: deleteField()
                                });
                            } else if (newPassword && newPassword.trim() !== "") {
                                const hashedPassword = await sha512(newPassword);
                                await updateDoc(nicknameRef, {
                                    password: hashedPassword
                                });
                            }

                            manageNicknamePasswordModalOverlay.style.display = 'none';

                        } catch (e) {
                            console.error("Error updating nickname password:", e);
                        } finally {
                            submitNicknamePasswordSettingsBtn.disabled = false;
                            submitNicknamePasswordSettingsBtn.textContent = 'Save';
                        }
                    });

                    cancelNicknamePasswordSettingsBtn.addEventListener('click', () => {
                        manageNicknamePasswordModalOverlay.style.display = 'none';
                    });


                    async function showLobby() {
                        document.querySelector('header').style.display = 'none';
                        document.querySelector('footer').style.display = 'none';
                        toggleSidebarBtn.style.display = 'none';
                        document.getElementById('center-board-btn').style.display = 'none';
                        
                        if (auth.currentUser && auth.currentUser.isAnonymous) {
                            logoutGuestBtn.style.display = 'block';
                        } else {
                            logoutGuestBtn.style.display = 'none';
                        }

                        lobbyModalOverlay.style.display = 'flex';
                        lobbyRoomList.innerHTML = `<li>Loading rooms...</li>`;

                        if (unsubscribeBoardsList) {
                            unsubscribeBoardsList();
                        }

                        try {
                            const boardsCollectionRef = collection(db, 'artifacts', appId, 'public', 'data', 'boards');

                            unsubscribeBoardsList = onSnapshot(boardsCollectionRef, (snapshot) => {
                                allBoards = [];
                                snapshot.docs.forEach(doc => {
                                    const data = doc.data()
                                    if (doc.id !== 'default-board' && data.hidden !== true) {
                                        allBoards.push({ id: doc.id, hasPassword: data.hasPassword || false });
                                    }
                                });

                                allBoards.sort((a, b) => a.id.localeCompare(b.id));

                                renderRoomList();
                            }, (error) => {
                                console.error("Error fetching board list:", error);
                                lobbyRoomList.innerHTML = `<li>Error loading rooms.</li>`;
                            });

                        } catch (e) {
                            console.error("Error setting up board list snapshot:", e);
                            lobbyRoomList.innerHTML = `<li>Error loading rooms.</li>`;
                        }
                    }

                    function renderRoomList() {
                        const searchTerm = roomSearchInput.value.toLowerCase();
                        const filteredBoards = allBoards.filter(board => board.id.toLowerCase().includes(searchTerm));

                        lobbyRoomList.innerHTML = '';

                        if (filteredBoards.length === 0) {
                            const li = document.createElement('li');
                            li.className = 'no-rooms';
                            li.textContent = 'No rooms found.';
                            lobbyRoomList.appendChild(li);
                            return;
                        }

                        filteredBoards.forEach(room => {
                            const li = document.createElement('li');
                            li.innerHTML = `
                                <button type="button" class="lobby-room-item" data-room-id="${room.id}">
                                    <div class="flex items-center gap-3 overflow-hidden">
                                        ${room.hasPassword ?
                                            `<svg class="h-5 w-5 text-yellow-500 flex-shrink-0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 1a4.5 4.5 0 0 0-4.5 4.5V9H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2h-.5V5.5A4.5 4.5 0 0 0 10 1Zm3 8V5.5a3 3 0 1 0-6 0V9h6Z" clip-rule="evenodd" /></svg>`
                                            :
                                            `<svg class="h-5 w-5 text-slate-500 flex-shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5V6.75a4.5 4.5 0 1 1 9 0v3.75M3.75 21.75h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H3.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" /></svg>`
                                        }
                                        <span class="font-medium text-lg room-name truncate transition-colors">${room.id}</span>
                                    </div>
                                    <div class="flex items-center gap-2 flex-shrink-0">
                                        <svg class="h-5 w-5 text-slate-400 join-arrow opacity-0 -translate-x-1 transition-all duration-200" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd" d="M3 10a.75.75 0 0 1 .75-.75h10.638L10.23 5.29a.75.75 0 1 1 1.04-1.08l5.5 5.25a.75.75 0 0 1 0 1.08l-5.5 5.25a.75.75 0 1 1-1.04-1.08l4.158-3.96H3.75A.75.75 0 0 1 3 10Z" clip-rule="evenodd" />
                                        </svg>
                                    </div>
                                </button>
                            `;
                            lobbyRoomList.appendChild(li);
                        });
                    }

                    lobbyRoomList.addEventListener('click', (e) => {
                        const roomItem = e.target.closest('.lobby-room-item');
                        if (roomItem && roomItem.dataset.roomId) {
                            onLobbyRoomClick(roomItem.dataset.roomId);
                        }
                    });

                    async function onCreateRoomAttempt() {
                        const roomName = newRoomNameInput.value.trim();
                        if (!roomName) return;

                        const sanitizedRoomId = roomName.replace(/[^a-zA-Z-0-9-]/g, '_');
                        if (sanitizedRoomId === 'default-board') {
                            showModalAlert(errorModalOverlay, errorModalOkBtn, {
                                title: "Invalid Name",
                                titleEl: errorModalTitle,
                                text: "'default-board' is a reserved name. Please choose another.",
                                textEl: errorModalText
                            });
                            return;
                        }

                        let existingRoomSnap = null;
                        try {
                            const boardMetaRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', sanitizedRoomId);
                            existingRoomSnap = await getDoc(boardMetaRef);
                        } catch (e) {
                            console.error("Erro ao verificar se a sala existe:", e);
                            showModalAlert(errorModalOverlay, errorModalOkBtn, {
                                title: "Erro de Rede",
                                titleEl: errorModalTitle,
                                text: "No foi possvel verificar a sala. Tente novamente.",
                                textEl: errorModalText
                            });
                            return;
                        }

                        if (existingRoomSnap.exists()) {
                            const existingRoomData = existingRoomSnap.data();
                            pendingRoomName = existingRoomSnap.id;
                            pendingHasPassword = existingRoomData.hasPassword;
                            roomExistsText.innerHTML = `The room <strong class="text-white">${existingRoomSnap.id}</strong> already exists. Would you like to join it?`;
                            roomExistsModalOverlay.style.display = 'flex';
                        } else {
                            const newPassword = await showModalPrompt(
                                newBoardPasswordModalOverlay,
                                newBoardPasswordInput,
                                submitNewBoardBtn,
                                cancelNewBoardBtn,
                                {
                                    text: `You are creating the board <strong id="new-board-name" class="text-white">${sanitizedRoomId}</strong>.`,
                                    textEl: newBoardPasswordModalOverlay.querySelector('p')
                                }
                            );

                            if (newPassword === null) {
                                document.getElementById('new-board-hidden-checkbox').checked = false;
                                return;
                            }

                            const isHidden = document.getElementById('new-board-hidden-checkbox').checked;

                            const boardMetaRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', sanitizedRoomId);
                            let boardData = {
                                hasPassword: false,
                                owner: userNickname,
                                ownerId: userId,
                                hidden: isHidden
                            };

                            if (newPassword && newPassword.trim() !== "") {
                                boardData.hasPassword = true;
                                boardData.password = await sha512(newPassword);
                            }

                            try {
                                await setDoc(boardMetaRef, boardData);
                                document.getElementById('new-board-hidden-checkbox').checked = false;
                                loadBoard(sanitizedRoomId);
                            } catch (e) {
                                console.error("Error creating new board:", e);
                                showModalAlert(errorModalOverlay, errorModalOkBtn, {
                                    title: "Error",
                                    titleEl: errorModalTitle,
                                    text: "Could not create the board. Please try again.",
                                    textEl: errorModalText
                                });
                            }
                        }
                    }

                    roomSearchInput.addEventListener('input', renderRoomList);
                    createRoomBtn.addEventListener('click', onCreateRoomAttempt);

                    newRoomNameInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            createRoomBtn.click();
                        }
                    });

                    lobbyModalOverlay.addEventListener('click', (e) => {
                        if (e.target === lobbyModalOverlay) {

                        }
                    });

                    cancelJoinRoomBtn.addEventListener('click', () => {
                        roomExistsModalOverlay.style.display = 'none';
                    });

                    confirmJoinRoomBtn.addEventListener('click', () => {
                        roomExistsModalOverlay.style.display = 'none';
                        if (pendingRoomName) {
                            onLobbyRoomClick(pendingRoomName);
                        }
                    });

                    lobbyRoomList.addEventListener('click', (e) => {
                        const roomItem = e.target.closest('.lobby-room-item');
                        if (roomItem && roomItem.dataset.roomId) {
                            onLobbyRoomClick(roomItem.dataset.roomId);
                        }
                    });

                    function onLobbyRoomClick(roomId) {
                        loadBoard(roomId);
                    }

                    roomSearchInput.addEventListener('input', renderRoomList);
                    createRoomBtn.addEventListener('click', onCreateRoomAttempt);

                    newRoomNameInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            createRoomBtn.click();
                        }
                    });

                    lobbyModalOverlay.addEventListener('click', (e) => {
                        if (e.target === lobbyModalOverlay) {

                        }
                    });

                    cancelJoinRoomBtn.addEventListener('click', () => {
                        roomExistsModalOverlay.style.display = 'none';
                    });

                    confirmJoinRoomBtn.addEventListener('click', () => {
                        roomExistsModalOverlay.style.display = 'none';
                        if (pendingRoomName) {
                            onLobbyRoomClick(pendingRoomName);
                        }
                    });

                    function toggleSidebar() {
                        sidebarMenu.classList.toggle('sidebar-open');
                        toggleSidebarBtn.classList.toggle('sidebar-button-shifted');
                    }
                    
                    function panToItem(itemId) {
                        const item = items.get(itemId);
                        if (!item) return;
                    
                        const itemData = item.data;
                        const itemEl = item.el;

                        const itemRect = itemEl.getBoundingClientRect();
                        const itemWidth = parseFloat(itemData.width) || (itemRect.width / scale);
                        const itemHeight = (itemData.height && itemData.height !== 'auto') ? parseFloat(itemData.height) : (itemRect.height / scale);
                        
                        const itemX = parseFloat(itemData.x);
                        const itemY = parseFloat(itemData.y);

                        const itemCenterX = itemX + itemWidth / 2;
                        const itemCenterY = itemY + itemHeight / 2;

                        const boardRect = board.getBoundingClientRect();
                        const viewWidth = boardRect.width;
                        const viewHeight = boardRect.height;

                        const targetScale = 1.2;
                        scale = targetScale;

                        translateX = (viewWidth / 2) - (itemCenterX * targetScale);
                        translateY = (viewHeight / 2) - (itemCenterY * targetScale);

                        updateTransform();

                        itemEl.classList.add('selected');
                        setTimeout(() => {
                            if (!selectedItems.has(itemEl.id)) {
                                itemEl.classList.remove('selected');
                            }
                        }, 1000);
                    }
                    
                    function renderSidebarList() {
                        const searchTerm = sidebarSearchInput.value.toLowerCase().trim();
                        const searchWords = searchTerm.split(/\s+/).filter(word => word.length > 0);

                        sidebarItemList.innerHTML = '';
                        let itemCount = 0;

                        sidebarItemCache.forEach((data, id) => {
                            let isMatch = false;

                            if (searchWords.length === 0) {
                                isMatch = true;
                            } else {
                                let contentToSearch = '';
                                if (data.type === 'note') {
                                    contentToSearch = (data.content || '').toLowerCase();
                                } else if (data.type === 'image') {
                                    contentToSearch = (data.caption && data.caption !== 'Click to add caption...') 
                                                    ? data.caption.toLowerCase() 
                                                    : '';
                                }

                                if (contentToSearch) {
                                    isMatch = searchWords.every(word => contentToSearch.includes(word));
                                }
                            }

                            if (!isMatch) {
                                return;
                            }
                            
                            itemCount++;
                            const li = document.createElement('div');
                            li.className = 'sidebar-item';
                            li.dataset.itemId = id;
                            
                            let previewHTML = '';
                            let contentText = '';
                
                            if (data.type === 'note') {
                                previewHTML = `
                                    <div class="preview preview-icon">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                          <path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                        </svg>
                                    </div>
                                `;
                                contentText = (data.content && data.content.length > 15) 
                                              ? data.content.substring(0, 15) + '...' 
                                              : (data.content || 'Nota vazia');
                            } else if (data.type === 'image') {
                                previewHTML = `
                                    <div class="preview">
                                        <img src=${data.content} alt="Preview" class="preview-img">
                                    </div>
                                `;
                                contentText = (data.caption && data.caption !== 'Click to add caption...') 
                                              ? data.caption 
                                              : 'Imagem';
                                if (contentText.length > 15) {
                                    contentText = contentText.substring(0, 15) + '...';
                                }
                            }
                
                            li.innerHTML = `
                                ${previewHTML}
                                <span class="text-preview">${contentText.replace(/<[^>]*>?/gm, '')}</span>
                            `;
                            sidebarItemList.appendChild(li);
                        });

                        if (itemCount === 0) {
                            if (searchTerm !== '') {
                                sidebarItemList.innerHTML = `<p class="text-slate-400 text-sm text-center p-4">No items match your search.</p>`;
                            } else {
                                sidebarItemList.innerHTML = `<p class="text-slate-400 text-sm text-center p-4">Nenhuma nota ou imagem no quadro ainda.</p>`;
                            }
                        }
                    }
                    

                    toggleSidebarBtn.addEventListener('click', toggleSidebar);
                    closeSidebarBtn.addEventListener('click', toggleSidebar);
                    sidebarSearchInput.addEventListener('input', renderSidebarList);
                    
                    sidebarItemList.addEventListener('click', (e) => {
                        const itemEl = e.target.closest('.sidebar-item');
                        if (itemEl && itemEl.dataset.itemId) {
                            panToItem(itemEl.dataset.itemId);
                        }
                    });

                    centerBoardBtn.addEventListener('click', () => {
                        scale = 1;
                        translateX = 0;
                        translateY = 0;
                        updateTransform();
                    });

                    googleSignInBtn.addEventListener("click", async () => {
                        const provider = new GoogleAuthProvider();
                        try {
                            await signInWithPopup(auth, provider);
                        } catch (error) {
                            console.error("Google Sign-In Error:", error);
                            if (
                                error.code ===
                                "auth/account-exists-with-different-credential"
                            ) {
                                showModalAlert(
                                    errorModalOverlay,
                                    errorModalOkBtn,
                                    {
                                        title: "Login Error",
                                        titleEl: errorModalTitle,
                                        text: "An account already exists with the same email address but different sign-in credentials. Try signing in using the original method.",
                                        textEl: errorModalText,
                                    }
                                );
                            } else {
                                showModalAlert(
                                    errorModalOverlay,
                                    errorModalOkBtn,
                                    {
                                        title: "Login Error",
                                        titleEl: errorModalTitle,
                                        text: `An error occurred during Google sign-in: ${error.message}`,
                                        textEl: errorModalText,
                                    }
                                );
                            }
                        }
                    });

                    saveNicknameBtn.addEventListener("click", async () => {
                        const nickname = nicknameInput.value.trim();
                        if (nickname) {
                            localStorage.setItem(NICKNAME_STORAGE_KEY, nickname);
                            try {
                                await signInAnonymously(auth);
                            } catch (e) {
                                console.error("Anonymous sign-in error:", e);
                            }
                        } else {
                            nicknameInput.focus();
                        }
                    });

                    logoutGuestBtn.addEventListener('click', async () => {
                        try {
                            await auth.signOut();
                            // onAuthStateChanged will handle the rest (show login modal)
                        } catch (e) {
                            console.error("Error signing out:", e);
                        }
                    });

                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            nicknameModalOverlay.style.display = "none";
                            userId = user.uid;
                            console.log(
                                "User authenticated:",
                                userId,
                                "Anonymous:",
                                user.isAnonymous
                            );

                            let savedNickname =
                                localStorage.getItem(NICKNAME_STORAGE_KEY);
                            let finalNickname = null;

                            if (!user.isAnonymous) {
                                if (user.displayName) {
                                    finalNickname = user.displayName;
                                } else if (savedNickname) {
                                    finalNickname = savedNickname;
                                } else {
                                    finalNickname = `User_${userId.substring(
                                        0,
                                        4
                                    )}`;
                                }
                            } else {
                                if (savedNickname) {
                                    finalNickname = savedNickname;
                                }
                            }

                            if (finalNickname) {
                                userNickname = finalNickname;
                                localStorage.setItem(
                                    NICKNAME_STORAGE_KEY,
                                    userNickname
                                );
                            } else {
                                let newNickname = await showModalPrompt(
                                    nicknameModalOverlay,
                                    nicknameInput,
                                    saveNicknameBtn,
                                    cancelNicknameBtn,
                                    {
                                        title: "Choose Nickname",
                                        titleEl: nicknameModalTitle,
                                        text: "Please choose a nickname to continue.",
                                        textEl: nicknameModalOverlay.querySelector(
                                            "p"
                                        ),
                                        defaultValue: user.isAnonymous
                                            ? ""
                                            : user.email ||
                                              `User_${userId.substring(0, 4)}`,
                                        placeholder: "Type your nickname...",
                                        closeOnOverlayClick: false,
                                    }
                                );

                                if (
                                    !newNickname ||
                                    newNickname.trim() === ""
                                ) {
                                    newNickname = `User_${userId.substring(
                                        0,
                                        4
                                    )}`;
                                }
                                userNickname = newNickname.trim();
                                localStorage.setItem(
                                    NICKNAME_STORAGE_KEY,
                                    userNickname
                                );
                            }

                            await updateBoardOwnership(userNickname, userId);

                            const urlParams = new URLSearchParams(
                                window.location.search
                            );
                            const urlBoardId = urlParams.get('board') || null;
                            const urlInviteToken = urlParams.get('invite') || null;

                            if (urlBoardId && urlBoardId !== "default-board") {
                                loadBoard(urlBoardId, urlInviteToken);
                            } else {
                                showLobby();
                            }
                        } else {
                            console.log("No user signed in.");
                            // Detach any existing listeners from the previous session
                            detachListeners();

                            // Hide board UI
                            document.querySelector('header').style.display = 'none';
                            document.querySelector('footer').style.display = 'none';
                            toggleSidebarBtn.style.display = 'none';
                            document.getElementById('center-board-btn').style.display = 'none';
                            lobbyModalOverlay.style.display = 'none'; // Hide lobby just in case

                            // Show the login modal
                            nicknameModalOverlay.style.display = "flex";
                        }
                    });

                    const timelineDirections = {
                        horizontal: [
                            { value: 'l-r', text: 'Left-to-Right' },
                            { value: 'r-l', text: 'Right-to-Left' }
                        ],
                        vertical: [
                            { value: 't-b', text: 'Top-to-Bottom' },
                            { value: 'b-t', text: 'Bottom-to-Top' }
                        ]
                    };

                    timelineConfigModeSelect.addEventListener('change', (e) => {
                        const mode = e.target.value;
                        const directions = timelineDirections[mode];
                        
                        timelineConfigDirectionSelect.innerHTML = '';
                        directions.forEach(dir => {
                            const option = document.createElement('option');
                            option.value = dir.value;
                            option.textContent = dir.text;
                            timelineConfigDirectionSelect.appendChild(option);
                        });
                    });

                    function openTimelineConfigModal(itemEl) {
                        const itemData = items.get(itemEl.id)?.data;
                        if (!itemData) return;

                        currentTimelineConfigData = {
                            itemEl: itemEl,
                            itemId: itemEl.id,
                            events: JSON.parse(JSON.stringify(itemData.events || []))
                        };

                        timelineConfigColorInput.value = itemData.mainColor || '#3b82f6';
                        timelineConfigModeSelect.value = itemData.mode || 'horizontal';
                        
                        const directions = timelineDirections[itemData.mode || 'horizontal'];
                        timelineConfigDirectionSelect.innerHTML = '';
                        directions.forEach(dir => {
                            const option = document.createElement('option');
                            option.value = dir.value;
                            option.textContent = dir.text;
                            option.selected = (dir.value === itemData.direction);
                            timelineConfigDirectionSelect.appendChild(option);
                        });

                        renderTimelineEventList();
                        timelineConfigModalOverlay.style.display = 'flex';
                    }

                    function renderTimelineEventList() {
                        if (!currentTimelineConfigData) return;
                        
                        timelineConfigEventsList.replaceChildren();
                        
                        if (currentTimelineConfigData.events.length === 0) {
                            timelineConfigEventsList.innerHTML = `<p class="text-slate-400 text-sm text-center">No events created yet.</p>`;
                            return;
                        }

                        currentTimelineConfigData.events.forEach((event, index) => {
                            const eventEl = document.createElement('div');
                            eventEl.className = 'p-3 bg-slate-700 rounded-lg border border-slate-600';
                            eventEl.dataset.eventId = event.id;
                            
                            eventEl.innerHTML = `
                                <div class="flex justify-between items-center mb-3">
                                    <span class="font-semibold text-white">Event ${index + 1}</span>
                                    <button class="header-btn danger text-xs px-2 py-1 timeline-event-delete-btn" data-event-id="${event.id}">Delete</button>
                                </div>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                                    <div>
                                        <label class="block text-xs font-medium text-slate-300 mb-1">Text</label>
                                        <textarea
                                            class="timeline-event-text-input w-full bg-slate-800 text-white text-sm rounded-md p-2 border border-slate-600"
                                            rows="2"
                                            placeholder="Event description..."
                                            data-event-id="${event.id}" data-field="text"
                                        >${event.text || ''}</textarea>
                                    </div>
                                    <div>
                                        <label class="block text-xs font-medium text-slate-300 mb-1">Image URL (Optional)</label>
                                        <input
                                            type="text"
                                            class="timeline-event-image-input w-full bg-slate-800 text-white text-sm rounded-md p-2 border border-slate-600"
                                            value="${event.image || ''}"
                                            placeholder="https://..."
                                            data-event-id="${event.id}" data-field="image"
                                        />
                                    </div>
                                </div>
                                <div class="mt-3">
                                    <label class="block text-xs font-medium text-slate-300 mb-1">Line/Text Color</label>
                                    <input
                                        type="color"
                                        class="timeline-event-color-input w-20 h-8 p-1 bg-slate-800 border border-slate-600 rounded-md"
                                        value="${event.color || '#FFFFFF'}"
                                        data-event-id="${event.id}" data-field="color"
                                    />
                                </div>
                            `;
                            timelineConfigEventsList.appendChild(eventEl);
                        });
                    }

                    timelineConfigEventsList.addEventListener('input', (e) => {
                        if (!currentTimelineConfigData || !e.target.dataset.eventId) return;

                        const eventId = e.target.dataset.eventId;
                        const field = e.target.dataset.field;
                        const value = e.target.value;

                        const event = currentTimelineConfigData.events.find(ev => ev.id === eventId);
                        if (event) {
                            event[field] = value;
                        }
                    });

                    timelineConfigAddEventBtn.addEventListener('click', () => {
                        if (!currentTimelineConfigData) return;
                        
                        const newEvent = {
                            id: crypto.randomUUID(),
                            position: 0.5,
                            text: "New Event",
                            color: "#FFFFFF",
                            lineLength: 40,
                            image: ""
                        };
                        
                        currentTimelineConfigData.events.push(newEvent);
                        renderTimelineEventList();
                    });

                    timelineConfigEventsList.addEventListener('click', (e) => {
                        if (e.target.classList.contains('timeline-event-delete-btn')) {
                            const eventId = e.target.dataset.eventId;
                            if (!currentTimelineConfigData) return;
                            
                            currentTimelineConfigData.events = currentTimelineConfigData.events.filter(event => event.id !== eventId);
                            renderTimelineEventList();
                        }
                    });

                    function closeTimelineConfigModal() {
                        timelineConfigModalOverlay.style.display = 'none';
                        currentTimelineConfigData = null;
                    }

                    timelineConfigCancelBtn.addEventListener('click', closeTimelineConfigModal);

                    timelineConfigSaveBtn.addEventListener('click', async () => {
                        if (!canEdit || !currentTimelineConfigData) return;

                        timelineConfigSaveBtn.disabled = true;
                        timelineConfigSaveBtn.textContent = 'Saving...';

                        try {
                            const updatedData = {
                                mainColor: timelineConfigColorInput.value,
                                mode: timelineConfigModeSelect.value,
                                direction: timelineConfigDirectionSelect.value,
                                events: currentTimelineConfigData.events
                            };

                            const itemRef = doc(itemsCol, currentTimelineConfigData.itemId);
                            await updateDoc(itemRef, updatedData);

                            closeTimelineConfigModal();

                        } catch (e) {
                            console.error("Error saving timeline config:", e);
                            await showModalAlert(
                                errorModalOverlay,
                                errorModalOkBtn,
                                {
                                    title: "Save Error",
                                    titleEl: errorModalTitle,
                                    text: "Could not save timeline changes. Please try again.",
                                    textEl: errorModalText
                                }
                            );
                        } finally {
                            timelineConfigSaveBtn.disabled = false;
                            timelineConfigSaveBtn.textContent = 'Save Changes';
                        }
                    });
        </script>
        <div
            id="timeline-config-modal-overlay"
            class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[22000] flex items-center justify-center"
            style="display: none"
        >
            <div
                id="timeline-config-modal"
                class="glass-panel p-6 rounded-lg shadow-xl max-w-2xl w-full flex flex-col"
                style="max-height: 90vh;"
            >
                <h2 class="text-xl font-bold text-white mb-4">
                    Configure Timeline
                </h2>
                
                <div class="grid grid-cols-3 gap-4 mb-4">
                    <div>
                        <label for="timeline-config-color" class="block text-sm font-medium text-slate-300 mb-2">Main Color</label>
                        <input
                            type="color"
                            id="timeline-config-color"
                            class="w-full h-10 p-1 bg-slate-700 border border-slate-600 rounded-lg"
                        />
                    </div>
                    <div>
                        <label for="timeline-config-mode" class="block text-sm font-medium text-slate-300 mb-2">Mode</label>
                        <select id="timeline-config-mode" class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600">
                            <option value="horizontal">Horizontal</option>
                            <option value="vertical">Vertical</option>
                        </select>
                    </div>
                    <div>
                        <label for="timeline-config-direction" class="block text-sm font-medium text-slate-300 mb-2">Direction</label>
                        <select id="timeline-config-direction" class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600">
                        </select>
                    </div>
                </div>
                
                <h3 class="text-lg font-semibold text-white mb-2">Events</h3>
                <div id="timeline-config-events-list" class="flex-grow overflow-y-auto bg-slate-800/50 rounded-lg p-3 space-y-3 mb-4">
                </div>

                <button id="timeline-config-add-event" class="header-btn bg-green-600 hover:bg-green-500 w-full mb-4">
                    + Add New Event
                </button>

                <div class="flex justify-end gap-4 flex-shrink-0">
                    <button id="timeline-config-cancel-btn" class="header-btn">
                        Cancel
                    </button>
                    <button
                        id="timeline-config-save-btn"
                        class="header-btn bg-indigo-600 hover:bg-indigo-500"
                    >
                        Save Changes
                    </button>
                </div>
            </div>
        </div>
    </body>
</html>
