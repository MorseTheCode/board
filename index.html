<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evidence Board</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            user-select: none;
        }

        textarea, [contenteditable="true"] {
            user-select: text;
        }

        #board {
            background-color: #1e293b;
            position: relative;
            overflow: hidden;
            z-index: 10; 
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
        }

        #svg-layer-connections, #svg-layer-drawings {
            position: absolute;
            top: -10000px;
            left: -10000px;
            width: 20000px;
            height: 20000px;
        }

        #svg-layer-connections {
            z-index: 6; 
        }

        #svg-layer-drawings {
            z-index: 5;
            pointer-events: none; 
        }

        #selection-box {
            position: absolute;
            border: 1px dashed #38bdf8;
            background: rgba(56, 189, 248, 0.1);
            z-index: 1000;
            display: none;
            pointer-events: none;
        }

        #users-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        #users-modal {
            width: 400px;
            max-width: 90%;
            padding: 20px;
            z-index: 10001;
        }
        #users-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #334155;
        }
        #users-list li:last-child {
            border-bottom: none;
        }
        .role-badge {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 12px;
            font-weight: 600;
        }
        .role-owner { background-color: #f43f5e; color: white; }
        .role-editor { background-color: #3b82f6; color: white; }
        .role-viewer { background-color: #475569; color: #e2e8f0; }

        .permission-btn {
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 6px;
            margin-left: 5px;
            background-color: #334155;
            color: #e2e8f0;
            cursor: pointer;
        }
        .permission-btn:hover {
            background-color: #475569;
        }
        .permission-btn.promote { background-color: #2563eb; color: white; }
        .permission-btn.demote { background-color: #94a3b8; color: #1e293b; }
        .permission-btn.kick { background-color: #b91c1c; color: white; }

        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .freehand-drawing {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: auto; 
        }

        .temp-drawing-path {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .item {
            position: absolute;
            min-width: 150px;
            min-height: 50px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
            cursor: default;
            display: flex;
            flex-direction: column;
            border-radius: 16px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            user-select: none;
        }

        .item:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            z-index: 1001 !important;
        }

        .item.item-node {
            background-color: #65a30d;
            border: 2px solid #a3e635;
            border-radius: 50%;
            min-width: 0;
            min-height: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            padding: 0;
            transition: box-shadow 0.2s ease;
        }

        .item.item-node:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.5);
        }

        .item.item-node .delete-btn {
            top: -6px;
            right: -6px;
        }

        .connector-line {
            fill: none;
            cursor: pointer;
            transition: stroke-width 0.1s;
            vector-effect: non-scaling-stroke;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .connector-line:hover {
            filter: drop-shadow(0 0 2px rgba(56, 189, 248, 0.7));
        }
        .connector-line.selected-line {
            filter: drop-shadow(0 0 3px #38bdf8) drop-shadow(0 0 3px #38bdf8);
        }

        .item.item-note {
            background-color: rgb(254 249 195);
        }

        .move-handle-note {
            width: 100%;
            height: 24px;
            background: rgba(0,0,0,0.15);
            cursor: grab;
            border-radius: 16px 16px 0 0;
        }
        .move-handle-note:active {
            cursor: grabbing;
            background-color: rgba(0,0,0,0.2);
        }

        .item.item-image {
            border: none;
            background: #ffffff;
            padding-bottom: 0px;
            border-radius: 8px;
        }

        .item.item-image .image-wrapper {
            padding: 2px 2px 2px 2px;
            background-color: #ffffff;
            position: relative;
            border-radius: 8px 8px 0 0;
            overflow: hidden; 
            transition: border-radius 0.2s ease; 
        }

        .item.item-image .image-wrapper.no-caption {
            border-radius: 8px;
        }

        .item.item-image .image-wrapper img {
            border: 1px solid #f0f0f0;
            border-radius: 8px;
        }

        .item.item-image .caption {
            background-color: #ffffff;
            padding: 8px 8px;
            font-size: 14px;
            text-align: center;
            color: #333;
            min-height: 30px;
            cursor: text;
            border-radius: 8px 8px 8px 8px;
            overflow: hidden;
            font-family: 'Brush Script MT', cursive;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .resize-handle {
            display: none !important;
        }

        .resize-handle-image, .resize-handle-note {
            position: absolute;
            width: 20px;
            height: 20px;
            bottom: -8px;
            right: -8px;
            background: #4f46e5;
            border: 1px solid white;
            border-radius: 50%;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            cursor: se-resize;
            z-index: 10;
        }

        .delete-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            top: -10px;
            right: -10px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            border: 1px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .delete-btn:hover {
            background: #dc2626;
        }

        .edit-btn {
            position: absolute;
            width: 24px;
            height: 24px;
            top: -10px;
            right: 22px;
            background: #3b82f6;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            z-index: 10;
            border: 1px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .edit-btn:hover {
            background: #2563eb;
        }

        #add-image-input {
            display: none;
        }

        .item.selected {
            box-shadow: 0 0 0 3px #4f46e5;
            z-index: 1000 !important;
        }

        .item textarea {
            border: none;
            outline: none;
            resize: none;
            width: 100%;
            padding: 12px;
            padding-top: 8px;
            background: transparent;
            font-family: 'Brush Script MT', cursive;
            flex-grow: 1;
            border-radius: 0 0 16px 16px;
        }

        .item.item-note textarea[readonly] {
            cursor: grab;
        }
        .item.item-note:active textarea[readonly] {
            cursor: grabbing;
        }
        .item.item-note textarea:not([readonly]) {
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
            cursor: text;
            background: rgba(0,0,0,0.03);
        }

        .glass-panel {
            background: rgb(30 41 59 / 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid #334155;
            border-radius: 16px;
            box-shadow: 0 12px 30px rgba(0,0,0,0.5);
        }

        #line-control-panel {
            position: absolute;
            z-index: 2000;
            display: none;
            flex-direction: column;
            gap: 10px;
            width: 220px;
            padding: 16px;
        }

        #line-control-panel label {
            font-size: 0.85rem;
            color: #94a3b8;
            display: block;
            margin-bottom: 4px;
        }

        #line-control-panel select,
        #line-control-panel input[type="range"],
        #line-control-panel input[type="color"] {
            width: 100%;
            padding: 4px;
            border-radius: 6px;
            border: 1px solid #475569;
            background: #1e293b;
            color: white;
            font-size: 0.9rem;
        }

        #line-control-panel input[type="color"] {
            height: 30px;
            padding: 2px;
        }

        #line-control-panel button {
            background: #4f46e5;
            color: white;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            margin-top: 5px;
            transition: background-color 0.2s;
        }
        #line-control-panel button:hover {
            background: #6366f1;
        }
        #line-control-panel #delete-line-btn {
            background: #ef4444;
        }
        #line-control-panel #delete-line-btn:hover {
            background: #f87171;
        }

        .context-menu {
            position: absolute;
            display: none;
            flex-direction: column;
            z-index: 1500;
            width: 190px;
            padding: 8px;
            animation: fadeInScale 0.12s ease-out;
        }
        .context-menu button {
            background: none;
            border: none;
            color: #e2e8f0;
            padding: 10px 14px;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0;
            border-radius: 8px;
            width: 100%;
        }
        .context-menu button:hover {
            background: #334155;
            color: white;
        }

        .context-menu label.context-menu-label-btn {
            background: none;
            border: none;
            color: #e2e8f0;
            padding: 10px 14px;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0;
            border-radius: 8px;
            width: 100%;
        }
        .context-menu label.context-menu-label-btn:hover {
            background: #334155;
            color: white;
        }

        #connection-submenu, #font-submenu {
            background: #1e293b;
            display: none;
            border-radius: 8px;
            margin-top: 4px;
            padding-top: 4px;
            padding-bottom: 4px;
            display: none;
            flex-direction: column;
            width: 100%;
            animation: fadeInScale 0.12s ease-out;
            transform-origin: left center;
        }

        #connection-submenu button, #font-submenu button {
            background: none;
            border: none;
            color: #e2e8f0;
            padding: 10px 14px;
            text-align: left;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
            border-radius: 8px;
            width: 100%;
        }
        #connection-submenu button:hover, #font-submenu button:hover {
            background: #334155;
            color: white;
        }

        .cursor-mode-btn {
            background-color: #334155;
            color: #e2e8f0;
            padding: 6px 10px;
            border-radius: 8px;
            border: 2px solid #334155;
            transition: all 0.2s ease;
        }
        .cursor-mode-btn:hover {
            background-color: #475569;
            border-color: #475569;
        }
        .cursor-mode-btn.active {
            background-color: #4f46e5;
            border-color: #818cf8;
            color: white;
            box-shadow: 0 0 10px rgba(99, 102, 241, 0.5);
        }

        .header-btn {
            background-color: #334155;
            color: #e2e8f0;
            padding: 6px 12px;
            border-radius: 8px;
            text-sm font-medium
            transition: background-color 0.2s;
        }
        .header-btn:hover {
            background-color: #475569;
        }
        .header-btn.danger {
            background-color: #7f1d1d;
            color: #fca5a5;
        }
        .header-btn.danger:hover {
            background-color: #b91c1c;
            color: white;
        }

        #toggle-api-box-btn {
            transition: transform 0.2s ease;
        }
        #toggle-api-box-btn.collapsed {
            transform: rotate(-90deg);
        }

        #cursor-mode-container {
            position: relative;
            display: flex;
            gap: 8px;
        }

        #toggle-draw-controls {
            background-color: #334155;
            color: white;
            padding: 6px;
            border-radius: 8px;
            border: 2px solid #334155;
            margin-left: -6px;
            z-index: 1;
        }
        #toggle-draw-controls.active {
            background-color: #4f46e5;
            border-color: #818cf8;
        }
        #toggle-draw-controls svg {
            transition: transform 0.2s ease;
        }
        #toggle-draw-controls.active svg {
            transform: rotate(180deg);
        }

        #draw-controls {
            position: absolute;
            top: 110%;
            left: 0;
            z-index: 21;
            display: none;
            flex-direction: column;
            gap: 10px;
            width: 200px;
            padding: 12px;
        }
        #draw-controls-tools {
            display: flex;
            gap: 8px;
        }
        .draw-tool-btn {
            background-color: #475569;
            color: white;
            padding: 6px;
            border-radius: 6px;
            border: 2px solid #475569;
            flex-grow: 1;
        }
        .draw-tool-btn.active {
            background-color: #4f46e5;
            border-color: #818cf8;
        }

        #draw-controls label {
            font-size: 0.8rem;
            color: #cbd5e1;
        }
        #draw-controls input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
            padding: 0;
            cursor: pointer;
            background: transparent;
        }
        #draw-controls input[type="color"]::-webkit-color-swatch {
            border-radius: 50%;
            border: none;
        }
        #draw-controls input[type="color"]::-moz-color-swatch {
            border-radius: 50%;
            border: none;
        }
        #draw-controls input[type="range"] {
            width: 100%;
        }

        #eraser-cursor {
            display: none;
            position: fixed;
            width: 20px;
            height: 20px;
            border: 1px solid rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 9999;
        }

        #board.eraser-active {
            cursor: none;
        }

        #pencil-cursor {
            display: none;
            position: fixed;
            width: 5px;
            height: 5px;
            border: 1px solid rgba(255, 255, 255, 0.7);
            background-color: #FFFFFF;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            z-index: 9999;
        }

        #board.pencil-active {
            cursor: none;
        }

        body.read-only #cursor-mode-container,
        body.read-only #toggle-snap-grid,
        body.read-only #clear-notes-btn,
        body.read-only #clear-images-btn,
        body.read-only #clear-lines-btn,
        body.read-only #clear-drawings-btn,
        body.read-only #clear-all-btn,
        body.read-only .edit-btn,
        body.read-only .delete-btn,
        body.read-only .resize-handle-image,
        body.read-only .resize-handle-note,
        body.read-only .move-handle-note,
        body.read-only #item-menu-font,
        body.read-only #item-menu-connect,
        body.read-only #item-menu-delete-node,
        body.read-only #board-menu-add-note,
        body.read-only #board-menu-add-image-label,
        body.read-only #board-menu-add-node,
        body.read-only #board-menu-paste {
            display: none !important;
        }

        body.read-only #item-menu-bring-front,
        body.read-only #item-menu-send-back {
             display: none !important;
        }

        body:not(.is-owner) #delete-room-btn,
        body:not(.is-owner) #manage-backups-btn,
        body:not(.is-owner) #board-settings-btn {
            display: none !important;
        }

        #invite-modal-owner-view { display: none; }
        body.is-owner #invite-modal-owner-view { display: block; }
        body.is-owner #invite-modal-user-view { display: none; }

    </style>
</head>
<body class="bg-slate-900 text-white h-screen w-screen flex flex-col overflow-hidden">

    <header class="bg-slate-900/80 backdrop-blur-sm border-b border-slate-700 shadow-lg p-2 flex items-center gap-3 flex-shrink-0 z-[10000] select-none">
        <h1 class="text-lg font-bold text-indigo-400 hidden sm:block">Evidence Board</h1>
        <div class="h-6 w-px bg-slate-700 hidden sm:block"></div>

        <input type="file" id="add-image-input" accept="image/*">

        <div class="h-6 w-px bg-slate-700"></div>

        <div id="cursor-mode-container" class="flex items-center">
            <div class="flex gap-2">
                <button id="mode-move" class="cursor-mode-btn active" title="Move (Default)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                      <path d="M10 4.5a.75.75 0 01.75.75v10a.75.75 0 01-1.5 0V5.25a.75.75 0 01.75-.75z" />
                      <path d="M5.25 10a.75.75 0 01.75-.75h8.5a.75.75 0 010 1.5h-8.5a.75.75 0 01-.75-.75z" />
                      <path d="M10 2l-3 3.5h6L10 2z" />
                      <path d="M10 18l-3-3.5h6L10 18z" />
                      <path d="M2 10l3.5-3v6L2 10z" />
                      <path d="M18 10l-3.5-3v6L18 10z" />
                    </svg>
                </button>
                <button id="mode-select" class="cursor-mode-btn" title="Select">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-dasharray="2 2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="14" height="14" rx="1" />
                    </svg>
                </button>
                <button id="mode-draw" class="cursor-mode-btn" title="Draw (Pencil)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                </button>
            </div>
            <button id="toggle-draw-controls">
                <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
            </button>

            <div id="draw-controls" class="glass-panel" style="display: none;">
                <div id="draw-controls-tools">
                    <button id="draw-tool-pencil" class="draw-tool-btn active" title="Pencil">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                    </button>
                    <button id="draw-tool-eraser" class="draw-tool-btn" title="Eraser">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" viewBox="0 0 20 20" fill="currentColor">
                          <path d="M16.142 3.858a2.25 2.25 0 00-3.182 0L4.3 12.518a2.25 2.25 0 000 3.182l.06.06a2.25 2.25 0 003.182 0L16.2 6.9a2.25 2.25 0 000-3.182l-.06-.06zM5.57 14.43a.75.75 0 01-1.06 0l-.06-.06a.75.75 0 010-1.06l8.66-8.66a.75.75 0 011.06 0l.06.06a.75.75 0 010 1.06l-8.66 8.66z" />
                        </svg>
                    </button>
                </div>
                <div id="draw-color-container">
                    <label for="draw-color">Color:</label>
                    <input type="color" id="draw-color" value="#FFFFFF">
                </div>
                <div id="draw-thickness-container">
                    <label for="draw-thickness">Thickness:</label>
                    <input type="range" id="draw-thickness" min="1" max="10" value="3" step="0.5">
                </div>
                <div id="eraser-size-container" style="display: none;">
                    <label for="eraser-size">Eraser Size:</label>
                    <input type="range" id="eraser-size" min="5" max="200" value="103" step="1">
                </div>
            </div>
        </div>

        <button id="toggle-snap-grid" class="cursor-mode-btn ml-2" title="Snap to Grid">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
              <path stroke-linecap="round" stroke-linejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" clip-rule="evenodd"></path>
            </svg>
        </button>

        <button id="invite-btn" class="header-btn ml-auto bg-indigo-600 hover:bg-indigo-500">
            Invite
        </button>

        <button id="clear-notes-btn" class="header-btn ml-2">
            Clear Notes
        </button>
        <button id="clear-images-btn" class="header-btn">
            Clear Images
        </button>
        <button id="clear-lines-btn" class="header-btn">
            Clear Lines
        </button>
        <button id="clear-drawings-btn" class="header-btn">
            Clear Drawings
        </button>
        <button id="clear-all-btn" class="header-btn danger">
            Clear All
        </button>
        <button id="delete-room-btn" class="header-btn bg-red-800 hover:bg-red-700 text-white font-bold ml-1" title="Delete This Room Permanently">
            Delete Room
        </button>
        <button id="manage-backups-btn" class="header-btn bg-teal-600 hover:bg-teal-500 text-white font-bold ml-1" title="Manage Room Backups">
            Backups
        </button>
        <button id="board-settings-btn" class="header-btn bg-gray-600 hover:bg-gray-500 text-white font-bold ml-1" title="Board Settings">
            Settings
        </button>

        <button id="show-users-btn" class="header-btn ml-3" title="Show Users">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path d="M9 6a3 3 0 11-6 0 3 3 0 016 0zM11 6a3 3 0 11-6 0 3 3 0 016 0zM12 8a4 4 0 100-8 4 4 0 000 8zM14 10a1 1 0 011 1v1a1 1 0 01-1 1h-1v1a1 1 0 01-1 1H6a1 1 0 01-1-1v-1H4a1 1 0 01-1-1v-1a1 1 0 011-1h10zM5 11v1h10v-1H5z" />
              <path d="M12.9 14.25c.218.087.48.13.7.13a3.5 3.5 0 003.5-3.5c0-.987-.41-1.884-1.077-2.523A3.986 3.986 0 0013 7a3.986 3.986 0 00-2.823 1.176A3.487 3.487 0 009 10.5a3.5 3.5 0 00.9 2.38c.218.087.48.13.7.13a2.5 2.5 0 002.3-1.23v2.47z" />
            </svg>
        </button>

        <div class="h-6 w-px bg-slate-700 ml-3"></div>
        <span id="board-name-display" class="text-sm text-indigo-300 font-medium ml-3">Loading board...</span>

        <input type="text" id="board-name-input" class="ml-3 bg-slate-700 text-white text-sm rounded-md p-1 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Enter board name...">
        <button id="switch-board-btn" class="header-btn ml-1">Switch</button>
    </header>

    <main id="board" class="flex-grow">
        <div id="selection-box"></div>

        <div id="canvas-container">
            <svg id="svg-layer-connections" class="absolute top-0 left-0 z-0">
                <defs>
                    <pattern id="threadPattern" 
                             patternUnits="userSpaceOnUse" 
                             width="16" height="16"
                             >
                        <image href="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCABkAGQDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD7v0jxfpfhvUJRdalLdySn/RYyN4EY+6oRF3Z69QR171H4w17TtStZ9U0q9ls9bsfllXTAks/B+ZHjwecZwpG78eK+R/Af7D76t9jfVbtLW0glYTeQQZN6vguu5SFQ4xjnBBBA6j7B+Gvw+svB+ixWLfZZYrckR3a22xHO49Qc4OAMnPJJINAFfw7qmn/E7w7BfQ+HLjW7e6VZFmvYEt8sOA7LJtZG7g7QemM8VseFPDeteH9GEGtXNvNHvaKKNU+ZICx2xOxYiQhcAngn9a6WSIxwzQWeLWRj5hKgCJmJyR68nrjnmsi8vNQZtnyTkcvaNgYGeejH8xnvxQBc0fwfFpckvl6hJdJKQ0NtcfMkKjOQgyeDxyc/yxPpej6Fa3lx5enW1ldIf3pSMKxJJOcj1OT6HmoP7Pu0Ed5bTC0ilXMtvIGMmeoCnPyjrxjv0GMVFL4otJZBZOAk7Hy9u3ILegxnn/dzjvigDc1CKbKS20tuYkH/AB7zwg7z7NnrTLW7sdcsXa909YVBMbx3UI5I7AEcisi1jk0m5zdzrO8gxBArL+7GB8oyODnPJ+hxVyS9stdmNm3lzXEJB2MvzRE9CVPOD2PQ9uKAJpNLtb1V+0WcV5Zx5ZGx0O4MMKB6qpyM8iqt/wCCNI8SXGl6lHvhls2aSF4XG1gyFWDDkMCD16ggEGnPcaj4f82XUVW808AYktQWaIY5Lp3HuufpS2+s2usWu7RLyGUldyvbsGi/HHA57ZzQBhr8P7jSr5ZW1+X7NgiKynj3W+ex6jn6YB9K47xFp/xF+1LZW6iG1nD+dqtpLE/2YYO0pE68nO35cnA3fNnFeq2t5HKiW1+8bX3liRkYq69cZXvjI4OB278Un9oXInKx2kkiIMHbwv1z6d+Bz+lAHh9jqOq6RALTUNf+yzw4QLFbPBuAAG5hiQFickkNj8uSvXpvC9pqkhuXvMs/P+sdf/QWA/HvRQBwlj4b8Zf2HqczWz2N1NdyvFCBHIUQuRvADqclcngjJbBG3IrV1HxfY6Db6bpV5uh+0FY1t5YyuflJOd2No4OT6DjOa9CgWSR0ks7sNB1aKT5gR7HqP5VXuJY9QY2t5awRhSGZLgb1PptJ6/UdPrQBxV3awJbhtG1VYScyGGR8qVI5EZHCg8Dd82BnA5NJYJda7Yx/2rb27eWfnsgoIYAnaUP8SAcjoScE4qHxx8KdO8ZWN1Y6fFd6HcTfvF1DRbp7ORJAwKuWT5XAIHDqc9DnOK8u8aaB8QvBuj2Bv/G1lq01mhja5uNP2RuxGBK4XhXAB5PyDJOBzQB61rE2paxMkWnXU9odwMqHBLRjOVV2IKcYyQG6YDDOau2saWcYudtvf3Ee5ftCJjjJyqsMtGevUk5zmvmjxB8WPF/hPwpB/Yvgm/1W7mj82TUIb1ovMGT+8ZSu5gSMgfKSBgEcVq/AjxV4y+J3w/fXtUttMsbY3bpZjSdyKwj+RvNDl+jhlxwQUOc0Ae72tjfwk3ljHJNaSqWk+0jM8Z4wOo3J1PGCOODzTrPXtHWR7m2uorO8DFJVumADN3w+OuTjkH6dK4q71n4pQW8J0qHQ7lyCfs9xHKqmPcQGaQN8vy44CMc57c1k6bJ4p8aGTVJ9NsdK1WwZ4WbEgaNl+8qMNpKMwB5yMAdcCgD0+HxRrUd7cnUNOk03SlZVhv8AekvmE9cqp3KBxgkd+QKr6xbx2MBl8P8Al20zyNL5MUe+K4kY7nYqpwWbn5s8EjOelfPHj/42fFzSdA0zS9O8NabfeI9QhQS2ro3+ioA/mEoH6YCFRnPz4IbHNf4YeEfjD4u8Qx67B4it/C3k7obvShaebalxjP7ov0/4EjKMAdxQB9CWesXHiHSzY+IrWXSNTBZPs6ThJxxnfDIp+YEf3TuzngYo/wCFjWmj6pBp63FzqSzYSO3tyJJA3QhgeT0PQn8+rLXwrZ6+ktn4vvI9cymGt2YJb4zgsIRgj6nf04YHiug0fQ18A6KLLTNOhfR4lIgt4EKyoM/dwOWIB+8PTn1oAnax1PW8XkFkLNJAD5c8jRPnHVlwcH8qK1k1lY8xtbyTMnBLsoxwDgZxkDPX6jtRQBk6nrd1oQiYwXGpQyuqk2iK724bgFxkHbkckZI54wOLEVsniSxguZ5445EcyQMrFlx254z9K811z4mWfwkS3g1TVrE2k8ohjnvLhYrh2IyAVP8ArDtySBzjBwM1mXtzpeo3v/CQaZ4nmkjlw02lWFz5lse5ZBglXx2TqSc54wAeuL4ka4u20+cSW9+jZilRHaORCDhi4XaDwcg9OD0YVlXljCt59q1BVkhnXLJHiaJZOhGNvOeuFOc54NZOnabc+L/CdvHHp32JplMtvDrMircIxHDboy+G5ySDnDY45re8Jabqmk+FbPT/ABf9hvNQmXy7lrRXNu5PHlpvJZ+O5xnBOAOAAc14vh03VNLZYpVhhm2C8tYZyhlhZcK8T8EKTj5lxgBsEEGoPg3obeH/AA1c6Vb2UWn6eL2UQW0KAJbwkAlFYAbiXLndgckjHy16NpvhfTdIUDT7EW6SMX2s5IyeT8pPH9PSqx8QapfXs1rbWDWMFu2xpbpSpcYBzGP4hyOcgdec8UAZun6dLpV9JBbWzzWwVfLf74BxtAKjkBQM/XPc1paxp4i09ri0sWe7jYSzWcWFM5xjGTjPHf0GPSr8d5dxWheFvt0wbaVJx35HsR6H8z1qSRo9SsUkvoZNi/MWXKGI+pHDD6/yoA8q8YXV5omrWGqQaSZ76dJoWtCBGvnlVMTFyM7cRmPjPzMnGc1ePiXT9N8NXF/aTwW1y4aZ7e8YoWK/ws6hgPmB6AjsM16BrU1naaf9nvwtxZAKWM/zDjGGY/xc4545+tTx2NrrFnH+7V4HxJ5VxEMHn+6Rx9etAHDw+L7eWyV9WiinATcZgCApA52sPu+mDtIxyTmtDRPECWMZmu5pXlkBMfnMgKR5JC8fLnaMnnqPoKoav8F/CmuTX32+1dftwU3Fl53mQyhWY/cfK4JY5AAyMA8DFch4k+A2qppd1b+H/Fd94f0/KiKxls4r2JfmU7cMAwTgfKHAAA4AGKAOj1f4yeGbTUJbe41bT3mi+VvNTcR3xkZ6Z/PNFc1CvxB0i3gs5fCWjeITCgQahDfPGJAO5V0JB9tzf7xooA8v+Ff7OXhDxRDaa94pvtX8W69PK8kLXt/OjWMYkYIhG4MGVg2eQMhsDivbtD8N6F8PrpbaLSrPTLO3CiKVI8M5fJIxyeoAwCdzHPrUknw5ufDurNf2KteaeySPd2+7eJXLM2UQDKvuZiScj5j7Y1V1XUdUc21xod8tn8xN1dRxbNoAzkBi2ecDgHg5xjkA6BtQtzCtvH5NmHO7ymGFOc9WHCv1OB/9eluPEL2c0FlKnmzTqxDScwqgHI/2jjnnrn8K4TxN4psdIs1svDkUepXikRHT7SZUZmwOAMY3d8EqPUjIzcm8f6VpGlwwWtrcyXzERRRyxFJmkOfvHHHQnIG3vzmgDq4pbjTVuLpJ5rsMc/YdygxHuE4GSeuCT/snBqnpGuzeNrN5Via0hUnYsjGOWNgSvzYyQ3Bypxjoe9YXh5Lk3EM2p3EMhiTf/ooYRncd3CszEgf72OchRji7/wAJ1YanceZp1ztLZRJGw32k4PygbvlAypJwByBnnFAGk15J4StZmeRtQYANuOEY5ON0hz0A9BgBTgcYq5a3T64iSxXREy9HtcbNpGeQ33xj8eeKy5tU1OO7soJra0WY/evMgoOBkRg5bPtgYABJ7VFr2kvhLrTbt4rvevm3HXK7ufqACcD6DigDUj1i50+JrWRbXT7ZDsSVpc7h1yq+nPfGPSkt7VkaF9PvpjAXZ5RcfMDnsjHoQQeASBk+wrPl13Q5o3gmRZ7xdokurxVjAYA4cbsepwyg8ZwTWX4i119CkjAurYRXKbnkbCoygqBIV3KUOW4YHGccrlaAO0fUrS82v5HlyR52zTYDI3Q8djx7VSvvEUmn3iW+oROsEigxXka7VkznKnJ+UgD15zxXGXujWaqdca7a2mhX5pLu5zHsV8jI+4jKCcELkgAFyM1l6D8ctP8AHd7JoOmyfbNWAKskcZZRhgFfHdeQQ2QpGDuGRQB3i2k18zzWl/cS27N8g8mNwn+yDxxnPr160Vh2+j+P7OHyZ44tWZWYLdfaI4iybjtBUAANtxnHGc49KKAO3j1KOAvFfvFD0I8rKRgdB85xk9OmPSn3MM15JG1nLGoY5dlUglMdv7315+hrnG8P6Xrmn2aajcp9ptnzBdu4NxHJgglSejYJHToeRWdqHiC/0W++zalqNrFpiKuzUpcx5Y5AGB/FxnqPQc8gA2dc+H3hjWLyO7v7SG71SPa6zKu2bI4DEqRzgkZPqfU15X8Q/hfqerabeT6Z4j1LTZ1PmWu64mnO9SRgQGQB8HHDcHjqenokkS6tGl5p8t7cM4BkuVzFHuC/6xY8jcG7gdc8c1k+FfGl34shvA1j5UtlvS31GRQYXOMZTJ3FffHYg4xyAfN0138UPC/h6PTrnXZY7oq3l2uu2dp9qfHO6MRblfJOcM24HJ2tjBp/A3xh4x1zQtT1bxDi1ms7824TTbY/aLpidoJ3swLjadoQKp3DsSa+iPEmj6Vr17Zt4lK3Mv3YMM0TW8voFBwSSDh8Hj6c814P06DS7a4nu3ghvbfWZS0EcZQNGVESDk/fMYVieg3k8KaAKCx+OviFrBn0TxZb2OjWszI8cdjHL57BmDLKJAduARlRzvB54zXTeDda8X31rNpV7LHZ6pp7FLsSQqY5ovmCzRbTxuAzsJJB4zjBPcw2rC6ZdNt1Z2kSS5kjiKq6kbQ/T74A6Hn5fTGJNU0+TUI4oolNvqkDru243yoWwQSRypx1xx7EUAfJHx61P4o6X4g8PaHpOqyW11r2qSyQ6gEhjVLWGJfMQkR9S8iFSRnCnt19C8PfCj4keItFmg+IHjqa+0+UxfZVtrO2tiOitGzIgkUv0yjrwccd+3+OXhXWPFen+HZ9Pt5LfUtB1iG8AeNjA8Cllk+fHGU3DJOMOCfbOtfH2qa7B9q1rR30LTrUD/RdWeEx3H3WEivG77ShxghuNwbng0AaHhz9lfwRpM9jqYsvtlzbReUsd7M86FAOAokLAAAnAIxznjrXpnhuTSliFpp1nDZwwcO0AWJUzxjAGM8fp+FefWOuyprSKdQmYzZzY3DrLHEqD7hIXcqHcnJViNqhvvGtjUvEC6tfNZ6dqkemXkCLK8e5GG08Kp67gdoHGGGDhgOCAegySS2+1CqXfGfNZFyf1FFcNH4ohj3xsJbl42KNJ9ndzkdiVGCR049OxyKKAOEuPi18O/FlrHqll4o0O3jaP95erexST3MQyAuM7m+Y8Y79M5Ocjw/4t1/4j3eq6JNBqWiWVqfIgudTshBLc56GPc5ckEfe8sdieeateC/g/wDDrwDe2t3oUOn6TromkjWDzFP21Hcny5Fzg9FIY5Ke4LBvZ9NWx1Rj9o09LRLdjHE0wAlBBxlR1AOAR6jHtkA890n4W+NLHVLUN8Rby60SDCzadJbRyXKHbkP5+Sep3YkVweBwMg+hWHgTSbGR7xZJI72bBeaVk3SNxyVUDGT1C4yST15qxNrQ0u4jikKGPAEN67bN2f4Txz34HX8zVfUZrJLea+t1jkvGBZnwSxwOVTIPHHKjjr3zQAyTTdIXXpLia1X7cqfPPKuPl6DJ4JA+bH1PvV+b7NnbaJFJO2Ha3iBhnI6F+Dn/AL6x9apbo9a0/wAvVmWEx5/e5w8J46E/TnPcdxjFe61GytZLW0jjIRmUwXTLtUvycswxzxkkZBzyOcEA6i2vgLNknYZwfmk/d4X37n6459qoyfarFRJa7WgkYkM5KeWD3YEnj3Azz0qGW3tNRkgZryZr1RgSxsuxm4IO0jaxH97bnFK948OoR2U9rLHezqSlzbktBIV7sAfkPTOeOQMtwKANSOT+0cfZ2WNl+9cFBtb2C96zrq3t/tUdrdWVu4x5ouGgEkXDA4OeVbIUjB6r7Un/AAj5xmXVHhjHztawkLCTxwWxuxnpgjr0PADF1y2mlbT0idHX5BA6MNwAxuHcr/tDjPWgBdQ8F+H9QuXuZdJs3eRdryCJUdwMnBIG5hljweOT61wXi74B6D4oglGizXXhi9j3YvNPmaJo3KgbsA7Wxgde3Q12baPc6ZJNey30l3CwBWyBG9cdQjADd0+7jOQeRmhZD4kjextH82zU7HkYlZbdx65HUccEfUYPAB83XH7N+uac/kN8R/HF4VyfN0++iSI5JPA8rg/ifrRX0xaeGGsbdIry/NzMo5kjCxg/8BOcUUAedan4U0vwrfXU1haokl1EryswHJyoyMYxkMc46nk8kk80k2pQ+JdQK61feXo0b3MMZ8siUiIOEkbZuKZY/KCB0PUZoooA9fdU1rRYRcxqyXEDSMmOATwQPY+lcd4DZre+1ddzSyQ3EqxzSks6qpKhQTxj5emO9FFAE/iqd7q40Ik+W13c+WzIACqqQcD2OMYOR6Y61vafdNatLCAsqmV4GMo3FlHqT9Tx05PHJoooA5nWNal8GeMNK0rSoo4bfVFkaV33O8e0DAjJb5V/2QNo7AV18N7JN/aMUuJI4XVVUj3HPHQ89sUUUAee3mtTWvxU0nRions7yC6lYTSSN5ZjKKNi7toyHOSVJ6YIrfi8Q3txDeQs6hre5NrHMqAOFC5B9M59se1FFAHI+DfF2p3V5NHNcGUrdtB5khLOVBUDJJ5PJqT4jfETWPB+ueEbexkjaLWtXj0+5WZSwCNn51AIAb5fpycgnBBRQB6/YqZrVHLYLeqhv1YE0UUUAf/Z" 
                               x="0" y="0" width="16" height="16" />
                    </pattern>
                </defs>
            </svg>

            <svg id="svg-layer-drawings">
                <defs>
                    <pattern id="dot-grid" patternUnits="userSpaceOnUse" width="20" height="20">
                        <rect width="20" height="20" fill="#1e293b" />
                        <circle cx="1" cy="1" r="1" fill="rgba(255,255,255,0.1)" />
                    </pattern>
                </defs>
                <rect id="svg-bg-rect" fill="url(#dot-grid)" x="0" y="0" width="20000" height="20000" />
                <g id="drawing-group">
                </g>
                <g id="temp-drawing-group">
                </g>
            </svg>

        </div>

        <div id="line-control-panel" class="glass-panel" style="display: none;">
            <h3 id="line-panel-handle" class="text-white text-md font-bold mb-2 cursor-grab active:cursor-grabbing">Configure Line</h3>

            <div>
                <label for="line-type">Type:</label>
                <select id="line-type">
                    <option value="solid">Thread</option>
                    <option value="dotted">Dotted</option>
                    <option value="arrow">Arrow</option>
                </select>
            </div>

            <div id="line-color-control" style="display: none;">
                <label for="line-color">Color:</label>
                <input type="color" id="line-color" value="#d90429">
            </div>

            <div>
                <label for="line-thickness">Thickness:</label>
                <input type="range" id="line-thickness" min="1" max="10" value="5" step="0.5">
            </div>

            <button id="change-direction-btn" style="display: none;">Change Direction</button>
            <button id="connect-from-line-btn">Connect From This Line</button>
            <button id="delete-line-btn">Delete Line</button>
            <button id="close-line-panel-btn">Close</button>
        </div>

        <div id="item-menu" class="context-menu glass-panel">
            <button id="item-menu-font">
                <span>Change Font</span>
                <span>&rsaquo;</span>
            </button>
            <div id="font-submenu">
                <button data-font="'Brush Script MT', cursive" style="font-family: 'Brush Script MT', cursive;">Cursive</button>
            </div>
            <div id="font-size-container" class="p-2" style="display: none;">
                <label for="item-menu-font-size" class="text-xs text-slate-400 block mb-1">Font Size</label>
                <input type="range" id="item-menu-font-size" min="10" max="24" value="14" step="1" class="w-full">
            </div>
            <button id="item-menu-connect">
                <span>Create Connection</span>
                <span>&rsaquo;</span>
            </button>
            <div id="connection-submenu">
                <button id="submenu-solid" data-type="solid">Thread Line</button>
                <button id="submenu-dotted" data-type="dotted">Dotted Line</button>
                <button id="submenu-arrow" data-type="arrow">Arrow</button>
            </div>
            <button id="item-menu-bring-front">Bring to Front</button>
            <button id="item-menu-send-back">Send to Back</button>
            <button id="item-menu-delete-node" style="color: #f87171;">Delete Node</button>
        </div>

        <div id="board-menu" class="context-menu glass-panel">
            <button id="board-menu-add-note">+ Add Note</button>
            <label for="add-image-input" id="board-menu-add-image-label" class="context-menu-label-btn">
                + Add Image
            </label>
            <button id="board-menu-add-node">+ Add Node</button>
            <button id="board-menu-paste">Paste (Ctrl+V)</button>
        </div>

    </main>

    <div id="users-modal-overlay">
        <div id="users-modal" class="glass-panel">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Connected Users</h2>
                <button id="close-users-modal-btn" class="text-gray-400 hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <ul id="users-list" class="max-h-60 overflow-y-auto text-white">
            </ul>
        </div>
    </div>

    <footer class="bg-slate-900/80 backdrop-blur-sm border-t border-slate-700 text-slate-400 text-xs p-2 text-center flex-shrink-0 z-[10000] select-none">
        Use <span class="text-indigo-400 font-bold">Move Tool</span> to pan. Use <span class="font-bold">Right-Click</span> for options. Use <span class="font-bold">Scroll</span> to zoom.
        <span id="user-role-display" class="ml-4 font-bold"></span>
        <button id="change-nickname-btn" class="ml-2 px-2 py-0.5 bg-slate-700 hover:bg-slate-600 rounded text-xs text-indigo-300" title="Change Nickname">Change Nickname</button>
    </footer>

    <div id="eraser-cursor"></div>
    <div id="pencil-cursor"></div>

    <div id="delete-room-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center" style="display: none;">
        <div id="delete-room-modal" class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-red-400 mb-4">Are you sure?</h2>
            <p class="text-slate-300 mb-6">
                You are about to permanently delete this room: <strong id="delete-room-name" class="text-white"></strong>.
                All notes, images, and connections will be lost forever. This action cannot be undone.
            </p>
            <div class="flex justify-end gap-4">
                <button id="cancel-delete-room-btn" class="header-btn">Cancel</button>
                <button id="confirm-delete-room-btn" class="header-btn danger">Yes, Delete Room</button>
            </div>
        </div>
    </div>

    <div id="error-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[22000] flex items-center justify-center" style="display: none;">
        <div id="error-modal" class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 id="error-modal-title" class="text-xl font-bold text-red-400 mb-4">Error</h2>
            <p id="error-modal-text" class="text-slate-300 mb-6">
                An unknown error occurred.
            </p>
            <div class="flex justify-end gap-4">
                <button id="error-modal-ok-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500">OK</button>
            </div>
        </div>
    </div>

    <!-- START: Missing HTML Modals -->
    <div id="backups-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center" style="display: none;">
        <div id="backups-modal" class="glass-panel p-6 rounded-lg shadow-xl max-w-lg w-full">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Manage Backups</h2>
                <button id="close-backups-modal-btn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <button id="create-new-backup-btn" class="header-btn bg-teal-600 hover:bg-teal-500 text-white w-full mb-4">Create New Backup</button>
            <ul id="backups-list" class="max-h-60 overflow-y-auto text-white bg-slate-800/50 rounded-lg p-2">
                <!-- Backups will be listed here -->
            </ul>
        </div>
    </div>

    <div id="restore-confirm-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[21000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-yellow-400 mb-4">Restore Backup?</h2>
            <p class="text-slate-300 mb-6">
                Are you sure you want to restore the backup from <strong id="restore-backup-name" class="text-white"></strong>?
                This will overwrite all current items on the board.
            </p>
            <div class="flex justify-end gap-4">
                <button id="cancel-restore-btn" class="header-btn">Cancel</button>
                <button id="confirm-restore-btn" class="header-btn bg-yellow-600 hover:bg-yellow-500">Yes, Restore</button>
            </div>
        </div>
    </div>

    <div id="nickname-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[30000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 id="nickname-modal-title" class="text-xl font-bold text-white mb-4">Welcome!</h2>
            <p class="text-slate-300 mb-6">Please, choose your nickname.</p>
            <input type="text" id="nickname-input" class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Type your nickname...">
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-nickname-btn" class="header-btn">Cancel</button>
                <button id="save-nickname-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500">Save</button>
            </div>
        </div>
    </div>

    <div id="board-password-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[29000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-white mb-4">Password Required</h2>
            <p class="text-slate-300 mb-6">The board <strong id="board-password-name" class="text-white"></strong> is password protected.</p>
            <input type="password" id="board-password-input" class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Enter board password...">
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-board-password-btn" class="header-btn">Cancel</button>
                <button id="submit-board-password-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500">Enter</button>
            </div>
        </div>
    </div>

    <div id="new-board-password-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[29000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-white mb-4">New Board</h2>
            <p class="text-slate-300 mb-6">You are creating the board <strong id="new-board-name" class="text-white"></strong>. Set a password (optional).</p>
            <input type="password" id="new-board-password-input" class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Enter new password (optional)...">
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancel-new-board-btn" class="header-btn">Cancel</button>
                <button id="submit-new-board-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500">Create Board</button>
            </div>
        </div>
    </div>

    <div id="delete-backup-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[21000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-red-400 mb-4">Delete Backup?</h2>
            <p class="text-slate-300 mb-6">Are you sure you want to permanently delete this backup? This action cannot be undone.</p>
            <div class="flex justify-end gap-4">
                <button id="cancel-delete-backup-btn" class="header-btn">Cancel</button>
                <button id="confirm-delete-backup-btn" class="header-btn danger">Yes, Delete</button>
            </div>
        </div>
    </div>

    <div id="invite-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-md w-full">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Invite Users</h2>
                <button id="close-invite-modal-btn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            
            <div id="invite-modal-user-view">
                <button id="generate-viewer-link-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500 w-full">
                    Generate Viewer Link
                    <br><span class="text-xs font-normal">(View-only access)</span>
                </button>
            </div>

            <div id="invite-modal-owner-view">
                <button id="owner-generate-viewer-link-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500 w-full mb-3">
                    Generate Viewer Link
                    <br><span class="text-xs font-normal">(View-only access)</span>
                </button>
                <button id="owner-generate-editor-link-btn" class="header-btn bg-blue-600 hover:bg-blue-500 w-full">
                    Generate Editor Link
                    <br><span class="text-xs font-normal">(Single-Use, Edit Access)</span>
                </button>
            </div>

            <div id="invite-link-display" style="display: none;" class="mt-4">
                <label class="block text-sm font-medium text-slate-300 mb-2">Share this link:</label>
                <div class="flex gap-2">
                    <input type="text" id="invite-link-input" readonly class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600">
                    <button id="copy-invite-link-btn" class="header-btn bg-slate-600 hover:bg-slate-500">Copy</button>
                </div>
            </div>
        </div>
    </div>

    <div id="kick-confirm-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[21000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-red-400 mb-4">Kick User?</h2>
            <p class="text-slate-300 mb-6">Are you sure you want to kick <strong id="kick-user-name" class="text-white"></strong> from this board?</p>
            <div class="flex justify-end gap-4">
                <button id="cancel-kick-btn" class="header-btn">Cancel</button>
                <button id="confirm-kick-btn" class="header-btn danger">Yes, Kick</button>
            </div>
        </div>
    </div>

    <div id="kicked-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[30000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-red-400 mb-4">You have been kicked</h2>
            <p class="text-slate-300 mb-6">You have been removed from this board by the owner. You will be redirected to the default board.</p>
            <div class="flex justify-end gap-4">
                <button id="kicked-ok-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500">OK</button>
            </div>
        </div>
    </div>

    <div id="invalid-invite-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[30000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-yellow-400 mb-4">Invalid Invite Link</h2>
            <p class="text-slate-300 mb-6">The invite link you used is invalid or has already been used. You have joined as a viewer.</p>
            <div class="flex justify-end gap-4">
                <button id="invalid-invite-ok-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500">OK</button>
            </div>
        </div>
    </div>

    <div id="board-settings-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/50 backdrop-blur-sm z-[20000] flex items-center justify-center" style="display: none;">
        <div class="glass-panel p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h2 class="text-xl font-bold text-white mb-4">Board Settings: <strong id="settings-board-name" class="text-indigo-300"></strong></h2>
            <div class="mb-4">
                <label for="board-password-change-input" class="block text-sm font-medium text-slate-300 mb-2">Change Password</label>
                <input type="password" id="board-password-change-input" class="w-full bg-slate-700 text-white text-sm rounded-md p-2 border border-slate-600 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Enter new password (or blank)">
            </div>
            <div class="mb-6">
                <label class="flex items-center">
                    <input type="checkbox" id="remove-password-checkbox" class="h-4 w-4 bg-slate-700 border-slate-600 rounded text-indigo-500 focus:ring-indigo-500">
                    <span class="ml-2 text-sm text-slate-300">Remove password</span>
                </label>
            </div>
            <div class="flex justify-end gap-4">
                <button id="cancel-board-settings-btn" class="header-btn">Cancel</button>
                <button id="submit-board-settings-btn" class="header-btn bg-indigo-600 hover:bg-indigo-500">Update</button>
            </div>
        </div>
    </div>
    <!-- END: Missing HTML Modals -->

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            addDoc, 
            setDoc, 
            updateDoc, 
            deleteDoc, 
            onSnapshot, 
            collection, 
            query, 
            where, 
            getDocs,
            writeBatch,
            serverTimestamp,
            setLogLevel,
            orderBy,
            deleteField
        } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";

        const board = document.getElementById('board');
        const canvasContainer = document.getElementById('canvas-container');
        const svgLayerConnections = document.getElementById('svg-layer-connections');
        const svgLayerDrawings = document.getElementById('svg-layer-drawings');
        const drawingGroup = document.getElementById('drawing-group');
        const tempDrawingGroup = document.getElementById('temp-drawing-group');
        const selectionBox = document.getElementById('selection-box');

        const addImageInput = document.getElementById('add-image-input');

        const clearNotesBtn = document.getElementById('clear-notes-btn');
        const clearImagesBtn = document.getElementById('clear-images-btn');
        const clearLinesBtn = document.getElementById('clear-lines-btn');
        const clearDrawingsBtn = document.getElementById('clear-drawings-btn');
        const clearAllBtn = document.getElementById('clear-all-btn');
        const deleteRoomBtn = document.getElementById('delete-room-btn');
        const inviteBtn = document.getElementById('invite-btn');

        const modeMoveBtn = document.getElementById('mode-move');
        const modeSelectBtn = document.getElementById('mode-select');
        const modeDrawBtn = document.getElementById('mode-draw');
        const toggleSnapGridBtn = document.getElementById('toggle-snap-grid');

        const lineControlPanel = document.getElementById('line-control-panel');
        const lineTypeSelect = document.getElementById('line-type');
        const lineColorInput = document.getElementById('line-color');
        const lineColorControl = document.getElementById('line-color-control');
        const lineThicknessInput = document.getElementById('line-thickness');
        const connectFromLineBtn = document.getElementById('connect-from-line-btn');
        const deleteLineBtn = document.getElementById('delete-line-btn');
        const closeLinePanelBtn = document.getElementById('close-line-panel-btn');
        const linePanelHandle = document.getElementById('line-panel-handle');
        const changeDirectionBtn = document.getElementById('change-direction-btn');

        const itemMenu = document.getElementById('item-menu');
        const itemMenuFontBtn = document.getElementById('item-menu-font');
        const fontSubmenu = document.getElementById('font-submenu');
        const itemMenuConnectBtn = document.getElementById('item-menu-connect');
        const connectionSubmenu = document.getElementById('connection-submenu');
        const itemMenuDeleteNodeBtn = document.getElementById('item-menu-delete-node');
        const itemMenuBringFrontBtn = document.getElementById('item-menu-bring-front');
        const itemMenuSendBackBtn = document.getElementById('item-menu-send-back');
        const submenuSolid = document.getElementById('submenu-solid');
        const submenuDotted = document.getElementById('submenu-dotted');
        const submenuArrow = document.getElementById('submenu-arrow');

        const boardMenu = document.getElementById('board-menu');
        const boardMenuAddNoteBtn = document.getElementById('board-menu-add-note');
        const boardMenuAddNodeBtn = document.getElementById('board-menu-add-node');
        const boardMenuPasteBtn = document.getElementById('board-menu-paste');

        const toggleDrawControlsBtn = document.getElementById('toggle-draw-controls');
        const drawControls = document.getElementById('draw-controls');
        const drawColorInput = document.getElementById('draw-color');
        const drawThicknessInput = document.getElementById('draw-thickness');
        const drawToolPencilBtn = document.getElementById('draw-tool-pencil');
        const drawToolEraserBtn = document.getElementById('draw-tool-eraser');
        const eraserSizeSlider = document.getElementById('eraser-size');
        const eraserSizeContainer = document.getElementById('eraser-size-container');
        const drawThicknessContainer = document.getElementById('draw-thickness-container');
        const drawColorContainer = document.getElementById('draw-color-container');

        const fontSizeSlider = document.getElementById('item-menu-font-size');

        const eraserCursor = document.getElementById('eraser-cursor');
        const pencilCursor = document.getElementById('pencil-cursor');

        const boardNameInput = document.getElementById('board-name-input');
        const switchBoardBtn = document.getElementById('switch-board-btn');
        const boardNameDisplay = document.getElementById('board-name-display');
        const userRoleDisplay = document.getElementById('user-role-display');

        const usersModalOverlay = document.getElementById('users-modal-overlay');
        const usersModal = document.getElementById('users-modal');
        const closeUsersModalBtn = document.getElementById('close-users-modal-btn');
        const showUsersBtn = document.getElementById('show-users-btn');
        const usersList = document.getElementById('users-list');

        const changeNicknameBtn = document.getElementById('change-nickname-btn');

        const deleteRoomModalOverlay = document.getElementById('delete-room-modal-overlay');
        const cancelDeleteRoomBtn = document.getElementById('cancel-delete-room-btn');
        const confirmDeleteRoomBtn = document.getElementById('confirm-delete-room-btn');
        const deleteRoomName = document.getElementById('delete-room-name');

        const manageBackupsBtn = document.getElementById('manage-backups-btn');
        const backupsModalOverlay = document.getElementById('backups-modal-overlay');
        const backupsModal = document.getElementById('backups-modal');
        const closeBackupsModalBtn = document.getElementById('close-backups-modal-btn');
        const createNewBackupBtn = document.getElementById('create-new-backup-btn');
        const backupsList = document.getElementById('backups-list');

        const restoreConfirmModalOverlay = document.getElementById('restore-confirm-modal-overlay');
        const cancelRestoreBtn = document.getElementById('cancel-restore-btn');
        const confirmRestoreBtn = document.getElementById('confirm-restore-btn');
        const restoreBackupName = document.getElementById('restore-backup-name');

        const nicknameModalOverlay = document.getElementById('nickname-modal-overlay');
        const nicknameModalTitle = document.getElementById('nickname-modal-title');
        const nicknameInput = document.getElementById('nickname-input');
        const saveNicknameBtn = document.getElementById('save-nickname-btn');
        const cancelNicknameBtn = document.getElementById('cancel-nickname-btn');

        const boardPasswordModalOverlay = document.getElementById('board-password-modal-overlay');
        const boardPasswordName = document.getElementById('board-password-name');
        const boardPasswordInput = document.getElementById('board-password-input');
        const cancelBoardPasswordBtn = document.getElementById('cancel-board-password-btn');
        const submitBoardPasswordBtn = document.getElementById('submit-board-password-btn');

        const newBoardPasswordModalOverlay = document.getElementById('new-board-password-modal-overlay');
        const newBoardName = document.getElementById('new-board-name');
        const newBoardPasswordInput = document.getElementById('new-board-password-input');
        const cancelNewBoardBtn = document.getElementById('cancel-new-board-btn');
        const submitNewBoardBtn = document.getElementById('submit-new-board-btn');

        const deleteBackupModalOverlay = document.getElementById('delete-backup-modal-overlay');
        const deleteBackupName = document.getElementById('delete-backup-name');
        const cancelDeleteBackupBtn = document.getElementById('cancel-delete-backup-btn');
        const confirmDeleteBackupBtn = document.getElementById('confirm-delete-backup-btn');

        const inviteModalOverlay = document.getElementById('invite-modal-overlay');
        const closeInviteModalBtn = document.getElementById('close-invite-modal-btn');
        const generateViewerLinkBtn = document.getElementById('generate-viewer-link-btn');
        const ownerGenerateViewerLinkBtn = document.getElementById('owner-generate-viewer-link-btn');
        const ownerGenerateEditorLinkBtn = document.getElementById('owner-generate-editor-link-btn');
        const inviteLinkDisplay = document.getElementById('invite-link-display');
        const inviteLinkInput = document.getElementById('invite-link-input');
        const copyInviteLinkBtn = document.getElementById('copy-invite-link-btn');

        const kickConfirmModalOverlay = document.getElementById('kick-confirm-modal-overlay');
        const kickUserName = document.getElementById('kick-user-name');
        const cancelKickBtn = document.getElementById('cancel-kick-btn');
        const confirmKickBtn = document.getElementById('confirm-kick-btn');
        
        const kickedModalOverlay = document.getElementById('kicked-modal-overlay');
        const kickedOkBtn = document.getElementById('kicked-ok-btn');

        const invalidInviteModalOverlay = document.getElementById('invalid-invite-modal-overlay');
        const invalidInviteOkBtn = document.getElementById('invalid-invite-ok-btn');

        const boardSettingsBtn = document.getElementById('board-settings-btn');
        const boardSettingsModalOverlay = document.getElementById('board-settings-modal-overlay');
        const settingsBoardName = document.getElementById('settings-board-name');
        const boardPasswordChangeInput = document.getElementById('board-password-change-input');
        const removePasswordCheckbox = document.getElementById('remove-password-checkbox');
        const cancelBoardSettingsBtn = document.getElementById('cancel-board-settings-btn');
        const submitBoardSettingsBtn = document.getElementById('submit-board-settings-btn');

        const errorModalOverlay = document.getElementById('error-modal-overlay');
        const errorModalTitle = document.getElementById('error-modal-title');
        const errorModalText = document.getElementById('error-modal-text');
        const errorModalOkBtn = document.getElementById('error-modal-ok-btn');

        let app, db, auth, userId;
        let itemsCol, connectionsCol, drawingsCol, usersCol, backupsCol, invitesCol, boardRef;
        let unsubscribeItems, unsubscribeConnections, unsubscribeDrawings, unsubscribeUsers, unsubscribeBackups, unsubscribeUserDoc;
        let currentBoardId = null; 

        let userNickname = "User";
        let currentUserRole = "viewer"; 
        let isBoardOwner = false;
        let canEdit = false;
        let presenceInterval;
        let pendingRestoreBackupId = null;
        let pendingKickUid = null;

        const PENCIL_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>`;
        const ERASER_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                  <path d="M16.142 3.858a2.25 2.25 0 00-3.182 0L4.3 12.518a2.25 2.25 0 000 3.182l.06.06a2.25 2.25 0 003.182 0L16.2 6.9a2.25 2.25 0 000-3.182l-.06-.06zM5.57 14.43a.75.75 0 01-1.06 0l-.06-.06a.75.75 0 010-1.06l8.66-8.66a.75.75 0 011.06 0l.06.06a.75.75 0 010 1.06l-8.66 8.66z" />
                                </svg>`;

        const MIN_DRAW_DISTANCE = 4;
        const GRID_SIZE = 20;

        let items = new Map();
        let connections = [];
        let itemConnectionsMap = new Map();

        let isDragging = false;
        let isResizing = false;
        let isDrawingLine = false;
        let isPanning = false;
        let isSelecting = false;
        let isDrawingFreehand = false;
        let isDraggingPanel = false;

        let drawingLineType = 'solid';
        let drawTool = 'pencil';

        let currentElement = null;
        let currentItemForMenu = null;
        let selectedItems = new Map();
        let selectedLines = new Map();
        let selectedLine = null;

        let startPos = { x: 0, y: 0 };
        let startSize = { w: 0, h: 0 };
        let panelStartPos = { x: 0, y: 0 };

        let lineStartIdentifier = null;
        let tempLine = null;
        let currentFreehandPath = null;
        let currentFreehandPoints = [];
        let currentFreehandPathString = "";

        let zIndexCounter = 10;
        let cursorMode = 'move';
        let snapToGrid = false;

        let scale = 1;
        let translateX = 0;
        let translateY = 0;

        let lastMousePos = { x: 0, y: 0 };
        let lineClickPos = { x: 0, y: 0 };

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = {
            apiKey: "AIzaSyCZjIpFdU4AX-4vwDfUlCEqw88_9p5YgLw",
            authDomain: "evidence-board.firebaseapp.com",
            projectId: "evidence-board",
            storageBucket: "evidence-board.firebasestorage.app",
            messagingSenderId: "63512059873",
            appId: "1:63512059873:web:23d55acfebc8744a5d7ca0",
            measurementId: "G-GQRV3HBDX1"
        };

        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            setLogLevel('Debug');
        } catch (e) {
            console.error("Firebase initialization error:", e);
            board.innerHTML = `<div class="text-red-500 p-4">Error initializing Firebase. Please check config.</div>`;
        }

        function showModalPrompt(overlay, inputEl, submitBtn, cancelBtn = null, data = {}) {
            return new Promise((resolve) => {
                overlay.style.display = 'flex';
                inputEl.value = data.defaultValue || '';
                
                if (data.title) data.titleEl.textContent = data.title;
                if (data.text) data.textEl.innerHTML = data.text;
                if (data.placeholder) inputEl.placeholder = data.placeholder;

                inputEl.focus();

                const onSubmit = (e) => {
                    e.preventDefault();
                    cleanup();
                    resolve(inputEl.value);
                };

                const onCancel = (e) => {
                    if (e) e.preventDefault();
                    cleanup();
                    resolve(null);
                };
                
                const onEnter = (e) => {
                    if (e.key === 'Enter') {
                        onSubmit(e);
                    }
                };

                submitBtn.addEventListener('click', onSubmit);
                inputEl.addEventListener('keydown', onEnter);
                if (cancelBtn) cancelBtn.addEventListener('click', onCancel);

                function cleanup() {
                    overlay.style.display = 'none';
                    submitBtn.removeEventListener('click', onSubmit);
                    inputEl.removeEventListener('keydown', onEnter);
                    if (cancelBtn) cancelBtn.removeEventListener('click', onCancel);
                }
            });
        }

        function showModalConfirm(overlay, confirmBtn, cancelBtn, data = {}) {
            return new Promise((resolve) => {
                overlay.style.display = 'flex';
                if (data.text) data.textEl.innerHTML = data.text;

                const onConfirm = () => {
                    cleanup();
                    resolve(true);
                };

                const onCancel = () => {
                    cleanup();
                    resolve(false);
                };

                confirmBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);

                function cleanup() {
                    overlay.style.display = 'none';
                    confirmBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                }
            });
        }

        function showModalAlert(overlay, okBtn, data = {}) {
             overlay.style.display = 'flex';
             if (data.title && data.titleEl) data.titleEl.textContent = data.title;
             if (data.text && data.textEl) data.textEl.innerHTML = data.text;

             const onOk = () => {
                 overlay.style.display = 'none';
                 okBtn.removeEventListener('click', onOk);
                 if(data.callback) data.callback();
             };
             okBtn.addEventListener('click', onOk);
        }

        function setupFirestoreListeners(boardId) { 
            if (unsubscribeItems) unsubscribeItems();
            if (unsubscribeConnections) unsubscribeConnections();
            if (unsubscribeDrawings) unsubscribeDrawings();
            if (unsubscribeUsers) unsubscribeUsers();
            if (unsubscribeBackups) unsubscribeBackups();
            if (unsubscribeUserDoc) unsubscribeUserDoc();

            items.forEach(item => item.el.remove());
            items.clear();
            connections.forEach(conn => {
                conn.lineEl.remove();
                conn.hitBoxEl.remove();
                if (conn.arrowHead) conn.arrowHead.remove();
            });
            connections = [];
            drawingGroup.innerHTML = '';
            itemConnectionsMap.clear();

            boardRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', boardId);
            itemsCol = collection(boardRef, 'items');
            connectionsCol = collection(boardRef, 'connections');
            drawingsCol = collection(boardRef, 'drawings');
            usersCol = collection(boardRef, 'users');
            backupsCol = collection(boardRef, 'backups');
            invitesCol = collection(boardRef, 'invites');

            unsubscribeItems = onSnapshot(itemsCol, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const id = change.doc.id;

                    if (change.type === 'added') {
                        renderItem(id, data);
                    }
                    if (change.type === 'modified') {
                        const item = items.get(id);
                        if (item) {
                            item.el.style.left = data.x;
                            item.el.style.top = data.y;
                            item.el.style.width = data.width;
                            item.el.style.height = data.height;
                            item.el.style.zIndex = data.zIndex;

                            if (data.type === 'note') {
                                const textarea = item.el.querySelector('textarea');
                                if (textarea.value !== data.content) textarea.value = data.content;
                                textarea.style.fontFamily = data.fontFamily;
                                textarea.style.fontSize = data.fontSize;
                            } else if (data.type === 'image') {
                                const captionEl = item.el.querySelector('.caption');
                                if (captionEl.innerHTML !== data.caption) captionEl.innerHTML = data.caption;
                                captionEl.style.display = data.captionVisible ? 'block' : 'none';
                                item.el.querySelector('.image-wrapper').classList.toggle('no-caption', !data.captionVisible);
                                captionEl.style.fontFamily = data.fontFamily;
                                captionEl.style.fontSize = data.fontSize;
                            }
                            item.data = data;
                            updateAllConnectionsForItem(id);
                        }
                    }
                    if (change.type === 'removed') {
                        removeItemLocally(id);
                    }
                });
            });

            unsubscribeConnections = onSnapshot(connectionsCol, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const id = change.doc.id;

                    if (change.type === 'added') {
                        renderConnection(id, data);
                    }
                    if (change.type === 'modified') {
                        const conn = connections.find(c => c.id === id);
                        if (conn) {
                            conn.type = data.type;
                            conn.color = data.color;
                            conn.thickness = data.thickness;
                            conn.startId = data.startId;
                            conn.endId = data.endId;
                            updateConnectionLine(conn);
                        }
                    }
                    if (change.type === 'removed') {
                        removeConnectionLocally(id);
                    }
                });
            });

            const drawingsQuery = query(drawingsCol, orderBy("createdAt"));

            unsubscribeDrawings = onSnapshot(drawingsQuery, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const id = change.doc.id;

                    if (change.type === 'added') {
                        if (data && data.stroke && data.strokeWidth && data.d) { 
                            const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            pathEl.setAttribute('class', 'freehand-drawing');
                            pathEl.setAttribute('vector-effect', 'non-scaling-stroke');
                            pathEl.setAttribute('fill', 'none');
                            pathEl.setAttribute('stroke-linecap', 'round');
                            pathEl.setAttribute('stroke-linejoin', 'round');
                            pathEl.setAttribute('stroke', data.stroke);
                            pathEl.setAttribute('stroke-width', data.strokeWidth);
                            pathEl.setAttribute('d', data.d);
                            pathEl.dataset.id = id;
                            drawingGroup.appendChild(pathEl);
                        }
                    }
                    if (change.type === 'modified') {
                        const pathEl = drawingGroup.querySelector(`path[data-id="${id}"]`);
                        if (pathEl) {
                            pathEl.setAttribute('stroke', data.stroke);
                            pathEl.setAttribute('stroke-width', data.strokeWidth);
                            pathEl.setAttribute('d', data.d);
                        }
                    }
                    if (change.type === 'removed') {
                        const pathEl = drawingGroup.querySelector(`path[data-id="${id}"]`);
                        if (pathEl) {
                            pathEl.remove();
                        }
                    }
                });
            });

            unsubscribeUsers = onSnapshot(usersCol, (snapshot) => {
                const connectedUsers = [];
                snapshot.docs.forEach(userDoc => {
                    connectedUsers.push({ id: userDoc.id, ...userDoc.data() });
                });
                updateUsersModal(connectedUsers);

                const myData = connectedUsers.find(user => user.id === userId);
                if (myData && myData.role !== currentUserRole) {
                    console.log(`User role updated from ${currentUserRole} to ${myData.role}`);
                    currentUserRole = myData.role;

                    setEditingPermissions(currentUserRole === 'owner' || currentUserRole === 'editor');
                }
            });

            unsubscribeUserDoc = onSnapshot(doc(usersCol, userId), (doc) => {
                if (doc.data() && doc.data().kicked === true) {
                    handleKick();
                }
            });

            unsubscribeBackups = onSnapshot(backupsCol, (snapshot) => {
                backupsList.innerHTML = '';
                const docs = snapshot.docs;
                docs.sort((a, b) => b.data().createdAt - a.data().createdAt);

                docs.forEach(backupDoc => {
                    const backup = backupDoc.data();
                    const backupId = backupDoc.id;
                    const date = backup.createdAt?.toDate ? backup.createdAt.toDate().toLocaleString() : 'Unknown Date';

                    const li = document.createElement('li');
                    li.className = 'flex justify-between items-center p-2 border-b border-slate-700 last:border-b-0';
                    li.innerHTML = `
                        <span class="text-sm">${date}</span>
                        <div>
                            <button class="permission-btn promote restore-btn text-xs" data-backup-id="${backupId}" data-backup-name="${date}">Restore</button>
                            <button class="permission-btn demote delete-backup-btn text-xs" data-backup-id="${backupId}">Delete</button>
                        </div>
                    `;
                    backupsList.appendChild(li);
                });
            });
       }

       function handleKick() {
            if (unsubscribeItems) unsubscribeItems();
            if (unsubscribeConnections) unsubscribeConnections();
            if (unsubscribeDrawings) unsubscribeDrawings();
            if (unsubscribeUsers) unsubscribeUsers();
            if (unsubscribeBackups) unsubscribeBackups();
            if (unsubscribeUserDoc) unsubscribeUserDoc();
            if (presenceInterval) clearInterval(presenceInterval);

            showModalAlert(kickedModalOverlay, kickedOkBtn, {
                callback: () => {
                    loadBoard("default-board", null, true);
                }
            });
       }

       backupsList.addEventListener('click', async (e) => {
           const target = e.target;
           if (target.classList.contains('restore-btn')) {
               if (!isBoardOwner) return;
               pendingRestoreBackupId = target.dataset.backupId;
               restoreBackupName.textContent = target.dataset.backupName;
               restoreConfirmModalOverlay.style.display = 'flex';
           } else if (target.classList.contains('delete-backup-btn')) {
               if (!isBoardOwner) return;
               const backupId = target.dataset.backupId;
               const backupNameText = target.closest('li').querySelector('.text-sm').textContent;
               
               const confirmed = await showModalConfirm(
                    deleteBackupModalOverlay,
                    confirmDeleteBackupBtn,
                    cancelDeleteBackupBtn,
                    {
                        text: `Are you sure you want to permanently delete the backup from <strong class="text-white">${backupNameText}</strong>? This action cannot be undone.`,
                        textEl: deleteBackupModalOverlay.querySelector('p')
                    }
               );

               if (confirmed) {
                   deleteBackup(backupId);
               }
           }
       });

       async function deleteBackup(backupId) {
           if (!isBoardOwner) return;
           try {
               await deleteDoc(doc(backupsCol, backupId));
           } catch (e) {
               console.error("Error deleting backup:", e);
           }
       }

       cancelRestoreBtn.addEventListener('click', () => {
           restoreConfirmModalOverlay.style.display = 'none';
           pendingRestoreBackupId = null;
       });

       confirmRestoreBtn.addEventListener('click', () => {
           if (!isBoardOwner || !pendingRestoreBackupId) return;

           const backupId = pendingRestoreBackupId;
           pendingRestoreBackupId = null;
           restoreConfirmModalOverlay.style.display = 'none';

           startRestoreProcess(backupId);
       });

       async function clearBoardContent() {
           if (!isBoardOwner) return;

           const itemsSnap = await getDocs(itemsCol);
           const connectionsSnap = await getDocs(connectionsCol);
           const drawingsSnap = await getDocs(drawingsCol);

           const batch = writeBatch(db);

           itemsSnap.docs.forEach(d => batch.delete(d.ref));
           connectionsSnap.docs.forEach(d => batch.delete(d.ref));
           drawingsSnap.docs.forEach(d => batch.delete(d.ref));

           await batch.commit();
       }

       async function startRestoreProcess(backupId) {
           if (!isBoardOwner) return;

           backupsModalOverlay.style.display = 'none';
           console.log(`Restoring backup ${backupId}...`);

           try {
               const backupRef = doc(backupsCol, backupId);
               const backupSnap = await getDoc(backupRef);

               if (!backupSnap.exists()) {
                   console.error("Backup not found!");
                   return;
               }

               const backupData = backupSnap.data();

               await clearBoardContent();

               const batch = writeBatch(db);

               if (backupData.items && Array.isArray(backupData.items)) {
                   backupData.items.forEach(item => {

                       const newItemRef = doc(itemsCol, item.id); 
                       const data = { ...item };
                       delete data.id; 
                       batch.set(newItemRef, data);
                   });
               }

               if (backupData.connections && Array.isArray(backupData.connections)) {
                   backupData.connections.forEach(conn => {

                       const newConnRef = doc(connectionsCol, conn.id);
                       const data = { ...conn };
                       delete data.id;
                       batch.set(newConnRef, data);
                   });
               }

               if (backupData.drawings && Array.isArray(backupData.drawings)) {
                   backupData.drawings.forEach(draw => {

                       const newDrawRef = doc(drawingsCol, draw.id);
                       const data = { ...draw };
                       delete data.id;
                       batch.set(newDrawRef, data);
                   });
               }

               await batch.commit();

               console.log("Restore complete.");

           } catch (e) {
               console.error("Error restoring backup:", e);
           }
       }

       createNewBackupBtn.addEventListener('click', async () => {
           if (!isBoardOwner) return;

           const btn = createNewBackupBtn;
           btn.disabled = true;
           btn.textContent = "Creating Backup...";

           try {
               const itemsSnap = await getDocs(itemsCol);
               const connectionsSnap = await getDocs(connectionsCol);
               const drawingsSnap = await getDocs(drawingsCol);

               const itemsData = itemsSnap.docs.map(itemDoc => ({ id: itemDoc.id, ...itemDoc.data() }));
               const connectionsData = connectionsSnap.docs.map(connDoc => ({ id: connDoc.id, ...connDoc.data() }));
               const drawingsData = drawingsSnap.docs.map(drawDoc => ({ id: drawDoc.id, ...drawDoc.data() }));

               await addDoc(backupsCol, {
                   createdAt: serverTimestamp(),
                   items: itemsData,
                   connections: connectionsData,
                   drawings: drawingsData
               });

           } catch (e) {
               console.error("Error creating backup:", e);
           } finally {
               btn.disabled = false;
               btn.textContent = "Create New Backup";
           }
       });

       manageBackupsBtn.addEventListener('click', () => {
           if (!isBoardOwner) return;
           backupsModalOverlay.style.display = 'flex';
       });

       closeBackupsModalBtn.addEventListener('click', () => {
           backupsModalOverlay.style.display = 'none';
       });

       backupsModalOverlay.addEventListener('click', (e) => {
           if (e.target === backupsModalOverlay) {
               backupsModalOverlay.style.display = 'none';
           }
       });

        function updateUsersModal(users) {
            usersList.innerHTML = ''; 

            users.sort((a, b) => {
                const order = { owner: 0, editor: 1, viewer: 2 };
                return (order[a.role] || 9) - (order[b.role] || 9);
            });

            users.forEach(user => {
                if(user.kicked) return;

                const li = document.createElement('li');

                let roleBadge = '';
                if (user.role === 'owner') roleBadge = '<span class="role-badge role-owner">Owner</span>';
                else if (user.role === 'editor') roleBadge = '<span class="role-badge role-editor">Editor</span>';
                else roleBadge = '<span class="role-badge role-viewer">Viewer</span>';

                let permissionButtons = '';
                if (isBoardOwner && user.id !== userId) { 
                    if (user.role === 'viewer') {
                        permissionButtons += `<button class="permission-btn promote" data-uid="${user.id}">Make Editor</button>`;
                    } else if (user.role === 'editor') {
                        permissionButtons += `<button class="permission-btn demote" data-uid="${user.id}">Make Viewer</button>`;
                    }
                    permissionButtons += `<button class="permission-btn kick" data-uid="${user.id}" data-nickname="${user.nickname}">Kick</button>`;
                }

                li.innerHTML = `
                    <span class="truncate ${user.id === userId ? 'font-bold text-indigo-300' : ''}">${user.nickname} ${user.id === userId ? '(You)' : ''}</span>
                    <div>
                        ${roleBadge}
                        ${permissionButtons}
                    </div>
                `;
                usersList.appendChild(li);
            });

            usersList.querySelectorAll('.permission-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const uidToChange = e.target.dataset.uid;
                    if (e.target.classList.contains('kick')) {
                        const nickToKick = e.target.dataset.nickname;
                        pendingKickUid = uidToChange;
                        kickUserName.textContent = nickToKick;
                        kickConfirmModalOverlay.style.display = 'flex';
                    } else {
                        const newRole = e.target.classList.contains('promote') ? 'editor' : 'viewer';
                        await changeUserRole(uidToChange, newRole);
                    }
                });
            });
        }

        async function changeUserRole(uid, newRole) {
            if (!isBoardOwner) return; 
            try {
                const userRef = doc(usersCol, uid);
                await updateDoc(userRef, { role: newRole });
            } catch (e) {
                console.error("Error changing user role:", e);
            }
        }

        async function kickUser(uid) {
            if (!isBoardOwner || !uid) return;
            try {
                const userRef = doc(usersCol, uid);
                await updateDoc(userRef, { kicked: true });
            } catch (e) {
                console.error("Error kicking user:", e);
            }
        }

        cancelKickBtn.addEventListener('click', () => {
            kickConfirmModalOverlay.style.display = 'none';
            pendingKickUid = null;
        });

        confirmKickBtn.addEventListener('click', () => {
            kickUser(pendingKickUid);
            kickConfirmModalOverlay.style.display = 'none';
            pendingKickUid = null;
        });

        showUsersBtn.addEventListener('click', () => usersModalOverlay.style.display = 'flex');
        closeUsersModalBtn.addEventListener('click', () => usersModalOverlay.style.display = 'none');
        usersModalOverlay.addEventListener('click', (e) => {
            if (e.target === usersModalOverlay) {
                usersModalOverlay.style.display = 'none';
            }
        });

        inviteBtn.addEventListener('click', () => {
            inviteLinkDisplay.style.display = 'none';
            inviteLinkInput.value = '';
            inviteModalOverlay.style.display = 'flex';
        });

        closeInviteModalBtn.addEventListener('click', () => {
            inviteModalOverlay.style.display = 'none';
        });

        async function generateInviteLink(type) {
            const baseUrl = window.location.origin + window.location.pathname;
            let link = '';

            if (type === 'viewer') {
                link = `https://morsethecode.github.io/board/?board=${currentBoardId}`;
                inviteLinkInput.value = link;
                inviteLinkDisplay.style.display = 'block';
            } else if (type === 'editor' && isBoardOwner) {
                ownerGenerateEditorLinkBtn.disabled = true;
                ownerGenerateEditorLinkBtn.textContent = 'Generating...';
                try {
                    const inviteId = crypto.randomUUID();
                    const inviteRef = doc(invitesCol, inviteId);
                    await setDoc(inviteRef, { 
                        type: 'editor', 
                        createdAt: serverTimestamp() 
                    });
                    link = `https://morsethecode.github.io/board/?board=${currentBoardId}&invite=${inviteId}`;
                    inviteLinkInput.value = link;
                    inviteLinkDisplay.style.display = 'block';
                } catch (e) {
                    console.error("Error generating editor invite:", e);
                    inviteLinkInput.value = 'Error generating link.';
                } finally {
                    ownerGenerateEditorLinkBtn.disabled = false;
                    ownerGenerateEditorLinkBtn.innerHTML = 'Generate Editor Link<br><span class="text-xs font-normal">(Single-Use, Edit Access)</span>';
                }
            }
        }

        generateViewerLinkBtn.addEventListener('click', () => generateInviteLink('viewer'));
        ownerGenerateViewerLinkBtn.addEventListener('click', () => generateInviteLink('viewer'));
        ownerGenerateEditorLinkBtn.addEventListener('click', () => generateInviteLink('editor'));

        copyInviteLinkBtn.addEventListener('click', () => {
            inviteLinkInput.select();
            document.execCommand('copy');
            copyInviteLinkBtn.textContent = 'Copied!';
            setTimeout(() => {
                copyInviteLinkBtn.textContent = 'Copy';
            }, 1500);
        });

        invalidInviteOkBtn.addEventListener('click', () => {
            invalidInviteModalOverlay.style.display = 'none';
        });

        function renderItem(id, data) {
            if (items.has(id)) return; 

            const itemEl = document.createElement('div');
            itemEl.id = id;
            itemEl.className = 'item';
            itemEl.style.left = data.x;
            itemEl.style.top = data.y;
            itemEl.style.width = data.width;
            itemEl.style.height = data.height;
            itemEl.style.zIndex = data.zIndex;

            zIndexCounter = Math.max(zIndexCounter, parseInt(data.zIndex) || 10);
            let contentHtml = '';

            if (data.type === 'note') {
                itemEl.classList.add('bg-yellow-100', 'text-black', 'item-note');
                contentHtml = `
                    <div class="move-handle-note" title="Drag"></div>
                    <textarea class="flex-grow" readonly style="font-family: ${data.fontFamily || "'Brush Script MT', cursive"}; font-size: ${data.fontSize || '16px'};">${data.content || 'Write your note...'}</textarea>
                    <div class="resize-handle-note" title="Resize Note"></div>
                    <div class="edit-btn" title="Edit Note">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                    </div>
                    <div class="delete-btn" title="Delete">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    </div>
                `;
            } else if (data.type === 'image') {
                itemEl.classList.add('item-image');
                itemEl.dataset.aspectRatio = data.aspectRatio;
                contentHtml = `
                    <div class="image-wrapper ${data.captionVisible ? '' : 'no-caption'}"> 
                        <img src="${data.content}" class="w-full h-auto object-cover pointer-events-none" />
                    </div>
                    <div class="caption p-3 pt-1 ${data.caption === 'Click to add caption...' ? 'text-gray-500' : ''}" contenteditable="true" style="display: ${data.captionVisible ? 'block' : 'none'}; font-family: ${data.fontFamily || "'Brush Script MT', cursive"}; font-size: ${data.fontSize || '14px'};">${data.caption || 'Click to add caption...'}</div>
                    <div class="resize-handle-image" title="Resize Image"></div>
                    <div class="edit-btn" title="Add/Edit Caption" style="right: 22px;">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>
                    </div>
                    <div class="delete-btn" title="Delete">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                    </div>
                `;
            } else if (data.type === 'node') {
                itemEl.classList.add('item-node');
                itemEl.dataset.type = 'node';
                itemEl.style.minWidth = '0';
                itemEl.style.minHeight = '0';
                contentHtml = ``;
            }

            itemEl.innerHTML = contentHtml;
            canvasContainer.appendChild(itemEl);
            items.set(id, { el: itemEl, data: data });

            setupItemEventListeners(itemEl, data.type);

            if (data.type === 'node') {
                updateTransform();
            }

            updateAllConnectionsForItem(id);
        }

        function removeItemLocally(id) {
            const item = items.get(id);
            if (item) {
                item.el.remove();
                items.delete(id);
            }
            if (selectedItems.has(id)) {
                selectedItems.delete(id);
            }
            itemConnectionsMap.delete(id);
        }

        function renderConnection(id, data) {
            if (connections.some(c => c.id === id)) return;

            const lineEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            lineEl.setAttribute('class', 'connector-line');

            const hitBoxEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            hitBoxEl.setAttribute('style', 'fill:none; stroke:transparent; stroke-width:20px; vector-effect: non-scaling-stroke; cursor: pointer;');

            const connection = { 
                id: id, 
                startId: data.startId,
                endId: data.endId,
                lineEl, 
                hitBoxEl,
                type: data.type,
                color: data.color,
                thickness: data.thickness,
                arrowHead: null
            };

            hitBoxEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!canEdit) return;
                lineClickPos = { x: e.clientX, y: e.clientY };
                openLineConfigPanel(connection);
            });

            hitBoxEl.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                if (cursorMode === 'move' || cursorMode === 'select') {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleLineSelection(connection, e);
                }
            });

            connections.push(connection);
            svgLayerConnections.appendChild(lineEl);
            svgLayerConnections.appendChild(hitBoxEl);

            if (!itemConnectionsMap.has(data.startId)) itemConnectionsMap.set(data.startId, new Set());
            itemConnectionsMap.get(data.startId).add(id);
            if (!itemConnectionsMap.has(data.endId)) itemConnectionsMap.set(data.endId, new Set());
            itemConnectionsMap.get(data.endId).add(id);

            updateConnectionLine(connection);
        }

        function removeConnectionLocally(id) {
            const index = connections.findIndex(c => c.id === id);
            if (index > -1) {
                const conn = connections[index];

                if (itemConnectionsMap.has(conn.startId)) {
                    itemConnectionsMap.get(conn.startId).delete(id);
                }
                if (itemConnectionsMap.has(conn.endId)) {
                    itemConnectionsMap.get(conn.endId).delete(id);
                }

                conn.lineEl.remove();
                conn.hitBoxEl.remove();
                if (conn.arrowHead) conn.arrowHead.remove();
                connections.splice(index, 1);
            }
        }

        async function mergePath(tempPath) {
            if (!canEdit) return;
            if (!tempPath) return;

            let stroke = tempPath.getAttribute('stroke');
            const strokeWidth = tempPath.getAttribute('stroke-width');
            const d = tempPath.getAttribute('d');

            if (!d || d.length < 2) {
                tempPath.remove();
                return;
            }

            try {
                await addDoc(drawingsCol, {
                    d: d,
                    stroke: stroke,
                    strokeWidth: strokeWidth,
                    createdAt: serverTimestamp() 
                });
            } catch (e) {
                console.error("Error saving drawing: ", e);
            }

            tempPath.remove();
        }

        function midPoint(p1, p2) {
            return {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2
            };
        }

        function updateEraserCursorSize() {
            if (drawTool === 'eraser' && cursorMode === 'draw') {
                const size = parseFloat(eraserSizeSlider.value) * scale;
                eraserCursor.style.width = `${size}px`;
                eraserCursor.style.height = `${size}px`;
            }
        }

        function updatePencilCursor() {
            if (drawTool === 'pencil' && cursorMode === 'draw') {
                const size = parseFloat(drawThicknessInput.value) * scale;
                pencilCursor.style.width = `${size}px`;
                pencilCursor.style.height = `${size}px`;
                pencilCursor.style.backgroundColor = drawColorInput.value;
            }
        }

        eraserSizeSlider.addEventListener('input', updateEraserCursorSize);
        drawThicknessInput.addEventListener('input', updatePencilCursor);
        drawColorInput.addEventListener('input', updatePencilCursor);

        fontSizeSlider.addEventListener('input', async (e) => {
            if (!canEdit || !currentItemForMenu) return;

            const newSize = e.target.value + 'px';
            const itemRef = doc(itemsCol, currentItemForMenu.id);

            try {
                if (currentItemForMenu.classList.contains('item-image')) {
                    await updateDoc(itemRef, { fontSize: newSize });
                } else if (currentItemForMenu.classList.contains('item-note')) {
                    await updateDoc(itemRef, { fontSize: newSize });
                }
            } catch (e) {
                console.error("Error updating font size:", e);
            }
        });
        fontSizeSlider.addEventListener('mousedown', (e) => e.stopPropagation());

        function updateTransform() {
            canvasContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;

            const nodes = document.querySelectorAll('.item-node');
            const counterScale = 1 / scale;
            nodes.forEach(node => {
                node.style.transform = `scale(${counterScale})`;
            });
        }

        const SVG_ORIGIN_X = 10000;
        const SVG_ORIGIN_Y = 10000;

        function worldToSvg(worldPos) {
            return {
                x: worldPos.x + SVG_ORIGIN_X,
                y: worldPos.y + SVG_ORIGIN_Y
            };
        }

        function screenToWorld(x, y) {
            const boardRect = board.getBoundingClientRect();
            const screenX = x - boardRect.left;
            const screenY = y - boardRect.top;
            return {
                x: (screenX - translateX) / scale,
                y: (screenY - translateY) / scale
            };
        }

        function worldToScreen(x, y) {
            const boardRect = board.getBoundingClientRect();
            const screenX = (x * scale) + translateX + boardRect.left;
            const screenY = (y * scale) + translateY + boardRect.top;
            return {
                x: screenX,
                y: screenY
            };
        }

        function updateSelectionVisuals() {
            items.forEach(item => {
                item.el.classList.toggle('selected', selectedItems.has(item.el.id));
            });
            connections.forEach(conn => {
                conn.lineEl.classList.toggle('selected-line', selectedLines.has(conn.id));
            });
        }

        function closeAllPopups() {
            hideLineControlPanel();
            hideItemMenu();
            boardMenu.style.display = 'none';
            drawControls.style.display = 'none';
            toggleDrawControlsBtn.classList.remove('active');
        }

        function clearSelection() {
            selectedItems.clear();
            selectedLines.clear();
            updateSelectionVisuals();
            selectedLine = null;
        }

        async function selectItem(element, e) {
            const ctrlPressed = e && e.ctrlKey;

            if (!ctrlPressed) {
                clearSelection();
            }

            if (ctrlPressed) {
                if (selectedItems.has(element.id)) {
                    selectedItems.delete(element.id);
                } else {
                    selectedItems.set(element.id, element);
                }
            } else {
                selectedItems.set(element.id, element);
            }

            if (canEdit) {
                const newZIndex = ++zIndexCounter;
                element.style.zIndex = newZIndex;

                try {
                    const itemRef = doc(itemsCol, element.id);
                    await updateDoc(itemRef, { zIndex: newZIndex });
                } catch (e) {
                    console.error("Error updating z-index:", e);
                }
            }

            updateSelectionVisuals();
        }

        function toggleLineSelection(lineData, e) {
            const ctrlPressed = e && e.ctrlKey;

            if (!ctrlPressed) {
                clearSelection();
            }

            if (ctrlPressed) {
                if (selectedLines.has(lineData.id)) {
                    selectedLines.delete(lineData.id);
                } else {
                    selectedLines.set(lineData.id, lineData);
                }
            } else {
                selectedLines.set(lineData.id, lineData);
            }

            updateSelectionVisuals();
        }

        function openLineConfigPanel(lineData) {
            if (!canEdit) return;
            clearSelection();
            hideItemMenu();
            boardMenu.style.display = 'none';
            drawControls.style.display = 'none';
            toggleDrawControlsBtn.classList.remove('active');

            lineData.lineEl.classList.add('selected-line');
            selectedLines.set(lineData.id, lineData);
            selectedLine = lineData;
            showLineControlPanel(lineData);
        }

        function showItemMenu(itemEl, e) {
            closeAllPopups();
            currentItemForMenu = itemEl;
            const boardRect = board.getBoundingClientRect();

            itemMenu.style.display = 'flex';
            const menuWidth = 190;
            let menuLeft = e.clientX - boardRect.left;

            if (menuLeft + menuWidth > board.offsetWidth) {
                menuLeft = board.offsetWidth - menuWidth - 10;
            }
            menuLeft = Math.max(10, menuLeft);

            let menuTop = e.clientY - boardRect.top;
            const menuHeight = itemMenu.offsetHeight;
            const boardHeight = board.offsetHeight;

            if (menuTop + menuHeight > boardHeight) {
                menuTop = boardHeight - menuHeight - 10;
            }
            menuTop = Math.max(10, menuTop);

            itemMenu.style.left = `${menuLeft}px`;
            itemMenu.style.top = `${menuTop}px`;

            const fontSizeContainer = document.getElementById('font-size-container');

            const isImage = itemEl.classList.contains('item-image');
            const isNote = itemEl.classList.contains('item-note');
            const isNode = itemEl.classList.contains('item-node');
            const captionEl = itemEl.querySelector('.caption');

            const showFontControls = isNote || (isImage && captionEl && captionEl.style.display !== 'none');

            if (canEdit) {
                itemMenuFontBtn.style.display = showFontControls ? 'flex' : 'none';
                fontSizeContainer.style.display = showFontControls ? 'block' : 'none';
                itemMenuConnectBtn.style.display = isNode ? 'flex' : (isNote || isImage ? 'flex' : 'none');
                itemMenuDeleteNodeBtn.style.display = isNode ? 'flex' : 'none';
                itemMenuBringFrontBtn.style.display = 'flex';
                itemMenuSendBackBtn.style.display = 'flex';

                if (showFontControls) {
                    const el = isNote ? itemEl.querySelector('textarea') : itemEl.querySelector('.caption');
                    const currentSize = window.getComputedStyle(el).fontSize;
                    document.getElementById('item-menu-font-size').value = parseFloat(currentSize) || 14;
                }
            } else {
                itemMenuFontBtn.style.display = 'none';
                fontSizeContainer.style.display = 'none';
                itemMenuConnectBtn.style.display = 'none';
                itemMenuDeleteNodeBtn.style.display = 'none';
                itemMenuBringFrontBtn.style.display = 'none';
                itemMenuSendBackBtn.style.display = 'none';
            }

            connectionSubmenu.style.display = 'none';
            fontSubmenu.style.display = 'none';
        }

        function showBoardMenu(e) {
            closeAllPopups();
            const boardRect = board.getBoundingClientRect();
            boardMenu.style.display = 'flex';

            let menuTop = e.clientY - boardRect.top;
            const menuHeight = boardMenu.offsetHeight;
            const boardHeight = board.offsetHeight;

            if (menuTop + menuHeight > boardHeight) {
                menuTop = boardHeight - menuHeight - 10;
            }
            menuTop = Math.max(10, menuTop);

            let menuLeft = e.clientX - boardRect.left;
            const menuWidth = boardMenu.offsetWidth;
            const boardWidth = board.offsetWidth;

            if (menuLeft + menuWidth > boardWidth) {
                menuLeft = boardWidth - menuWidth - 10;
            }
            menuLeft = Math.max(10, menuLeft);

            boardMenu.style.left = `${menuLeft}px`;
            boardMenu.style.top = `${menuTop}px`;

            lastMousePos.x = menuLeft + boardRect.left;
            lastMousePos.y = menuTop + boardRect.top;
        }

        function hideItemMenu() {
            if (itemMenu) itemMenu.style.display = 'none';
            if (connectionSubmenu) connectionSubmenu.style.display = 'none';
            if (fontSubmenu) fontSubmenu.style.display = 'none';
            currentItemForMenu = null;
        }

        function setCursorMode(mode) {
            if (!canEdit && mode === 'draw') mode = 'move'; 

            cursorMode = mode;

            eraserCursor.style.display = 'none';
            pencilCursor.style.display = 'none';
            board.classList.remove('eraser-active');
            board.classList.remove('pencil-active');

            modeMoveBtn.classList.toggle('active', mode === 'move');
            modeSelectBtn.classList.toggle('active', mode === 'select');
            modeDrawBtn.classList.toggle('active', mode === 'draw');

            toggleDrawControlsBtn.style.display = (mode === 'draw') ? 'block' : 'none';
            if (mode !== 'draw') {
                drawControls.style.display = 'none';
                toggleDrawControlsBtn.classList.remove('active');
            }

            if (mode === 'move') {
                board.style.cursor = 'grab';
            } else if (mode === 'select') {
                board.style.cursor = 'default';
            } else if (mode === 'draw') {
                setDrawTool(drawTool);
            }

            svgLayerDrawings.style.pointerEvents = (mode === 'draw' && canEdit) ? 'auto' : 'none';
        }

        modeMoveBtn.addEventListener('click', () => setCursorMode('move'));
        modeSelectBtn.addEventListener('click', () => setCursorMode('select'));
        modeDrawBtn.addEventListener('click', () => {
            if (!canEdit) return;
            setCursorMode('draw');

        });

        toggleSnapGridBtn.addEventListener('click', () => {
            snapToGrid = !snapToGrid;
            toggleSnapGridBtn.classList.toggle('active', snapToGrid);
        });

        toggleDrawControlsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isActive = toggleDrawControlsBtn.classList.toggle('active');
            drawControls.style.display = isActive ? 'flex' : 'none';
        });

        drawControls.addEventListener('mousedown', (e) => e.stopPropagation());

        function setDrawTool(tool) {
            drawTool = tool;
            drawToolPencilBtn.classList.toggle('active', tool === 'pencil');
            drawToolEraserBtn.classList.toggle('active', tool === 'eraser');

            if (tool === 'pencil') {
                modeDrawBtn.innerHTML = PENCIL_ICON_SVG;
                modeDrawBtn.title = 'Draw (Pencil)';
                drawThicknessContainer.style.display = 'block';
                eraserSizeContainer.style.display = 'none';
                drawColorContainer.style.display = 'block';

                board.style.cursor = 'none';
                board.classList.add('pencil-active');
                board.classList.remove('eraser-active');
                pencilCursor.style.display = 'block';
                eraserCursor.style.display = 'none';
                updatePencilCursor();

            } else {
                modeDrawBtn.innerHTML = ERASER_ICON_SVG;
                modeDrawBtn.title = 'Draw (Eraser)';
                drawThicknessContainer.style.display = 'none';
                eraserSizeContainer.style.display = 'block';
                drawColorContainer.style.display = 'none';

                board.style.cursor = 'none';
                board.classList.add('eraser-active');
                board.classList.remove('pencil-active');
                eraserCursor.style.display = 'block';
                pencilCursor.style.display = 'none';
                updateEraserCursorSize();
            }
        }

        drawToolPencilBtn.addEventListener('click', () => setDrawTool('pencil'));
        drawToolEraserBtn.addEventListener('click', () => setDrawTool('eraser'));

        linePanelHandle.addEventListener('mousedown', (e) => {
            e.stopPropagation(); 
            isDraggingPanel = true;
            const panelRect = lineControlPanel.getBoundingClientRect();
            panelStartPos.x = e.clientX - panelRect.left;
            panelStartPos.y = e.clientY - panelRect.top;

            linePanelHandle.style.cursor = 'grabbing';

            document.addEventListener('mousemove', onPanelMouseMove);
            document.addEventListener('mouseup', onPanelMouseUp);
        });

        function onPanelMouseMove(e) {
            if (!isDraggingPanel) return;
            e.preventDefault();

            const boardRect = board.getBoundingClientRect();
            let newX = (e.clientX - panelStartPos.x) - boardRect.left;
            let newY = (e.clientY - panelStartPos.y) - boardRect.top;

            newX = Math.max(10, Math.min(newX, board.offsetWidth - lineControlPanel.offsetWidth - 10));
            newY = Math.max(10, Math.min(newY, board.offsetHeight - lineControlPanel.offsetHeight - 10));

            lineControlPanel.style.left = `${newX}px`;
            lineControlPanel.style.top = `${newY}px`;
        }

        function onPanelMouseUp(e) {
            isDraggingPanel = false;
            linePanelHandle.style.cursor = 'grab';
            document.removeEventListener('mousemove', onPanelMouseMove);
            document.removeEventListener('mouseup', onPanelMouseUp);
        }

        board.addEventListener('contextmenu', (e) => {
            e.preventDefault();

            const target = e.target;
            const isControl = target.classList.contains('delete-btn') ||
                              target.closest('.delete-btn') ||
                              target.classList.contains('edit-btn') ||
                              target.closest('.edit-btn') ||
                              target.classList.contains('resize-handle-note') ||
                              target.closest('.resize-handle-note') ||
                              target.classList.contains('resize-handle-image') ||
                              target.closest('.resize-handle-image') ||
                              target.classList.contains('move-handle-note') ||
                              target.closest('.move-handle-note');

            if (isControl) {
                return;
            }

            lastMousePos = { x: e.clientX, y: e.clientY };
            const isBoardClick = e.target === board || e.target === canvasContainer || e.target === svgLayerConnections || e.target.closest('#svg-layer-drawings');

            if (isBoardClick) {
                showBoardMenu(e);
            } else {
                const itemEl = e.target.closest('.item');
                if(itemEl) {
                    e.stopPropagation();
                    showItemMenu(itemEl, e);
                } else {
                    closeAllPopups();
                }
            }
        });

        board.addEventListener('mousedown', (e) => {
            closeAllPopups();

            const isBoardClick = e.target === board || e.target === canvasContainer || e.target === svgLayerConnections || e.target.closest('#svg-layer-drawings');

            if (cursorMode === 'draw' && !isBoardClick) {
                const itemEl = e.target.closest('.item');
                if (itemEl) {
                    e.stopPropagation();
                    selectItem(itemEl, e);
                    onItemDragStart(e, itemEl);
                    return;
                }
            }

            if (!isBoardClick) return;

            startPos.x = e.clientX;
            startPos.y = e.clientY;

            if (!e.ctrlKey) {
                clearSelection();
            }

            if (cursorMode === 'move') {
                isPanning = true;
                startPos.x = e.clientX - translateX;
                startPos.y = e.clientY - translateY;
                board.style.cursor = 'grabbing';
            } 
            else if (cursorMode === 'select') {
                isSelecting = true;
                selectionBox.style.display = 'block';

                const boardRect = board.getBoundingClientRect();
                const selBoxStartX = e.clientX - boardRect.left;
                const selBoxStartY = e.clientY - boardRect.top;

                selectionBox.style.left = `${selBoxStartX}px`;
                selectionBox.style.top = `${selBoxStartY}px`;
                selectionBox.style.width = '0px';
                selectionBox.style.height = '0px';
            }
            else if (cursorMode === 'draw') {
                if (!canEdit) return;
                isDrawingFreehand = true;
                const worldPos = screenToWorld(e.clientX, e.clientY);
                const svgPos = worldToSvg(worldPos);

                currentFreehandPoints = [svgPos]; 
                currentFreehandPathString = `M${svgPos.x} ${svgPos.y}`;

                currentFreehandPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                currentFreehandPath.setAttribute('class', 'temp-drawing-path');
                currentFreehandPath.setAttribute('d', currentFreehandPathString); 
                currentFreehandPath.setAttribute('vector-effect', 'non-scaling-stroke');
                currentFreehandPath.setAttribute('fill', 'none');
                currentFreehandPath.setAttribute('stroke-linecap', 'round');
                currentFreehandPath.setAttribute('stroke-linejoin', 'round');

                if (drawTool === 'pencil') {
                    currentFreehandPath.setAttribute('stroke', drawColorInput.value);
                    currentFreehandPath.setAttribute('stroke-width', drawThicknessInput.value);
                } else {
                    currentFreehandPath.setAttribute('stroke', 'url(#dot-grid)'); 
                    currentFreehandPath.setAttribute('stroke-width', eraserSizeSlider.value);
                }

                tempDrawingGroup.appendChild(currentFreehandPath); 
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        board.addEventListener('mousemove', (e) => {
            if (cursorMode === 'draw') {
                if (drawTool === 'eraser') {
                    eraserCursor.style.left = `${e.clientX}px`;
                    eraserCursor.style.top = `${e.clientY}px`;
                } else {
                    pencilCursor.style.left = `${e.clientX}px`;
                    pencilCursor.style.top = `${e.clientY}px`;
                }
            }

            lastMousePos = { x: e.clientX, y: e.clientY };
        });

        board.addEventListener('wheel', (e) => {
            e.preventDefault();

            const boardRect = board.getBoundingClientRect();
            const mouseX = e.clientX - boardRect.left;
            const mouseY = e.clientY - boardRect.top;

            const mouseWorldX_before = (mouseX - translateX) / scale;
            const mouseWorldY_before = (mouseY - translateY) / scale;

            const scaleFactor = (e.deltaY > 0) ? 0.9 : 1.1;
            let newScale = scale * scaleFactor;
            scale = Math.max(0.1, Math.min(newScale, 3.0));

            translateX = mouseX - mouseWorldX_before * scale;
            translateY = mouseY - mouseWorldY_before * scale;

            updateTransform();
            updateEraserCursorSize();
            updatePencilCursor();

        });

        board.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        });

        board.addEventListener('drop', (e) => {
            e.preventDefault();
            closeAllPopups();
            if (!canEdit) return;

            if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        createItem('image', event.target.result, e.clientX, e.clientY);
                    };
                    reader.readAsDataURL(file);
                    return;
                }
            }
        });

        board.addEventListener('mouseenter', () => {
            if (cursorMode === 'draw' && canEdit) {
                if (drawTool === 'eraser') {
                    eraserCursor.style.display = 'block';
                } else {
                    pencilCursor.style.display = 'block';
                }
            }
        });
        board.addEventListener('mouseleave', () => {
            eraserCursor.style.display = 'none';
            pencilCursor.style.display = 'none';
        });

        document.addEventListener('keydown', async (e) => {
            if (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable || document.activeElement.tagName === 'INPUT') {
                return;
            }
            if (!canEdit) return;

            if (e.key === 'Delete' || e.key === 'Backspace') {
                
                const itemsToDelete = Array.from(selectedItems.keys());
                for (const id of itemsToDelete) {
                    await deleteItem(id, true); 
                }
                selectedItems.clear();

                if (selectedLines.size > 0) {
                    const lineBatch = writeBatch(db);
                    selectedLines.forEach((line, id) => {
                        lineBatch.delete(doc(connectionsCol, id));
                    });
                    selectedLines.clear();
                    await lineBatch.commit().catch(e => console.error("Error deleting selected lines:", e));
                }
            }
        });

        document.addEventListener('paste', onPaste);

        async function onPaste(e) {
            if (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.isContentEditable) {
                return;
            }

            e.preventDefault();
            closeAllPopups();
            if (!canEdit) return;

            if (e.clipboardData && e.clipboardData.files && e.clipboardData.files.length > 0) {
                const imageFile = Array.from(e.clipboardData.files).find(f => f.type.startsWith('image/'));
                if (imageFile) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        createItem('image', event.target.result, lastMousePos.x, lastMousePos.y);
                    };
                    reader.readAsDataURL(imageFile);
                    return;
                }
            }

            await handlePasteLegacy();
        }

        async function handlePasteLegacy() {
            if (!canEdit) return;
            try {
                const clipboardItems = await navigator.clipboard.read();

                for (const item of clipboardItems) {
                    const imageType = item.types.find(type => type.startsWith('image/'));
                    if (imageType) {
                        const blob = await item.getType(imageType);
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            createItem('image', event.target.result, lastMousePos.x, lastMousePos.y);
                        };
                        reader.readAsDataURL(blob);
                        return;
                    }

                    if (item.types.includes('text/plain')) {
                        const blob = await item.getType('text/plain');
                        const text = await blob.text();
                        if (text) {
                            createItem('note', text, lastMousePos.x, lastMousePos.y);
                        }
                        return;
                    }
                }
            } catch (err) {
                console.error('Failed to read clipboard contents: ', err);
            }
        }

        async function createItem(type, content = '', x = 50, y = 50) {
            if (!canEdit) return null;

            const boardRect = board.getBoundingClientRect();
            const viewMin = screenToWorld(boardRect.left, boardRect.top);
            const viewMax = screenToWorld(boardRect.right, boardRect.bottom);
            const worldPos = screenToWorld(x, y);

            let itemWidth = 200;
            let itemHeight = 150;

            if (type === 'image') {
                itemWidth = 250;
                itemHeight = 200; 
            } else if (type === 'node') {
                itemWidth = 20;
                itemHeight = 20;
            }

            let finalX = worldPos.x - (itemWidth / 2);
            let finalY = worldPos.y - (itemHeight / 2);

            finalX = Math.max(viewMin.x + 5, Math.min(finalX, viewMax.x - itemWidth - 5));
            finalY = Math.max(viewMin.y + 5, Math.min(finalY, viewMax.y - itemHeight - 5));

            const itemData = {
                type: type,
                x: `${finalX}px`,
                y: `${finalY}px`,
                zIndex: ++zIndexCounter,
            };

            if (type === 'note') {
                itemData.width = '200px';
                itemData.height = '150px';
                itemData.content = content || 'Write your note...';
                itemData.fontFamily = "'Brush Script MT', cursive";
                itemData.fontSize = '16px';
            } else if (type === 'image') {
                itemData.width = '250px';
                itemData.height = 'auto';
                itemData.content = content;
                itemData.caption = 'Click to add caption...';
                itemData.captionVisible = false;
                itemData.fontFamily = "'Brush Script MT', cursive";
                itemData.fontSize = '14px';

                const img = new Image();
                img.onload = () => {
                    itemData.aspectRatio = img.naturalHeight / img.naturalWidth;
                    addDoc(itemsCol, itemData).catch(e => console.error("Error creating item: ", e));
                };
                img.src = content;
                return; 
            } else if (type === 'node') {
                itemData.width = '20px';
                itemData.height = '20px';
            }

            try {
                const docRef = await addDoc(itemsCol, itemData);
                return docRef.id;
            } catch (e) {
                console.error("Error creating item: ", e);
                return null;
            }
        }

        async function setupItemEventListeners(itemEl, type) {

            itemEl.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                closeAllPopups();

                const target = e.target;
                const isTextarea = target.tagName === 'TEXTAREA';
                const isEditable = (isTextarea && !target.readOnly) || target.isContentEditable;

                const isControl = target.classList.contains('move-handle-note') ||
                                  target.classList.contains('delete-btn') ||
                                  target.closest('.delete-btn') ||
                                  target.classList.contains('edit-btn') ||
                                  target.closest('.edit-btn') ||
                                  target.classList.contains('resize-handle-note') ||
                                  target.closest('.resize-handle-note') ||
                                  target.classList.contains('resize-handle-image') ||
                                  target.closest('.resize-handle-image');

                if ((isEditable || isControl) && canEdit) {
                    if (isEditable) {
                        target.focus();
                    }
                    e.stopPropagation();
                    return;
                }

                selectItem(itemEl, e);
                e.stopPropagation();

                if (cursorMode === 'move' || (cursorMode === 'draw' && canEdit)) {
                    onItemDragStart(e, itemEl);
                }
            });

            itemEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const target = e.target;
                const isControl = target.classList.contains('delete-btn') ||
                                  target.closest('.delete-btn') ||
                                  target.classList.contains('edit-btn') ||
                                  target.closest('.edit-btn') ||
                                  target.classList.contains('resize-handle-note') ||
                                  target.closest('.resize-handle-note') ||
                                  target.classList.contains('resize-handle-image') ||
                                  target.closest('.resize-handle-image') ||
                                  target.classList.contains('move-handle-note') ||
                                  target.closest('.move-handle-note');
                if (isControl) return;
                showItemMenu(itemEl, e);
            });

            if (type === 'image') {
                itemEl.querySelector('.resize-handle-image').addEventListener('mousedown', onResizeStart);
                itemEl.querySelector('.edit-btn').addEventListener('mousedown', (e) => {
                    if (!canEdit || e.button !== 0) return;
                    e.stopPropagation();
                    selectItem(itemEl, e);
                    onToggleCaption(e, itemEl);
                });

                const captionEl = itemEl.querySelector('.caption');
                captionEl.addEventListener('blur', async () => {
                    if (!canEdit) return;
                    const itemRef = doc(itemsCol, itemEl.id);
                    await updateDoc(itemRef, { caption: captionEl.innerHTML });
                });

            } else if (type === 'note') {
                const textarea = itemEl.querySelector('textarea');
                const editBtn = itemEl.querySelector('.edit-btn');

                editBtn.addEventListener('mousedown', (e) => {
                    if (!canEdit || e.button !== 0) return;
                    e.stopPropagation();
                    selectItem(itemEl, e);
                    if (textarea.readOnly) {
                        textarea.readOnly = false;
                        setTimeout(() => {
                            textarea.focus();
                            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                        }, 0);
                    } else {
                        textarea.readOnly = true;
                    }
                });

                textarea.addEventListener('blur', async () => {
                    if (!canEdit) return;
                    textarea.readOnly = true;
                    const itemRef = doc(itemsCol, itemEl.id);
                    await updateDoc(itemRef, { content: textarea.value });
                });

                itemEl.querySelector('.resize-handle-note').addEventListener('mousedown', onResizeStart);
                itemEl.querySelector('.move-handle-note').addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    closeAllPopups(); 
                    e.stopPropagation();
                    selectItem(itemEl, e);
                    onItemDragStart(e, itemEl);
                });
            }

            if (type !== 'node') {
                itemEl.querySelector('.delete-btn').addEventListener('mousedown', onDelete);
            }

            const captionEl = itemEl.querySelector('.caption');
            if (captionEl) {
                captionEl.addEventListener('focus', () => {
                    if (!canEdit) {
                        captionEl.blur();
                        return;
                    }
                    if (captionEl.innerHTML === 'Click to add caption...') {
                        captionEl.innerHTML = '';
                        captionEl.classList.remove('text-gray-500');
                    }
                });
                captionEl.addEventListener('blur', () => {
                    if (captionEl.innerHTML.trim() === '' || captionEl.innerHTML === '<br>') {
                        captionEl.innerHTML = 'Click to add caption...';
                        captionEl.classList.add('text-gray-500');
                    }
                });
            }
        }

        async function onToggleCaption(e, itemEl) {
            if (!canEdit) return;
            e.stopPropagation();
            const targetItem = itemEl || currentItemForMenu;
            if (!targetItem) return;

            const captionEl = targetItem.querySelector('.caption');
            const wrapperEl = targetItem.querySelector('.image-wrapper');
            let isVisible = false;

            if (captionEl && wrapperEl) {
                if (captionEl.style.display === 'none' || captionEl.style.display === '') {
                    isVisible = true;
                    captionEl.focus();
                }
            }

            try {
                const itemRef = doc(itemsCol, targetItem.id);
                await updateDoc(itemRef, { captionVisible: isVisible });
            } catch (err) {
                console.error("Error toggling caption: ", err);
            }

            if (!itemEl) {
                hideItemMenu();
            }
        }

        boardMenuAddNoteBtn.addEventListener('click', () => {
            if (!canEdit) return;
            createItem('note', '', lastMousePos.x, lastMousePos.y);
            closeAllPopups();
        });

        boardMenuAddNodeBtn.addEventListener('click', () => {
            if (!canEdit) return;
            createItem('node', '', lastMousePos.x, lastMousePos.y);
            closeAllPopups();
        });

        boardMenuPasteBtn.addEventListener('click', () => {
            if (!canEdit) return;
            onPaste({ clipboardData: null, preventDefault: () => {} });
            closeAllPopups();
        });

        addImageInput.addEventListener('change', (e) => {
            if (!canEdit) return;
            const file = e.target.files[0];
            if (file && file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    createItem('image', event.target.result, lastMousePos.x, lastMousePos.y);
                };
                reader.readAsDataURL(file);
            }
            e.target.value = null;
            closeAllPopups();
        });

        async function batchDelete(collectionRef, querySnapshot) {
            if (!canEdit) return;
            const batch = writeBatch(db);
            querySnapshot.docs.forEach((docToDelete) => {
                batch.delete(docToDelete.ref);
            });
            await batch.commit();
        }

        clearNotesBtn.addEventListener('click', async () => {
            if (!canEdit) return;
            try {
                const q = query(itemsCol, where('type', '==', 'note'));
                const snapshot = await getDocs(q);
                await batchDelete(itemsCol, snapshot);
            } catch (e) {
                console.error("Error clearing notes:", e);
            }
        });

        clearImagesBtn.addEventListener('click', async () => {
            if (!canEdit) return;
            try {
                const q = query(itemsCol, where('type', '==', 'image'));
                const snapshot = await getDocs(q);
                await batchDelete(itemsCol, snapshot);
            } catch (e) {
                console.error("Error clearing images:", e);
            }
        });

        clearLinesBtn.addEventListener('click', async () => {
            if (!canEdit) return;
             try {
                const snapshot = await getDocs(connectionsCol);
                await batchDelete(connectionsCol, snapshot);
            } catch (e) {
                console.error("Error clearing lines:", e);
            }
        });

        clearDrawingsBtn.addEventListener('click', async () => {
            if (!canEdit) return;
             try {
                const snapshot = await getDocs(drawingsCol);
                await batchDelete(drawingsCol, snapshot);
            } catch (e) {
                console.error("Error clearing drawings:", e);
            }
        });

        async function clearAllBoard(isDeletingRoom = false) {
            if (!canEdit) return;
            await clearNotesBtn.click();
            await clearImagesBtn.click();
            await clearLinesBtn.click();
            await clearDrawingsBtn.click();

            try {
                const q = query(itemsCol, where('type', '==', 'node'));
                const snapshot = await getDocs(q);
                await batchDelete(itemsCol, snapshot);
            } catch (e) {
                console.error("Error clearing nodes:", e);
            }

            if (!isDeletingRoom) {
                translateX = 0;
                translateY = 0;
                scale = 1;
                updateTransform();
            }
        }

        clearAllBtn.addEventListener('click', () => clearAllBoard(false));

        deleteRoomBtn.addEventListener('click', () => {
            if (!isBoardOwner) return;
            deleteRoomName.textContent = currentBoardId;
            deleteRoomModalOverlay.style.display = 'flex';
        });

        cancelDeleteRoomBtn.addEventListener('click', () => {
            deleteRoomModalOverlay.style.display = 'none';
        });

        confirmDeleteRoomBtn.addEventListener('click', async () => {
            if (!isBoardOwner) return;

            try {
                await clearAllBoard(true); 

                if (boardRef) {
                    await deleteDoc(boardRef);
                }

                deleteRoomModalOverlay.style.display = 'none';
                loadBoard("default-board"); 

            } catch (e) {
                console.error("Error deleting room:", e);
                deleteRoomModalOverlay.style.display = 'none';
            }
        });

        let dragOffsets = new Map();

        function onItemDragStart(e, itemEl) {
            if (!canEdit || isResizing || isDrawingLine) return;

            e.preventDefault();
            isDragging = true;
            currentElement = itemEl;
            dragOffsets.clear();

            const worldMouse = screenToWorld(e.clientX, e.clientY);

            if (!selectedItems.has(itemEl.id)) {
                 clearSelection();
                 selectItem(itemEl, null);
            }

            selectedItems.forEach((el, id) => {
                 const worldLeft = parseFloat(el.style.left);
                 const worldTop = parseFloat(el.style.top);

                 dragOffsets.set(id, {
                     startX: worldLeft,
                     startY: worldTop
                 });
            });

            const clickedItemStart = dragOffsets.get(currentElement.id);
            startPos.x = worldMouse.x - clickedItemStart.startX;
            startPos.y = worldMouse.y - clickedItemStart.startY;

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function onResizeStart(e) {
            if (!canEdit || e.button !== 0) return;
            e.preventDefault();
            e.stopPropagation();

            isResizing = true;
            currentElement = e.target.closest('.item');
            clearSelection();
            selectItem(currentElement, e);

            const computedStyle = window.getComputedStyle(currentElement);
            startSize.w = parseFloat(computedStyle.width);
            startSize.h = parseFloat(computedStyle.height);

            startPos.x = e.clientX;
            startPos.y = e.clientY;

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        async function deleteItem(id, skipConfirm = false) {
            if (!canEdit || !items.has(id)) return;

            try {
                const batch = writeBatch(db);

                batch.delete(doc(itemsCol, id));

                const q1 = query(connectionsCol, where('startId', '==', id));
                const q2 = query(connectionsCol, where('endId', '==', id));

                const [snap1, snap2] = await Promise.all([getDocs(q1), getDocs(q2)]);

                snap1.docs.forEach(d => batch.delete(d.ref));
                snap2.docs.forEach(d => batch.delete(d.ref));

                await batch.commit();

                hideLineControlPanel();
            } catch (e) {
                console.error("Error deleting item and its connections:", e);
            }
        }

        function onDelete(e) {
            if (!canEdit || e.button !== 0) return;
            e.stopPropagation();
            const itemEl = e.target.closest('.item');
            deleteItem(itemEl.id, true);
        }

        async function startDrawingLine(e, identifier, lineType) {
            if (!canEdit) return;
            e.preventDefault();
            e.stopPropagation();

            isDrawingLine = true;
            drawingLineType = lineType;

            let startPoint;
            let startId = identifier; 

            if (!items.has(identifier)) {
                const clickedConn = connections.find(c => c.id === identifier);
                if (!clickedConn) {
                    isDrawingLine = false;
                    return;
                }

                const oldStartId = clickedConn.startId;
                const oldEndId = clickedConn.endId;
                const oldType = clickedConn.type;
                const oldThickness = clickedConn.thickness;

                const currentDrawingLineType = drawingLineType;
                const currentThickness = lineThicknessInput.value;

                await deleteLine(clickedConn.id);

                drawingLineType = oldType;
                lineThicknessInput.value = oldThickness;

                const newNodeId = await createItem('node', '', lineClickPos.x, lineClickPos.y);
                if (!newNodeId) { 
                    isDrawingLine = false;
                    return;
                }

                await createConnection(oldStartId, newNodeId);
                await createConnection(newNodeId, oldEndId);

                drawingLineType = currentDrawingLineType;
                lineThicknessInput.value = currentThickness;

                startId = newNodeId;

                let newNodeEl = items.get(newNodeId)?.el;
                let attempts = 0;
                while(!newNodeEl && attempts < 50) {
                    await new Promise(r => setTimeout(r, 100)); 
                    newNodeEl = items.get(newNodeId)?.el;
                    attempts++;
                }

                if (!newNodeEl) { 
                    isDrawingLine = false;
                    return;
                }
                startPoint = getElementCenter(newNodeEl);

            } else {
                const startEl = items.get(identifier)?.el;
                if (!startEl) {
                    isDrawingLine = false;
                    return;
                }
                startPoint = getElementCenter(startEl);
            }

            lineStartIdentifier = startId; 

            if (!startPoint) {
                isDrawingLine = false;
                return;
            }

            const svgStart = worldToSvg(startPoint);

            tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tempLine.setAttribute('class', 'connector-line');
            tempLine.setAttribute('style', 'pointer-events: none;');

            const thickness = lineThicknessInput.value;
            tempLine.setAttribute('stroke-width', thickness);

            tempLine.setAttribute('stroke', 'url(#threadPattern)');
            if (lineType === 'dotted') {
                const dash = thickness * 2;
                const gap = thickness;
                tempLine.setAttribute('stroke-dasharray', `${dash} ${gap}`);
            }

            tempLine.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgStart.x} ${svgStart.y}`);
            svgLayerConnections.appendChild(tempLine);

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);

            hideItemMenu();
            hideLineControlPanel();
        }

        async function createConnection(startId, endId) {
            if (!canEdit || startId === endId) return;

            if (connections.some(c => (c.startId === startId && c.endId === endId) || (c.startId === endId && c.endId === startId))) {
                return;
            }

            const connectionData = { 
                startId,
                endId,
                type: drawingLineType,
                color: lineColorInput.value,
                thickness: parseFloat(lineThicknessInput.value),
            };

            try {
                await addDoc(connectionsCol, connectionData);
            } catch (e) {
                console.error("Error creating connection:", e);
            }
        }

        function getLineMidpoint(connectionId) {
            const parentConn = connections.find(c => c.id === connectionId);
            if (!parentConn) return null;

            let startPoint;
            const startEl = items.get(parentConn.startId)?.el;
            if (!startEl) return null;
            startPoint = getElementCenter(startEl);

            let endPoint;
            const endEl = items.get(parentConn.endId)?.el;
            if (!endEl) return null;
            endPoint = getElementCenter(endEl);

            if (!startPoint || !endPoint) return null;

            return {
                x: (startPoint.x + endPoint.x) / 2,
                y: (startPoint.y + endPoint.y) / 2
            };
        }

        function updateConnectionLine(connection) {
            let startPoint, endPoint;

            const startEl = items.get(connection.startId)?.el;
            if (startEl) startPoint = getElementCenter(startEl);

            const endEl = items.get(connection.endId)?.el;
            if (endEl) endPoint = getElementCenter(endEl);

            if (!startPoint || !endPoint) {
                return;
            }

            let actualStartPoint = { ...startPoint };
            let actualEndPoint = { ...endPoint };

            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const len = Math.sqrt(dx * dx + dy * dy);

            if (len > 0) {
                const nx = dx / len;
                const ny = dy / len;
                const absNx = Math.abs(nx);
                const absNy = Math.abs(ny);

                if (endEl) {
                    const endWidth = parseFloat(window.getComputedStyle(endEl).width);
                    const endHeight = parseFloat(window.getComputedStyle(endEl).height);

                    let insetScaleEnd = 0;
                    if(absNx > 0.001 && absNy > 0.001) {
                        insetScaleEnd = Math.min(endWidth / 2 / absNx, endHeight / 2 / absNy);
                    } else if (absNx > 0.001) {
                        insetScaleEnd = endWidth / 2 / absNx;
                    } else if (absNy > 0.001) {
                        insetScaleEnd = endHeight / 2 / absNy;
                    }

                    actualEndPoint.x = endPoint.x - nx * insetScaleEnd;
                    actualEndPoint.y = endPoint.y - ny * insetScaleEnd;
                }

                if (startEl) {
                    const startWidth = parseFloat(window.getComputedStyle(startEl).width);
                    const startHeight = parseFloat(window.getComputedStyle(startEl).height);

                    let insetScaleStart = 0;
                    if(absNx > 0.001 && absNy > 0.001) {
                        insetScaleStart = Math.min(startWidth / 2 / absNx, startHeight / 2 / absNy);
                    } else if (absNx > 0.001) {
                        insetScaleStart = startWidth / 2 / absNx;
                    } else if (absNy > 0.001) {
                        insetScaleStart = startHeight / 2 / absNy;
                    }

                    actualStartPoint.x = startPoint.x + nx * insetScaleStart;
                    actualStartPoint.y = startPoint.y + ny * insetScaleStart;
                }
            }

            const svgStart = worldToSvg(actualStartPoint);
            const svgEnd = worldToSvg(actualEndPoint);

            connection.lineEl.setAttribute('stroke-width', connection.thickness);

            connection.lineEl.setAttribute('stroke', 'url(#threadPattern)');
            if (connection.type === 'dotted') {
                const thickness = connection.thickness || 3;
                const dash = thickness * 2;
                const gap = thickness;
                connection.lineEl.setAttribute('stroke-dasharray', `${dash} ${gap}`);
            } else {
                connection.lineEl.setAttribute('stroke-dasharray', '0');
            }

            if (connection.arrowHead) {
                connection.arrowHead.remove();
                connection.arrowHead = null;
            }

            connection.lineEl.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgEnd.x} ${svgEnd.y}`);
            connection.hitBoxEl.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgEnd.x} ${svgEnd.y}`);

            if (connection.type === 'arrow') {
                const angle = Math.atan2(actualEndPoint.y - actualStartPoint.y, actualEndPoint.x - actualStartPoint.x);

                const dynamicArrowSize = connection.thickness * 3.5;

                const lineEndX = actualEndPoint.x - dynamicArrowSize * Math.cos(angle);
                const lineEndY = actualEndPoint.y - dynamicArrowSize * Math.sin(angle);
                const svgLineEnd = worldToSvg({ x: lineEndX, y: lineEndY });
                connection.lineEl.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgLineEnd.x} ${svgLineEnd.y}`);
                connection.hitBoxEl.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgLineEnd.x} ${svgLineEnd.y}`);

                const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                arrowHead.setAttribute('fill', 'url(#threadPattern)');
                arrowHead.setAttribute('vector-effect', 'non-scaling-stroke');

                const svgP1 = worldToSvg(actualEndPoint);
                const svgP2 = worldToSvg({ x: actualEndPoint.x - dynamicArrowSize * Math.cos(angle - Math.PI / 6), y: actualEndPoint.y - dynamicArrowSize * Math.sin(angle - Math.PI / 6) });
                const svgP3 = worldToSvg({ x: actualEndPoint.x - dynamicArrowSize * Math.cos(angle + Math.PI / 6), y: actualEndPoint.y - dynamicArrowSize * Math.sin(angle + Math.PI / 6) });

                const arrowPoints = [
                    `${svgP1.x},${svgP1.y}`,
                    `${svgP2.x},${svgP2.y}`,
                    `${svgP3.x},${svgP3.y}`
                ].join(' ');
                arrowHead.setAttribute('points', arrowPoints);

                svgLayerConnections.appendChild(arrowHead);
                connection.arrowHead = arrowHead;
            }
        }

        function updateAllConnectionsForItem(itemId) {
            const connectionIds = itemConnectionsMap.get(itemId);
            if (connectionIds) {
                connectionIds.forEach(connId => {
                    const conn = connections.find(c => c.id === connId);
                    if (conn) {
                        updateConnectionLine(conn);
                    }
                });
            }
        }

        function onMouseMove(e) {

            if (isPanning) {
                e.preventDefault(); 
                translateX = e.clientX - startPos.x;
                translateY = e.clientY - startPos.y;
                updateTransform();
                return;
            }

            const mouseX = e.clientX;
            const mouseY = e.clientY;
            const worldMouse = screenToWorld(mouseX, mouseY);
            const worldMouseX = worldMouse.x;
            const worldMouseY = worldMouse.y;

            if (isDragging) {
                if (!canEdit) return;
                let newClickedItemX = worldMouseX - startPos.x;
                let newClickedItemY = worldMouseY - startPos.y;

                const clickedItemStart = dragOffsets.get(currentElement.id);
                const deltaX = newClickedItemX - clickedItemStart.startX;
                const deltaY = newClickedItemY - clickedItemStart.startY;

                selectedItems.forEach((el, id) => {
                    const originalPos = dragOffsets.get(id);
                    const newX = originalPos.startX + deltaX;
                    const newY = originalPos.startY + deltaY;

                    el.style.left = `${newX}px`;
                    el.style.top = `${newY}px`;

                    updateAllConnectionsForItem(id);
                });

            } else if (isResizing) {
                if (!canEdit) return;
                const deltaX_screen = mouseX - startPos.x;
                const deltaY_screen = mouseY - startPos.y;

                const deltaX_world = deltaX_screen / scale;
                const deltaY_world = deltaY_screen / scale;

                const aspectRatio = currentElement.dataset.aspectRatio;

                if (aspectRatio) {
                    const newWidth = Math.max(150, startSize.w + deltaX_world);
                    currentElement.style.width = `${newWidth}px`;
                    currentElement.style.height = 'auto';
                } else {
                    const newWidth = Math.max(150, startSize.w + deltaX_world);
                    const newHeight = Math.max(100, startSize.h + deltaY_world);

                    currentElement.style.width = `${newWidth}px`;
                    currentElement.style.height = `${newHeight}px`;
                }

                updateAllConnectionsForItem(currentElement.id);

            } else if (isDrawingLine) {
                if (!canEdit) return;
                let startPoint;
                if (!items.get(lineStartIdentifier)) return;
                startPoint = getElementCenter(items.get(lineStartIdentifier).el);

                if(startPoint) {
                    const svgStart = worldToSvg(startPoint);
                    const svgMouse = worldToSvg(worldMouse);
                    tempLine.setAttribute('d', `M${svgStart.x} ${svgStart.y} L${svgMouse.x} ${svgMouse.y}`);
                }
            }
            else if (isSelecting) {
                const boardRect = board.getBoundingClientRect();

                const currentSelX = mouseX - boardRect.left;
                const currentSelY = mouseY - boardRect.top;

                const selBoxStartX = startPos.x - boardRect.left;
                const selBoxStartY = startPos.y - boardRect.top;

                const left = Math.min(selBoxStartX, currentSelX);
                const top = Math.min(selBoxStartY, currentSelY);
                const width = Math.abs(selBoxStartX - currentSelX);
                const height = Math.abs(selBoxStartY - currentSelY);

                selectionBox.style.left = `${left}px`;
                selectionBox.style.top = `${top}px`;
                selectionBox.style.width = `${width}px`;
                selectionBox.style.height = `${height}px`;
            } else if (isDrawingFreehand) {
                if (!canEdit) return;
                const svgPos = worldToSvg(worldMouse);

                const lastPoint = currentFreehandPoints[currentFreehandPoints.length - 1];
                const dx = svgPos.x - lastPoint.x;
                const dy = svgPos.y - lastPoint.y;
                if (Math.sqrt(dx*dx + dy*dy) < MIN_DRAW_DISTANCE) {
                    return;
                }

                currentFreehandPoints.push(svgPos);

                const points = currentFreehandPoints;

                if (points.length > 2) {
                    const last = points[points.length - 1];
                    const secondLast = points[points.length - 2];

                    const M_curr = midPoint(secondLast, last);

                    const newSegment = `Q${secondLast.x},${secondLast.y} ${M_curr.x},${M_curr.y}`;

                    currentFreehandPathString += " " + newSegment;

                    currentFreehandPath.setAttribute('d', currentFreehandPathString);
                }
            }
        }

        async function onMouseUp(e) {
            if (isDrawingLine) {
                if (!canEdit) return;
                let endIdentifier = null;
                const endElement = e.target.closest('.item');
                const endConn = connections.find(c => c.hitBoxEl === e.target);

                if (endElement) {
                    endIdentifier = endElement.id;
                    if (endIdentifier && endIdentifier !== lineStartIdentifier) {
                        await createConnection(lineStartIdentifier, endIdentifier);
                    }
                } else if (endConn && endConn.id !== lineStartIdentifier) { 

                    const oldStartId = endConn.startId;
                    const oldEndId = endConn.endId;
                    const oldType = endConn.type;
                    const oldThickness = endConn.thickness;

                    await deleteLine(endConn.id); 

                    const currentDrawingLineType = drawingLineType;
                    const currentThickness = lineThicknessInput.value;

                    drawingLineType = oldType;
                    lineThicknessInput.value = oldThickness;

                    const newNodeId = await createItem('node', '', e.clientX, e.clientY);

                    if (newNodeId) {
                        await createConnection(lineStartIdentifier, newNodeId);
                        await createConnection(oldStartId, newNodeId);
                        await createConnection(newNodeId, oldEndId);
                    }

                    drawingLineType = currentDrawingLineType;
                    lineThicknessInput.value = currentThickness;
                }

                if(tempLine) tempLine.remove();
                tempLine = null;
            }

            if (isSelecting) {
                selectionBox.style.display = 'none';

                const boardRect = board.getBoundingClientRect();
                const selLeft = parseFloat(selectionBox.style.left) - boardRect.left;
                const selTop = parseFloat(selectionBox.style.top) - boardRect.top;
                const selRight = selLeft + parseFloat(selectionBox.style.width);
                const selBottom = selTop + parseFloat(selectionBox.style.height);

                const worldSel = {
                    left: (selLeft - translateX) / scale,
                    top: (selTop - translateY) / scale,
                    right: (selRight - translateX) / scale,
                    bottom: (selBottom - translateY) / scale
                };

                if (!e.ctrlKey) {
                    clearSelection();
                }

                items.forEach((item, id) => {
                    const itemStyle = window.getComputedStyle(item.el);
                    const itemLeft = parseFloat(itemStyle.left);
                    const itemTop = parseFloat(itemStyle.top);
                    const itemRight = itemLeft + (item.el.offsetWidth / scale);
                    const itemBottom = itemTop + (item.el.offsetHeight / scale);

                    if (worldSel.left < itemRight && worldSel.right > itemLeft &&
                        worldSel.top < itemBottom && worldSel.bottom > itemTop) 
                    {
                        selectedItems.set(id, item.el);
                    }
                });

                connections.forEach(conn => {
                    const midPoint = getLineMidpoint(conn.id);
                    if (midPoint) {
                        if (worldSel.left < midPoint.x && worldSel.right > midPoint.x &&
                            worldSel.top < midPoint.y && worldSel.bottom > midPoint.y)
                        {
                            selectedLines.set(conn.id, conn);
                        }
                    }
                });

                updateSelectionVisuals();
            }

            if (isDrawingFreehand) {
                if (!canEdit) return;

                if (drawTool === 'pencil') {
                    if (currentFreehandPoints.length > 1) {
                        const last = currentFreehandPoints[currentFreehandPoints.length - 1];
                        const newSegment = `L${last.x},${last.y}`;
                        currentFreehandPathString += " " + newSegment;
                        currentFreehandPath.setAttribute('d', currentFreehandPathString);
                    }
                    await mergePath(currentFreehandPath); 
                } else {
                    if (currentFreehandPath) {
                        const eraserRect = currentFreehandPath.getBBox();
                        currentFreehandPath.remove(); 
                        
                        const pathsToDelete = new Set();
                        const batch = writeBatch(db);

                        drawingGroup.querySelectorAll('path.freehand-drawing').forEach(pathEl => {
                            const pathRect = pathEl.getBBox();
                            if (!(eraserRect.x > pathRect.x + pathRect.width ||
                                  eraserRect.x + eraserRect.width < pathRect.x ||
                                  eraserRect.y > pathRect.y + pathRect.height ||
                                  eraserRect.y + eraserRect.height < pathRect.y)) {
                                
                                pathsToDelete.add(pathEl.dataset.id);
                            }
                        });

                        if (pathsToDelete.size > 0) {
                            pathsToDelete.forEach(id => {
                                batch.delete(doc(drawingsCol, id));
                            });
                            await batch.commit();
                        }
                    }
                }

                currentFreehandPath = null;
                currentFreehandPoints = [];
                currentFreehandPathString = "";
            }

            if (isDragging) {
                if (!canEdit) return;
                const batch = writeBatch(db);
                selectedItems.forEach((el, id) => {
                    let newX = parseFloat(el.style.left);
                    let newY = parseFloat(el.style.top);

                    if (snapToGrid) {
                        newX = Math.round(newX / GRID_SIZE) * GRID_SIZE;
                        newY = Math.round(newY / GRID_SIZE) * GRID_SIZE;
                        el.style.left = `${newX}px`;
                        el.style.top = `${newY}px`;
                        updateAllConnectionsForItem(id);
                    }

                    const itemRef = doc(itemsCol, id);
                    batch.update(itemRef, { x: `${newX}px`, y: `${newY}px` });
                });
                await batch.commit();
            }

            if (isResizing) {
                if (!canEdit) return;
                try {
                    const itemRef = doc(itemsCol, currentElement.id);
                    await updateDoc(itemRef, { 
                        width: currentElement.style.width, 
                        height: currentElement.style.height 
                    });
                } catch(e) {
                    console.error("Error updating size:", e);
                }
            }

            if (isPanning) {
                if (cursorMode === 'move') {
                    board.style.cursor = 'grab';
                }
            }

            isPanning = false;
            isDragging = false;
            isResizing = false;
            isDrawingLine = false;
            isSelecting = false;
            isDrawingFreehand = false;

            currentElement = null;
            lineStartIdentifier = null;
            dragOffsets.clear();

            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }

        function getElementCenter(element) {
            const worldLeft = parseFloat(element.style.left);
            const worldTop = parseFloat(element.style.top);

            const computedStyle = window.getComputedStyle(element);
            const worldWidth = parseFloat(computedStyle.width);
            const worldHeight = parseFloat(computedStyle.height);

            return {
                x: worldLeft + worldWidth / 2,
                y: worldTop + worldHeight / 2
            };
        }

        function showLineControlPanel(lineData) {
            const boardRect = board.getBoundingClientRect();

            let panelX, panelY;
            if (lastMousePos.x > 0) {
                panelX = lastMousePos.x - boardRect.left - 110;
                panelY = lastMousePos.y - boardRect.top - 60;
            } else {

                const midPoint = getLineMidpoint(lineData.id);
                if (midPoint) {
                    const screenPos = worldToScreen(midPoint.x, midPoint.y);
                    panelX = screenPos.x - boardRect.left - 110;
                    panelY = screenPos.y - boardRect.top - 60;
                } else {
                    panelX = 100; panelY = 100;
                }
            }
            const panelHeight = lineControlPanel.offsetHeight || 180; 
            const boardHeight = board.offsetHeight;

            panelX = Math.max(10, Math.min(panelX, board.offsetWidth - 230));
            panelY = Math.max(10, Math.min(panelY, boardHeight - panelHeight - 10));

            lineControlPanel.style.display = 'flex';
            lineControlPanel.style.left = `${panelX}px`;
            lineControlPanel.style.top = `${panelY}px`;

            lineTypeSelect.value = lineData.type;
            lineColorInput.value = lineData.color;
            lineThicknessInput.value = lineData.thickness;

            lineColorControl.style.display = 'none';
            changeDirectionBtn.style.display = (lineData.type === 'arrow') ? 'block' : 'none';
        }

        function hideLineControlPanel() {
            lineControlPanel.style.display = 'none';
            selectedLine = null;
            changeDirectionBtn.style.display = 'none';
        }

        async function deleteLine(lineId) {
            if (!canEdit) return;
            try {
                await deleteDoc(doc(connectionsCol, lineId));
            } catch (e) {
                console.error("Error deleting line:", e);
            }
        }

        lineTypeSelect.addEventListener('change', async (e) => {
            if (!canEdit || !selectedLine) return;
            try {
                const lineRef = doc(connectionsCol, selectedLine.id);
                await updateDoc(lineRef, { type: e.target.value });
                changeDirectionBtn.style.display = (e.target.value === 'arrow') ? 'block' : 'none';
            } catch (err) {
                console.error("Error updating line type:", err);
            }
        });

        lineColorInput.addEventListener('input', async (e) => {
            if (!canEdit || !selectedLine) return;
             try {
                const lineRef = doc(connectionsCol, selectedLine.id);
                await updateDoc(lineRef, { color: e.target.value });
            } catch (err) {
                console.error("Error updating line color:", err);
            }
        });

        lineThicknessInput.addEventListener('input', async (e) => {
            if (!canEdit || !selectedLine) return;
             try {
                const lineRef = doc(connectionsCol, selectedLine.id);
                await updateDoc(lineRef, { thickness: parseFloat(e.target.value) });
            } catch (err) {
                console.error("Error updating line thickness:", err);
            }
        });

        connectFromLineBtn.addEventListener('click', (e) => {
            if (!canEdit || !selectedLine) return;
            startDrawingLine(e, selectedLine.id, 'solid');
        });

        changeDirectionBtn.addEventListener('click', async () => {
            if (!canEdit || !selectedLine) return;
            try {
                const lineRef = doc(connectionsCol, selectedLine.id);
                await updateDoc(lineRef, { 
                    startId: selectedLine.endId, 
                    endId: selectedLine.startId 
                });
            } catch (err) {
                console.error("Error changing line direction:", err);
            }
        });

        deleteLineBtn.addEventListener('click', () => {
            if (!canEdit || !selectedLine) return;
            deleteLine(selectedLine.id);
            hideLineControlPanel();
        });

        closeLinePanelBtn.addEventListener('click', hideLineControlPanel);

        lineControlPanel.querySelectorAll('button, input, select').forEach(el => {
            el.addEventListener('mousedown', (e) => e.stopPropagation());
        });

        itemMenu.addEventListener('mousedown', (e) => e.stopPropagation());

        itemMenuFontBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isHidden = fontSubmenu.style.display === 'none' || fontSubmenu.style.display === '';
            fontSubmenu.style.display = isHidden ? 'flex' : 'none';
            connectionSubmenu.style.display = 'none';

            if (isHidden) {
                const subMenuRect = fontSubmenu.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();

                if (subMenuRect.bottom > boardRect.bottom) {
                    const itemMenuRect = itemMenu.getBoundingClientRect();
                    const overflowAmount = subMenuRect.bottom - boardRect.bottom;
                    const currentTop = itemMenuRect.top - boardRect.top;

                    const newTop = currentTop - overflowAmount - 10; 

                    itemMenu.style.top = `${Math.max(10, newTop)}px`;
                }
            }
        });

        fontSubmenu.addEventListener('click', async (e) => {
            e.stopPropagation();
            if (!canEdit || e.target.tagName !== 'BUTTON' || !currentItemForMenu) return;

            const font = e.target.dataset.font;

            try {
                const itemRef = doc(itemsCol, currentItemForMenu.id);
                await updateDoc(itemRef, { fontFamily: font });
            } catch (err) {
                console.error("Error updating font family:", err);
            }

            hideItemMenu();
        });

        itemMenuConnectBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isHidden = connectionSubmenu.style.display === 'none' || connectionSubmenu.style.display === '';
            connectionSubmenu.style.display = isHidden ? 'flex' : 'none';
            fontSubmenu.style.display = 'none';

            if (isHidden) {
                const subMenuRect = connectionSubmenu.getBoundingClientRect();
                const boardRect = board.getBoundingClientRect();

                if (subMenuRect.bottom > boardRect.bottom) {
                    const itemMenuRect = itemMenu.getBoundingClientRect();
                    const overflowAmount = subMenuRect.bottom - boardRect.bottom;
                    const currentTop = itemMenuRect.top - boardRect.top;

                    const newTop = currentTop - overflowAmount - 10;

                    itemMenu.style.top = `${Math.max(10, newTop)}px`;
                }
            }
        });

        itemMenuDeleteNodeBtn.addEventListener('click', (e) => {
            if (!canEdit) return;
            e.stopPropagation();
            if (currentItemForMenu) {
                deleteItem(currentItemForMenu.id, true);
            }
            hideItemMenu();
        });

        itemMenuBringFrontBtn.addEventListener('click', async (e) => {
            if (!canEdit) return;
            e.stopPropagation();
            if (currentItemForMenu) {
                const newZIndex = ++zIndexCounter;
                try {
                    const itemRef = doc(itemsCol, currentItemForMenu.id);
                    await updateDoc(itemRef, { zIndex: newZIndex });
                } catch(err) {
                    console.error("Error bringing to front:", err);
                }
            }
            hideItemMenu();
        });

        itemMenuSendBackBtn.addEventListener('click', async (e) => {
            if (!canEdit) return;
            e.stopPropagation();
            if (currentItemForMenu) {
                 try {
                    const itemRef = doc(itemsCol, currentItemForMenu.id);
                    await updateDoc(itemRef, { zIndex: 9 });
                } catch(err) {
                    console.error("Error sending to back:", err);
                }
            }
            hideItemMenu();
        });

        submenuSolid.addEventListener('click', (e) => startDrawingLine(e, currentItemForMenu.id, 'solid'));
        submenuDotted.addEventListener('click', (e) => startDrawingLine(e, currentItemForMenu.id, 'dotted'));
        submenuArrow.addEventListener('click', (e) => startDrawingLine(e, currentItemForMenu.id, 'arrow'));

        boardMenu.querySelectorAll('button, label').forEach(el => {
            el.addEventListener('mousedown', (e) => e.stopPropagation());
        });

        setCursorMode('move');

        function setEditingPermissions(canUserEdit) {
            canEdit = canUserEdit;

            // Handle read-only first
            if (canEdit) {
                document.body.classList.remove('read-only');
            } else {
                document.body.classList.add('read-only');
                document.body.classList.remove('is-owner'); // Viewers are not owners
                userRoleDisplay.textContent = `Role: Viewer`;
                userRoleDisplay.className = "ml-4 font-bold text-gray-400";
                setCursorMode('move'); 
                return; // Exit here if viewer
            }

            // Handle Owner vs Editor (both can edit)
            if (currentUserRole === 'owner') {
                 document.body.classList.add('is-owner');
                 userRoleDisplay.textContent = `Role: Owner`;
                 userRoleDisplay.className = "ml-4 font-bold text-red-400";
                 
                 // Add owner tag if they are also the owner
                 if (isBoardOwner) {
                    userRoleDisplay.textContent = `Role: Owner`;
                 }
            } else if (currentUserRole === 'editor') {
                 document.body.classList.remove('is-owner');
                 userRoleDisplay.textContent = `Role: Editor`;
                 userRoleDisplay.className = "ml-4 font-bold text-blue-400";
            }
        }

        async function setupPresence() {
            if (presenceInterval) clearInterval(presenceInterval);

            const userRef = doc(usersCol, userId);
            await setDoc(userRef, { 
                nickname: userNickname, 
                role: currentUserRole,
                last_seen: serverTimestamp(),
                kicked: false
            }, { merge: true });

            presenceInterval = setInterval(() => {
                setDoc(userRef, { last_seen: serverTimestamp() }, { merge: true });
            }, 15000); 

            window.onbeforeunload = () => {
                deleteDoc(userRef);
                clearInterval(presenceInterval);
            };
        }

        async function loadBoard(boardId, token = null, forceReload = false) {
            if (!boardId || boardId.trim() === "") {
                boardId = "default-board";
            }
            
            if (!forceReload && boardId === currentBoardId) return;

            document.body.classList.remove('is-owner');

            if (presenceInterval) clearInterval(presenceInterval);
            if (unsubscribeUsers) unsubscribeUsers();
            if (unsubscribeUserDoc) unsubscribeUserDoc();

            const sanitizedBoardId = boardId.trim().replace(/[^a-zA-Z0-9-]/g, '_');
            boardNameDisplay.textContent = `Loading: ${sanitizedBoardId}...`;

            try {
                const boardMetaRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', sanitizedBoardId);
                const boardSnap = await getDoc(boardMetaRef);

                let boardOwnerId = null;

                if (boardSnap.exists()) {
                    const boardData = boardSnap.data();
                    boardOwnerId = boardData.ownerId; 

                    if (boardData.hasPassword) {
                        let passwordCorrect = false;
                        while (!passwordCorrect) {
                            const password = await showModalPrompt(
                                boardPasswordModalOverlay,
                                boardPasswordInput,
                                submitBoardPasswordBtn,
                                cancelBoardPasswordBtn,
                                { 
                                    text: `The board <strong id="board-password-name" class="text-white">${sanitizedBoardId}</strong> is password protected.`,
                                    textEl: boardPasswordModalOverlay.querySelector('p')
                                }
                            );

                            if (password === null) { // User clicked "Cancel"
                                boardNameDisplay.textContent = `Board: ${currentBoardId}`;
                                if(currentBoardId && currentBoardId !== "default-board") {
                                    loadBoard("default-board", null, true);
                                } else if (!currentBoardId) {
                                    // If they cancel on first load, they have no board, load default
                                    loadBoard("default-board", null, true);
                                }
                                return; 
                            }

                            if (password === boardData.password) {
                                passwordCorrect = true; // Exit the loop and proceed
                            } else {
                                // Password was wrong. Show the error modal.
                                await showModalAlert(
                                    errorModalOverlay,
                                    errorModalOkBtn,
                                    {
                                        title: "Password Incorrect",
                                        titleEl: errorModalTitle,
                                        text: "The password you entered is incorrect. Please try again.",
                                        textEl: errorModalText
                                    }
                                );
                                // After clicking "OK", the loop will repeat, showing the password prompt again.
                            }
                        }
                    }
                } else {
                    const newPassword = await showModalPrompt(
                        newBoardPasswordModalOverlay,
                        newBoardPasswordInput,
                        submitNewBoardBtn,
                        cancelNewBoardBtn,
                        {
                            text: `You are creating the board <strong id="new-board-name" class="text-white">${sanitizedBoardId}</strong>.`,
                            textEl: newBoardPasswordModalOverlay.querySelector('p')
                        }
                    );
                    
                    if (newPassword === null) {
                        boardNameDisplay.textContent = `Board: ${currentBoardId}`;
                        return;
                    }

                    let passwordData = { hasPassword: false, ownerId: userId }; 
                    boardOwnerId = userId; 

                    if (newPassword && newPassword.trim() !== "") {
                        passwordData.hasPassword = true;
                        passwordData.password = newPassword;
                    }
                    await setDoc(boardMetaRef, passwordData);
                }

                // Reset kicked flag if user is rejoining after being kicked
                const potentialUsersCol = collection(db, 'artifacts', appId, 'public', 'data', 'boards', sanitizedBoardId, 'users');
                const potentialUserRef = doc(potentialUsersCol, userId);
                if (userId) { // Ensure userId is set before trying to use it
                    const potentialUserSnap = await getDoc(potentialUserRef);
                    if (potentialUserSnap.exists() && potentialUserSnap.data().kicked === true) {
                        await setDoc(potentialUserRef, { kicked: false }, { merge: true });
                        console.log("Reset kicked flag for user rejoining board.");
                    }
                }

                currentBoardId = sanitizedBoardId;
                boardRef = doc(db, 'artifacts', appId, 'public', 'data', 'boards', currentBoardId);
                usersCol = collection(boardRef, 'users');
                invitesCol = collection(boardRef, 'invites');

                const userRef = doc(usersCol, userId);
                const userSnap = await getDoc(userRef);

                let intendedRole = userSnap.exists() ? userSnap.data().role : 'viewer';
                if (boardOwnerId === userId) { 
                    isBoardOwner = true; 
                    intendedRole = 'owner'; 
                } else { 
                    isBoardOwner = false; 
                }

                let inviteConsumed = false;

                if (token && intendedRole !== 'owner') {
                    const inviteRef = doc(invitesCol, token);
                    const inviteSnap = await getDoc(inviteRef);

                    if (inviteSnap.exists() && inviteSnap.data().type === 'editor') {
                        intendedRole = 'editor';
                        await deleteDoc(inviteRef);
                        inviteConsumed = true;
                    } else if (token) {
                        showModalAlert(invalidInviteModalOverlay, invalidInviteOkBtn);
                        inviteConsumed = true;
                    }
                }

                currentUserRole = intendedRole;

                setEditingPermissions(currentUserRole === 'owner' || currentUserRole === 'editor');

                boardNameDisplay.textContent = `Board: ${currentBoardId}`;
                boardNameInput.value = ""; 

                setupFirestoreListeners(currentBoardId);
                setupPresence();

                if (inviteConsumed) {
                    window.history.replaceState({}, document.title, `${window.location.pathname}?board=${currentBoardId}`);
                }

            } catch (e) {
                console.error("Error loading board:", e);
                boardNameDisplay.textContent = `Board: ${currentBoardId}`;
            }
        }

        changeNicknameBtn.addEventListener('click', async () => {
            const newNickname = await showModalPrompt(
                nicknameModalOverlay,
                nicknameInput,
                saveNicknameBtn,
                cancelNicknameBtn,
                { 
                    title: "Change Nickname", 
                    titleEl: nicknameModalTitle, 
                    text: "What would you like to be called?",
                    textEl: nicknameModalOverlay.querySelector('p'),
                    defaultValue: userNickname,
                    placeholder: "Enter your nickname..."
                }
            );

            if (newNickname && newNickname.trim() !== "" && newNickname.trim() !== userNickname) {
                await updateNicknameInFirestore(newNickname.trim());
            }
        });

        async function updateNicknameInFirestore(newNickname) {
            if (!userId || !usersCol) return;
            try {
                const userRef = doc(usersCol, userId);
                await updateDoc(userRef, { nickname: newNickname });
                userNickname = newNickname;
            } catch (e) {
                console.error("Error updating nickname:", e);
            }
        }

        switchBoardBtn.addEventListener('click', () => {
            const newBoardId = boardNameInput.value;
            if (newBoardId && newBoardId.trim() !== "" && newBoardId !== currentBoardId) {
                loadBoard(newBoardId);
            }
        });

        boardNameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                switchBoardBtn.click();
            }
        });

        boardSettingsBtn.addEventListener('click', () => {
            if (!isBoardOwner) return;
            settingsBoardName.textContent = currentBoardId;
            boardPasswordChangeInput.value = '';
            removePasswordCheckbox.checked = false;
            boardPasswordChangeInput.disabled = false;
            boardSettingsModalOverlay.style.display = 'flex';
        });

        boardSettingsModalOverlay.addEventListener('click', (e) => {
            if (e.target === boardSettingsModalOverlay) {
                boardSettingsModalOverlay.style.display = 'none';
            }
        });

        cancelBoardSettingsBtn.addEventListener('click', () => {
            boardSettingsModalOverlay.style.display = 'none';
        });

        removePasswordCheckbox.addEventListener('change', () => {
            if (removePasswordCheckbox.checked) {
                boardPasswordChangeInput.value = '';
                boardPasswordChangeInput.disabled = true;
            } else {
                boardPasswordChangeInput.disabled = false;
            }
        });

        boardPasswordChangeInput.addEventListener('input', () => {
            if (boardPasswordChangeInput.value) {
                removePasswordCheckbox.checked = false;
                boardPasswordChangeInput.disabled = false;
            }
        });

        submitBoardSettingsBtn.addEventListener('click', async () => {
            if (!isBoardOwner || !boardRef) return;

            submitBoardSettingsBtn.disabled = true;
            submitBoardSettingsBtn.textContent = 'Updating...';

            try {
                let dataToUpdate = {};
                if (removePasswordCheckbox.checked) {
                    dataToUpdate = {
                        hasPassword: false,
                        password: deleteField() // Remove the password field
                    };
                } else {
                    const newPassword = boardPasswordChangeInput.value;
                    if (newPassword && newPassword.trim() !== "") {
                        dataToUpdate = {
                            hasPassword: true,
                            password: newPassword.trim()
                        };
                    } else {
                        // User left it blank AND didn't check the box. Treat as "remove password".
                        dataToUpdate = {
                            hasPassword: false,
                            password: deleteField()
                        };
                    }
                }
                await updateDoc(boardRef, dataToUpdate);
                boardSettingsModalOverlay.style.display = 'none';

            } catch (e) {
                console.error("Error updating password:", e);
            } finally {
                submitBoardSettingsBtn.disabled = false;
                submitBoardSettingsBtn.textContent = 'Update';
            }
        });

        boardPasswordChangeInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitBoardSettingsBtn.click();
            }
        });

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                console.log("User authenticated:", userId);

                const urlParams = new URLSearchParams(window.location.search);
                const urlBoardId = urlParams.get('board') || "default-board";
                const urlInviteToken = urlParams.get('invite') || null;

                const defaultNick = `User_${userId.substring(0, 4)}`;
                userNickname = await showModalPrompt(
                    nicknameModalOverlay,
                    nicknameInput,
                    saveNicknameBtn,
                    cancelNicknameBtn,
                    { 
                        title: "Welcome!", 
                        titleEl: nicknameModalTitle, 
                        text: "Please, choose your nickname.",
                        textEl: nicknameModalOverlay.querySelector('p'),
                        defaultValue: defaultNick,
                        placeholder: "Type your nickname..."
                    }
                );

                if (!userNickname || userNickname.trim() === "") {
                    userNickname = defaultNick;
                }

                loadBoard(urlBoardId, urlInviteToken); 

            } else {
                console.log("No user signed in, attempting auth...");
                try {
                    await signInAnonymously(auth);
                } catch (e) {
                    console.error("Authentication failed:", e);
                    board.innerHTML = `<div class="text-red-500 p-4">Authentication Error. Cannot load board.</div>`;
                }
            }
        });
    </script>
</body>

</html>
